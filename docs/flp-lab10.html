<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->


          <h2>От анализа к трансляции</h2>

      <p>Наконец, пора заняться серьёзным делом&nbsp;— трансляцией. Читаемые символы хочется как-то понимать, как-то обрабатывать. А для этого их нужно каким-то образом передавать по цепочке трансляторов.</p>

      <p> Давайте рассуждать, глядя на определение комбинатора <code>>></code>. 
    
	<pre><hs> t1 >> t2 = Parser $ \r -> case run t1 r of
   Ok _ r' -> run t2 r'
   Fail r' -> Fail r'</hs></pre>

	Его тип: </p>

      <pre><hs>(>>) :: Parser i a -> Parser i b -> Parser i b</hs></pre>
      
      <p> Транслятор <code>t2</code> для своей работы не требует значения, возвращаемого транслятором <code>t1</code>. А если бы требовал, то как бы он смог его получить? Самое естественное для функционального языка решение&nbsp;— передать это значение, как аргумент функции, которая принимая и используя его, возвращает новый транслятор. Назовём эту функцию <code>f :: a -> Parser i b</code>.
	
      <p>Получается, нам нужен комбинатор, соединяющий в цепочку транслятор <code>Parser i a</code> и эту функцию. Назовём его <code>>>=</code>.
	<pre><hs> t1 >>= f = Parser $ \r -> case run t1 r of
   Ok x r' -> run (f x) r'
   Fail r' -> Fail r'</hs></pre>

	Тип этого комбинатора:
	<pre><hs>(>>=) :: Parser i a -> (a -> Parser i b) -> Parser i b</hs></pre>
      </p>
         
      <p>Ну, что же, попробуем написать транслятор, определяющий два <em>одинаковых</em> символа подряд, причём неважно каких. Раньше это нам было сделать невозможно:</p>

      <pre><hs>double = next >>= (\x -> term x)</hs></pre>
    
      <pre><ghci><l></l> run double "aab"
<o>Ok 'a' "b"</o>
<l></l> run double "aba"
<o>Fail "ba"</o> </ghci></pre>

      <p> Можно записать и короче:</p>

      <pre><hs>double = next >>= term</hs></pre>
      
      <p>Осталась одна важная деталь: как можно вернуть в качестве результата разбора какую-нибудь комбинацию из предыдущих результатов?</p>

      <p>Для этого определим функцию <code>pure</code>:</p>

      <pre><hs>pure x = Parser $ Ok x</hs></pre>

      <p>Теперь, например, можно прочитать цифру и тут же превратить её в однозначное число с помощью вспомогательной функции <code>digitToInt</code>:</p>

      <pre><hs>num1 = digit >>= (\x -> pure (digitToInt x))
digitToInt x = read [x] :: Int</hs></pre>

      <p>Или ещё проще:</p>

      <pre><hs>num1 = digit >>= (pure . digitToInt)</hs></pre>

      <p>А так&nbsp;— определить выражение для инфиксного сложения двух однозначных чисел:</p>

      <pre><hs>add = num1 >>= (\x -> term '+' >> num1 >>= (\y -> pure (x+y)))</hs></pre>

      <pre><ghci><l></l> run num1 "2"
<o>Ok 2 ""</o>
<l></l> run add "3+2"
<o>Ok 5 ""</o>
</ghci></pre>

      <p>Работает!! Но. Если вам кажется, что этот кошмар из значков и скобок&nbsp;— это абсолютно неудачный способ записывать трансляторы, то я вас поздравляю: вам так не кажется! Потерпите ещё совсем немного, скоро всё станет существенно лучше.</p>


		    <p>Надеюсь вы уже узнали основные признаки монады в том, какие операции определены для трансляторов. Мы определили связывание <code>(>>=)</code>, функцию <code>pure</code>, а также альтернативное выполнение <code>(<|>)</code>. Незнакомым оказался оператор <code>(>>)</code>, но посмотрем внимательно на его определение можно догадаться, что он определяется через оператор <code>(>>=)</code>:</p>
      <p align='center'><tt>x >> f = x >>= (\_ -> f)</tt></p> 
      <p>
        а значит, определён для всех монад.
      </p>
      
      <p>Итак, наш тип <code>Parser</code> является монадой, а значит и аппликативным функтором. Кроме того он ещё и альтернативен. Объявим эти свойства явно. Первым делом, уберём первую строчку программы, скрывающую операторы <code>>></code>, <code>>>=</code> и функцию <code>pure</code>, добавим модуль для работы с монадами и аппликкативными функторами
	<pre><hs>import Control.Monad
import Control.Applicative</hs></pre>
	сотрём (или закомментируем) наше определение оператора <code>>></code>,  а затем объявим наш тип <code>Parser i</code> монадой по всем правилам.</p>

      <pre><hs>instance Monad (Parser i) where
  t >>= f = Parser $ \r -> case run t r of
    Ok x r' -> run (f x) r'
    Fail r' -> Fail r'

instance Functor (Parser i) where
  fmap f p = p >>= (pure . f)

instance Applicative (Parser i) where
  pure = Parser . Ok
  f <*> x = f >>= (<$> x)</hs></pre>

      <p>Реализация экземпляра класса <code>Alternative</code> состоит в определении оператора <code><|></code> и единичного элемента <code>empty</code>, образующих моноид. Роль пустого элемента в нашем случае играет функция, возвращающая <code>Fail</code>. Таким образом, получаем определение для экземпляра класса <code>Alternative</code>:</p>

      <pre><hs>instance Alternative (Parser i) where
  empty = Parser Fail
  t1 <|> t2 = Parser $ \r -> case run t1 r of
    Fail _ -> run t2 r
    Ok x r' -> Ok x r'</hs></pre>


      <task>Перепишите  определение функции <code>num1</code> с использование функториальных свойств трансляторов</task>
      
      <p> Теперь мы можем производить различные действия над результатами трансляции, действуя при этом на сам транслятор. Вот что имеется в виду. </p>

      <pre><ghci><l></l> run ((2*) <$> num1) "5"
<o>Ok 10 ""</o>
<l></l> run ((+) <$> num1 <*> num1) "57"
<o>Ok 12 ""</o>
<l></l> run ((+) <$> num1 <*> (term '+' >> num1)) "5+7"
<o>Ok 12 ""</o>
</ghci></pre>

      <task>Для функторов, кроме функции <code>fmap</code> определён оператор <code><$</code>, который выражается следующим образом:</p>
 <p align='center'><tt>x <$ y = const x <$> y</tt></p> <p>Перепишите определение оператора <code>?></code>, используя оператор <code><$</code></p></task>
      
<p>После того, как мы объявили трансляторы аппликативными функторами, нам стала доступна функция <code>sequence</code>, превращающая список трансляторов в один транслятор, возвращающий список результатов:

      <pre><ghci><l></l> run (sequence [digit, digit, digit]) "1234"
<o>Ok "123" "4"</o></ghci></pre>

      Вот&nbsp;— изящное определение для повторения <code>n</code> раз транслятора <code>p</code>:
      <pre><hs>repeatP n p = sequence $ replicate n p</hs></pre>

      Для этой задачи есть функция <code>replicateM</code>, определённая для любых монад:

      <pre><ghci><l></l> run (replicateM 3 digit) "1234"
<o>Ok "123" "4"</o></ghci></pre>

      Очень полезна функция <code>mapM</code> -- монадический аналог функции отображения <code>map</code>. Посмотрим, что она может нам предложить:

      <pre><ghci><l></l> run (mapM term "cat") "catalog"
<o>Ok "cat" "alog"</o></ghci></pre>

      Из списка символов, <code>mapM term</code> произвела последовательность трансляторов <code>term</code> для этих символов, причём, получившийся транслятор возвращает список результатов этой последовательности. Теперь мы можем определить функцию, распознающую указанную строку:

      <pre><hs>string :: Eq a => [a] -> Parser [a] [a]
string = mapM term </hs></pre>

      <pre><ghci><l></l> run (string "cat") "catalog"
Ok "cat" "alog"</ghci></pre>

<p>После определения комбинатора <code><*></code>, в нашем распоряжении автоматически появилась ещё пара полезных комбинаторов:
    <ul>
      <li> <code>*></code>&nbsp;— игнорирует значение первого аргумента эквивалентен оператору <code>>></code>
      <li> <code><*</code>&nbsp;— игнорирует значение второго аргумента
    </ul>
    Они бывают нужны когда требуется выполнить транслятор в цепочке, но его результат передаваться дальше не будет. Например, пусть нужно чтобы за целым числом следовал пробел. Простая последовательность не годится. мы потеряем прочитанное число:</p>

<pre><ghci><l></l> run (num1 >> term ' ') "1 4"
<o>Ok ' ' "4"</o></ghci></pre>

     <pre><ghci><l></l> run (num1 <* term ' ') "1 4"
<o>Ok 1 "4"</o></ghci></pre>

 <p>А вот&nbsp;— вычитание двух чисел, разделённых знаком <code>'-'</code></p>
				   
     <pre><ghci><l></l> run ((-) <$> num1 <*> (term '-' *> num1)) "5-2"
<o>Ok 3 ""</o></ghci></pre>
</p>
      
      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok a i | Fail i<br/>
(Show, Eq)</p>

<p>Parser i a = Parser { run :: i -> Result i a }<br/>
  (Functor, Applicative, Alternative, Monad)</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic> <der><$> <$</der></p>

<part>комбинаторы</part>
<p><basic><|>  >>=</basic>  <der>>> (*>)  ?></der><br/>
<der><*>  <*  <**></der></p>

<part>элементарные трансляторы</part>
<p><basic>pure</basic> epsilon</p>
	      
<part>трансляторы для коллекций</part>
<p><basic>end next  check</basic>  term<br/>
<der>sequence replicateM mapM</der> </p>

<part>трансляторы для строк</part>
<p>digit space string</p>
</sinopsys>
</details>

<h2>Делай раз! Делай два!</h2>

      <p>Монадам полагается ещё одна привилегия: специальный синтаксис для последовательности действий.</p>

      <p> Выражение <pre><hs> expr1 >> expr2</hs></pre> можно записать так:
	<pre><hs> do expr1
    expr2</hs></pre>
	Выражение <pre><hs> expr1 >>= (\x -> expr2)</hs></pre> так:
	<pre><hs> do x &lt;- expr1
    expr2</hs></pre>
	При этом в блоке <code>do</code> может быть сколько угодно выражений, связанных с символами или нет.

<p>Кроме того, у функции <code>pure</code> есть псевдоним <code>return</code>.</p>
	
<p> Давайте-ка перепишем определения для функций <code>num1</code>, и <code>add</code>  в новом виде:

  <pre><hs>num1 = do
  x <- digit
  return (readInt x)

add = do
  x <- num1
  term '+'
  y <- num1
  return (x+y)   </hs></pre>    

				   
    <p>Правда, стало похоже на императивную программу? Что-то вроде С#:</p>

    <pre><cs>int num() {
  var x = digit();
  return (Int.Parse(x.toString()));
}
	
int add() {
  var x = num();
  term('+');
  var y = num();
  return (x+y);
}</cs></pre>

      <p>В этом нет ничего удивительного. Монады нужны в очень многих приложениях, но на первый план они выступают в задачах, в которых речь идёт о последовательных вычислениях и трансляция&nbsp;— это типичный пример. Действительно, входная цепочка обрабатывается последовательно: сначала один символ, потом второй и т.д. В императивных программах это естественным образом кодируется последовательностью команд. Роль операторов <code>>>=</code> и <code>>></code> в C# играет "точка с запятой" , которой в функциональном программировании нет. Но её можно придумать и реализовать самим такой, какой нам надо. А это и есть&nbsp;— свобода.</p>

<details><summary>Подробности</summary>
  <p>Неужели стоило городить все эти абстракции: монады, аппликативные функторы и комбинаторы для того чтобы переизобрести императивное программирование!? Почему бы сразу не писать всё на C#?</p>
  
  <p> Существенная разница состоит в том, что Haskell позволил нам построить императивное программирование <em>с нужными нам свойствами</em>. Что происходит между командами с программе на C#? Ничего. В нашей программе между строк происходит проверка того, чем завершилось выполнение предыдущей команды, и если разбор оказался неудачным вся цепочка будет прекращена, а информация о неразобранной строке передана альтернативной ветке. В программе на C# для прекращения выполнения пришлось бы пользоваться механизмом исключений, а вместо изящного оператора <code><|></code> выстраивать нагромождение из конструкций <code>try-catch</code>. Сравним цепочку альтернатив:</p>

  <pre><hs> x <- term 'a' <|> term 'b' <|> term 'c'</hs></pre>

  <p>с её реализацией с помощью исключений:</p>

  <pre><cs>var x;
try
{
  x = term('a');
}
catch ()
{
  try
  {
    x = term ('b');
  }
  catch ()
  {
    x = term ('c');
  }
}</cs></pre>

  <p>Ещё хуже дело будет обстоять, если альтернативы будут включать в себя последовательности команд, сокращающие входную строку при разборе L(k)-грамматики. В этом случае при неудачном разборе нужно будет как-то вернуть читаемую строку к первоначальному состоянию перед передачей её в альтернативную ветку, а это ещё больше запутает и загромоздит код программы. Наш оператор <code><|></code> устроен так, что каждой ветке предлагается для разбора одна и та же строка (посмотрите на его определение) и этим все сложности снимаются. Мы сразу получаем LL(k)-транслятор. </p>

  
  <p>Монады и функциональный подход позволяют сколь угодно тонко настраивать контроль над вычислениями и вычислительным потоком, оставляя видимость простого последовательного выполнения команд.</p>

</details>


      
      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

