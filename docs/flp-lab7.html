<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>fmap {
      content: "hello&lt;$&gt;";
    }</style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в функциональном программировании — это больше чем описание данных. Это, в первую очередь, описание структуры образуемой данными, в виде математических законов, справедливых для этой структуры. Мы видели это на примере типов для электрических сопротивлений, разнообразных моноидов, изображений и т. д. Типы могут обладать структурой, которая позволяет не только комбинировать вычисления, но и управлять потоком вычислений. Для управления потоком в императивном программировании используются ветвление, циклы или исключения, в функциональном подходе часть и этой работы берут на себя типы.</p>
      
      <p>Простой и часто встречающийся пример — тип <code>Maybe a</code>, говорящий о&nbsp;том, что величина значения типа <code>a</code> может быть неопределена.</p>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите две функции, связывающие эти два типа  <pre><hs>listToMaybe :: [a] -> Maybe a
maybeToList :: Maybe a -> [a]</hs></pre></task>

      <p>Оператор <code>(&lt;$&gt;)</code> имеет своё имя: <code>fmap</code>  и он определён для всех типов, являющихся <strong>функторами</strong>. Самое общее определение для функтора — это <strong>контекст, в котором производятся вычисления</strong>.</p>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <tt>:t</tt>. Посмотрите (с&nbsp;помощью команды <tt>:i</tt> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <task>С помощью оператора <code>(&lt;$&gt;)</code> удвойте определённые элементы списка:<pre><hs>[Just 2, Nothing, Just 3, Just 15]</hs></pre> </task>
      
      <h2>Аппликативные функторы</h2>
    
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с функторами. Посмотрите на то, как действуют операторы <code>&lt;|&gt;</code> и <code><*></code>, вычислив в <sl>GHCi</sl> следующие выражения.
      <pre><hs> Nothing &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Nothing
 Nothing &lt;|&gt; Nothing
 Nothing &lt;*&gt; Just 5
 Just (4*) &lt;*&gt; Just 5
 Just (2*) &lt;*&gt; Nothing
 (+) &lt;$&gt; Just 3 &lt;*&gt; Just 7
 (+) &lt;$&gt; Nothing &lt;*&gt; Just 7
 (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing</hs></pre>
      Объясните своими словами, для чего нужны операторы <code>&lt;$&gt;</code> (<code>fmap</code>), <code>&lt;|&gt;</code>, <code>&lt;*&gt;</code>, применительно к функтору <code>Maybe</code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните действие выражений:
	<pre><hs>(+2) &lt;$&gt; find (< 2) [2,3,1,4]
(*) &lt;$&gt; find odd [2,3,1,4] &lt;*&gt; find even [2,3,1,4]
(*) &lt;$&gt; find odd [2,6,10,4] &lt;*&gt; find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) &lt;$&gt; lookup "x" vars &lt;*&gt; lookup "a" vars</hs></pre>
 </task>

      <task>Посмотрите на определение функтора <code>Either</code>, и объясните его функториальные свойства, судя по примерам:
	<pre><hs>(*2) &lt;$&gt; Right 4
(*2) &lt;$&gt; Left 4
(*2) &lt;$&gt; Left "hello"
(+) &lt;$&gt; Right 8 &lt;*&gt; Right 5
(+) &lt;$&gt; Left "No!" &lt;*&gt; Right 5 </hs></pre>
      </task>			  

      <task>Напишите функцию <code>sqrtE</code>, которая вычисляет квадратный корень вещественного числа, и для отрицательных чисел возвращает сообщение об ошибке, в виде значения <code>Left "sqrt: got negative argument!"</code>. Вычислите с её помощью  выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>
     
      <task>Поэкспериментируйте с функториальными свойствами типа <code>[]</code>:      <pre><hs>[] &lt;|&gt; [2,3]
[1,2,3] &lt;|&gt; [4,5]
[2] &lt;|&gt; []
[] &lt;|&gt; []
[] &lt;*&gt; [2,3,4]
[(4*)] &lt;*&gt; [2,3,4]
[(4*), (3+)] &lt;*&gt; [2,3,4]
(+) &lt;$&gt; [2,3] &lt;*&gt; [4,5,6]
(+) &lt;$&gt; [] &lt;*&gt; [2,3]
(+) &lt;$&gt; [1,2,3] &lt;*&gt; []</hs></pre>
</task>

      <task> Получите все возможные разбиения строки пробелами
<pre><ghci><l></l> spaces "ABC"
<o>["ABC", "AB C", "A BC", "A B C"]</o></ghci></pre>

<details><summary>Вариант решения</summary>
<pre><hs>spaces s = case s of
    x:xs -> (x :) <$> go xs
    "" -> [""]
  where go s = case s of
    x:xs -> (++ [x]) <$> ["", " "] <*> go xs
    "" -> [""]</hs></pre>
</details></task>

      <task>Напишите функцию <code>sqrtL</code>, которая вычисляет квадратный корень вещественного числа, причём, для положительных аргументов она должна возвращать как положительное, так и отрицательное значение корня, для нулевого — только ноль, а для отрицательных значений — ни одного значения. Вычислите с её помощью выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Посмотрите на определение типа <code>IO</code> и объясните как он действует, в&nbsp;качестве функтора:
	<pre><hs> ("Hello, " ++) &lt;$&gt; getLine
 let readNum = read &lt;$&gt; getLine 
 (+) &lt;$&gt; readNum &lt;*&gt; readNum
 print 6 &lt;|&gt; error "!!"	</hs></pre>
      </task>			  
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В&nbsp;определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>empty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code> (они образуют моноид). </task>

      <task>Напишите универсальную функцию <code>sqrtA</code>, обобщающую функции <code>sqrtM</code> и <code>sqrtL</code> так, чтобы она работала c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code>, причём, для списков, возвращала несколько корней.</task>

      <task>Напишите, используя альтернативные функторы, функцию <code>bisectionA</code>, отыскивающую точку смены заданного условия методом бисекции: <pre><hs>bisectionA :: (Alternative f, Eq a)
  => (Double -> a) -> (Double, Double) -> f Double</hs></pre></task>
      <details><summary>Схема решения</summary>
	<pre><hs>bisection p (a,b)
  -- тестовая функция не меняется на границах
  | ... = empty
  -- достигнута абсолютная или относительная погрешность
  | ... = pure c
  -- шаг бисекции
  | otherwise = bisection p (a,c) <|> bisection p (c,b)
  where c = mean a b</hs></pre></details>
      
<!--       <h2>Управление сообщениями об ошибках</h2> -->
      
<!--       <p>Тип <code>Either</code> похож на тип <code>Maybe</code> тем, что у него есть одно "верное" значение — правое, и "неверное" — левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p> -->

<!--       <p>Однако тип <code>Either</code> не является альтернативным функтором. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>strongpty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>strongpty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p> -->

<!--       <pre><hs>instance Monoid m =&gt; Alternative (Either m) where -->
<!--   strongpty = Left mstrongpty -->
<!--   Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно -->
<!--   Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения -->
<!--   Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения</hs></pre> -->

<!--       <task>Убедитесь на следующих примерах, что приведённое определение работает корректно: -->

<!--       <pre><code>Left "fail" &lt;|&gt; Right 42 -->
<!-- Right 42 &lt;|&gt; Left "fail" -->
<!-- Left "I am " &lt;|&gt; Left "a fail" -->
<!-- </code></pre> -->
<!--       </task> -->

<!-- <p>Для типа <code>Either String</code> определим специальный тип:<pre><hs>type Messaged = Either String</hs></pre></p> -->
      
<!--       <p>Теперь нужно научиться вводить в программу сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали их. Эта возможность должна быть определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>sqrtA</code> для разных контестов, а это уже не DRY (Don't Repeat Yourself — один из универсальных принципов программирования).</p> -->

<!--       <p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в&nbsp;нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию — <code>message</code>.</p> -->

<!--       <pre><hs>class Alternative f =&gt; Failable f where -->
<!--   message :: String -&gt; f a -->
<!--   -- определение, используемое по умолчанию -->
<!--   message _ = strongpty -->
<!-- </hs></pre> -->

<!--       <p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Messaged</code> и <code>IO</code> — специфические:</p> -->

<!--       <pre><hs>instance Failable Maybe -->
<!-- instance Failable [] -->
<!-- instance Failable Messaged where message = Left -->
<!-- instance Failable IO where message = error -->
<!-- </hs></pre> -->

<!--       <task>Внесите в определение функции <code>sqrtA</code> изменения, позволяющие использовать её в четырёх различных контекстах: -->
<!-- 	<pre><hs> sqrtA 16 :: [Double] -->
<!--  sqrtA 16 :: Maybe Double -->
<!--  sqrtA 16 :: Messaged Double -->
<!--  sqrtA 16 -->
<!--  sqrtA (-1) :: [Double] -->
<!--  sqrtA (-1) :: Maybe Double -->
<!--  sqrtA (-1) :: Messaged Double -->
<!--  sqrtA (-1)</hs></pre> -->
<!--       </task> -->
<!--       <p> -->
<!-- 	Нам в дальнейшей работе пригодится класс <code>Failable</code>, поэтому стоит выделить его и определение экземпляров для типов <code>[]</code>, <code>Maybe</code>, <code>Messaged</code> и  <code>IO</code> в отдельный модуль <tt>Failable.hs</tt> -->
<!--       </p> -->

<!--       <task>Перепишите функцию <code>bisection</code>, так, чтобы её тип стал таким: <pre><hs>bisection :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> Double -> Double -> f Double</hs></pre></task> -->


<!--       <task>Подобно тому, как мы интегрировали функцию на указанной сетке, организуйте поиск особых точек методом бисекции на произвольной сетке:<pre><hs>findRoot :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> [Double] -> f Double</hs></pre> При этом для пустой сетки и сетки с единственной точкой должны возвращаться соответствующие сообшения об ошибках.</task> -->

     
      <h2>Монады</h2>
      
      <p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые возвращают значение в контексте? Например, как можно дважды применить функцию <code>sqrtM</code>, чтобы вычислить <eq>\sqrt{\sqrt{16}}</eq>? Иными словами, как выполнить композицию функций, возвращающих не просто значение, а значение в некотором контексте <code>m</code>?</p>
      
      <p>Попробуем начать с использования оператора <code>&lt;$&gt;</code>:
	<pre><ghci><l></l> sqrtM &lt;$&gt; sqrtM 16
<o>Just (Just 2)</o>
<l></l> sqrtM &lt;$&gt; sqrtM (-1)
<o>Just Nothing</o></ghci></pre>
      </p> 
      
      <p>
	Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just 2)</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>Just 2</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление.</p>

      <task> Определите функцию <code>join :: Maybe (Maybe a) -&gt; Maybe a</code>, которая занималась бы "соединением" контекстов так, чтобы можно было получить такие результаты: <pre><ghci><l></l> join $ sqrtM &lt;$&gt; sqrtM 16
<o>Just 4</o>
<l></l> join $ sqrtM &lt;$&gt; sqrtM (-1)
<o>Nothing</o></ghci></pre>
      </task>

      <p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в&nbsp;цепочки любые вычисления с контекстом. Для неё есть особое обозначение: <code>=&lt;&lt;</code></p>

<p align='center'><tt>f =&lt;&lt; x  ≡  join $ f &lt;$&gt; x</tt></p>


      <p>Мы определили для типа <code>Maybe</code> функцию <code>join</code> и сразу повысили его "ранг", позволяя объединять в цепочку функции, возвращающие значения в контексте <code>Maybe</code>. Функторы (аппликативные) для которых определено соединение <code>join</code> называются <strong>монадами</strong>. </p>
      
      <task>Сравните типы операторов <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> и <code>=&lt;&lt;</code> и объясните своими словами их действие в контекстах.</task>

      <p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

      <pre><hs>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</hs></pre>

      <task>Вычислите следующие выражения в интерпретаторе и объясните как происходят вычисления:
	<pre><hs>[-1,0,1,16] &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Just 64 &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Right 16 &gt;&gt;= sqrtA
Right (-16) &gt;&gt;= sqrtA
(read &lt;$&gt; getLine) &gt;&gt;= sqrtA &gt;&gt;= print</hs></pre></task>

      <task>Изучите типы универсальных функций для работы с функторами и монадами
	<pre><ghci>ap
(>=>)
($>)	    
mapM
foldM
sequence
traverse
replicateM</ghci></pre>
	C помощью интерпретатора познакомьтесь с их поведением для типов <code>[]</code>, <code>Maybe </code>, <code>(,) a</code>. </task>

      <h2>Порождающие грамматики</h2>

<p>Используя деревья, мы уже порождали последовательность всех корректных или некорректных скобочных выражений (<a href='flp-lab5.html#tree_brackets'>см. Занятие 5</a>). Но таким образом нельзя создать что-либо сложнее свободного языка двухсимвольного алфавита <tt>(a|b)*</tt>. Аппликативные и альтернативные функторы позволят нам порождать слова для произвольной регулярной грамматики.</p>

<h3>Регулярные грамматики</h3>

<p>Регулярные формальные грамматики определяются алгебраически с помощью трёх операций — объединения (альтернатива), конкатенации (соединения в цепочки) и звезды Клини (многократного повторения), а также трёх базовых конструкций: пустого символа (<eq>\varepsilon</eq>), невозможного символа (<eq>\bot</eq>) и литералов (произвольного и конкретного).</p>

<p>Эту алгебраическую структуру можно выразить таким типом:</p>
<pre><hs>data Grammar a =
  None                            -- невозможный символ
  | Epsilon                       -- пустой символ
  | Term a                        -- конкретный литерал
  | Anything                      -- произвольный литерал
  | Kleene (Grammar a)            -- звезда Клини
  | Alter (Grammar a) (Grammar a) -- объединение
  | Chain (Grammar a) (Grammar a) -- конкатенация
    deriving (Show, Functor)</hs></pre>

<p>Такой тип вполне пригоден для описания произвольных регулярных грамматик, но он крайне неудобен. Для примера опишем регулярное выражение, задающее двоичные числа, кратные трём  <tt>(0|(1(01*0)*1))+</tt>:</p>
<pre>Chain (Alter (Term 0) (Chain (Term 1) (Chain (Kleene (Chain (Term 0)
(Chain (Kleene (Term 1)) (Term 0)))) (Term 1)))) (Kleene (Alter (Term 0)
(Chain (Term 1) (Chain (Kleene (Chain (Term 0) (Chain (Kleene (Term 1))
(Term 0)))) (Term 1)))))</pre>
<p>Как видно, запись получается громоздкой и вовсе нечитабельной. Для упрощения работы, воспользуемся тем, что регулярные грамматики образуют моноид относительно операций объединения и конкатенации с нейтральными элементами <eq>\bot</eq> и <eq>\varepsilon</eq>, соответственно. Это свойство можно выразить с помощью классов <code>Monoid</code> и <code>Alternative</code>:</p>
<pre><hs>instance Monoid (Grammar a) where
  mempty = Epsilon

instance Semigroup (Grammar a) where
  (<>) = Chain

instance Alternative Grammar where
  empty = None
  (<|>) = Alter
         
instance Applicative Grammar where
  pure = Term
  f <*> x = case f of 
     None      -> None
     Epsilon   -> Epsilon
     Anything  -> Anything
     Term f    -> f <$> x
     Kleene f  -> Kleene (f <*> x)
     Alter f g -> (f <*> x) <|> (g <*> x)
     Chain f g -> (f <*> x) <> (g <*> x)</hs></pre>

<p>Ещё стоит создать несколько вспомогательных функций:</p>
  <pre><hs>ch = pure -- указанный литерал
str = foldMap pure -- цепочка указанных литералов
alt = getAlt . foldMap pure -- список возможных литералов
-- здесь используется тип-обёртка Alt, превращающая
-- любой альтернативный функтор в моноид.
oneof g = getAlt . foldMap (Alt . g)  -- список возможных параметризованных грамматик

opt g = Epsilon <|> g  -- необязательное выражение
many g = Kleeny g      -- повторение выражения 0 или более раз
some g = g <> Kleeny g -- повторение выражения 1 или более раз</hs></pre>
  
<p>Теперь запись выражения <nobr><tt>(0|(1(01*0)*1))+</tt></nobr> становится более осмысленной:</p>
<pre>some (ch 0 <|> (ch 1 <> many (ch 0 <> many (ch 1) <> ch 0) <> ch 1))</pre>
<p> Вот, например, как запишутся такие регулярные выражения:</p>
<pre><hs> <tt>b[aeiou]bble</tt>:
   ch 'b' <> alt "aeiou" <> str "bble"
	
 <tt>g(oo)+gle</tt>:
   ch 'g' <> some (str "oo") <> str "gle"

 <tt>x(.x)*</tt>:
   ch 'x' <> many (Anything <> ch 'x')    
 
 <tt>0x[0-9A-F]{2}</tt>:
   str "0x" <> 2 *<> alt (['0'..'9']++['A'..'F'])
     
 <tt>(cat|dog|list) has a? (head|tail)</tt>:
   str `oneof` ["cat","dog","list"] <>
   str " has " <> opt (str "a ")
   str `oneof` ["head","tail"]</hs></pre>

<p>Тип <code>Grammar</code> лишь описывает грамматику, но не наделяет её никакими функциями. Различные её интерпретации позволяют получить любую информацию о языке, который эта грамматика описывает. Такая структура называется <i>свободной грамматикой</i>.</p>


<task>Первая практически важная задача, которую мы рассмотрим, состоит в определении того, содержит ли язык, определяемый грамматикой, пустую строку <eq>\varepsilon</eq>. Напишите код для предиката <code>vanishing</code>, отличающий такие грамматики.</task>

<p>Наличие метасимвола <code>Anything</code> подразумевает, что можно говорить о некотором алфавите, конечном или бесконечном. Для выражения этой мысли определим клас типов <code>Alphabetic</code>:

<pre><hs>class Eq a => Alphabetic a where
  charset :: [a]</hs></pre>

и сразу же определим алфавит для типа <code>Char:</code>

<pre><hs>instance Alphabetic Char where
  charset = ['a'..'z'] ++ [' '..'`']</hs></pre>
</p>

<task>Напишите функцию <code>alphabeth</code>, возвращающую алфавит языка, определяемого грамматикой. Если в определении грамматики используется метасимвол <code>Anything</code>, то используйте набор символов <code>charset</code> для типа <code>a</code>.</task>

<p>Ещё одна полезная задача интерпретации свободной грамматики — определение множества символов, с которого может начинаться слово, соответствующее грамматике. Эта задача возникает при построении конечных атоматов и трансляторов праворекурсивных грамматик. Функция, возвращающая множество возможных первых (лидирующих или направляющих) символов для заданной грамматики, может быть определена так:

<pre><hs><d>leader :: Alphabetic a => Grammar a -> [a]</d>
leader g = case g of
   None      -> empty
   Epsilon   -> mempty
   Term c    -> pure c
   Anything  -> alphabeth g
   Kleene g  -> leader $ opt g
   Alter a b -> leader a `union` leader b
   Chain a b -> leader $ a <|> unless (vanishing a) b</hs></pre>
</p>

<task>Найдите лидирующие символы для следующих выражений:
<pre><hs> ch 'a'
 str "cat" <|> str "dog"
 alt "cat"
 opt (ch 'a') <|> str "dog"
 many (ch 'a')
 many (ch 'a') <> many (ch 'b') <> many (str "cat")</hs></pre>
</task>

<hr/>

<p>В задачах отладки и тестирования очень полезно иметь возможность генерировать слова, соответствующие грамматическим структурам. Генерация может быть детерминированной, то есть, планомерно перечисляющей все варианты (в том числе, и тривиальные, пограничные и вырожденные случаи) либо случайной. О том как в функциональной парадигме создавать случайные величины мы поговорим на следующем занятии, а сейчас рассмотрим задачу детерминированной исчерпывающей генерации всех возможных слов языка, соответствующего регулярной грамматике. И здесь нам опять помогут концепции аппликативных и альтернативных функторов, позволяя дать изящное и универсальное решение:</p>
  
<pre><hs><d>generate :: (Alphabetic a, Alternative f)
         => Grammar a -> f [a]</d>
generate g = case g of
   None           -> empty
   Kleene None    -> empty
   Epsilon        -> pure []
   Kleene Epsilon -> pure []
   Term a         -> pure [a]
   Kleene a       -> generate $ opt (some a)
   Alter a b      -> generate a <|> generate b
   Chain a b      -> (++) <$> generate a <*> generate b</hs></pre>

<p>Используя в качестве функтора <code>f</code> тип <code>[]</code>, мы получим список всех удовлетворяющих грамматике слов, возможно, бесконечный. </p>
<pre><ghci><l></l> let g1 = (str "cat" <|> str "dog") <> alt "ao" <> str "log"
<l></l> generate g1 :: Maybe String
<o>Just "catalog"</o>
<l></l> generate g1 :: [String]
<o>["catalog","catolog","dogalog","dogolog"]</o>
<l></l> take 5 $ generate $ ch 'g' <> some (str "o") <> str "gle"
<o>["gogle","google","gooogle","goooogle","gooooogle"]</o></ghci></pre>

<p>Впрочем, у такого решения есть проблема. Посмотрите, как генерируются слова простой грамматики: <tt>a+b+</tt>:
<pre><ghci><l></l> take 6 $ generate $ some (ch 'a') <> some (ch 'b')
<o>["ab","abb","abbb","abbbb","abbbbb","abbbbbb"]</o></ghci></pre>
Пока не завершится перебор всех вариантов конструкции <tt>b+</tt>, (а он не завершится никогда), мы не получим корректных коротких слов <tt>aab, aaab, aabb</tt> и им подобных.</p>

<p>Аппликативное поведение списков состоит в построчном переборе пространства вариантов:</p>
<p><img src='img/appList.png' width=40%/></p>

<pre><hs>(,) <$> [1,2,3] <*> [1,2,3,4] = 
= [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4)]
	
(,) <$> [1..] <*> [1..] = 
= [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),...</hs></pre>

<p>Если строки бесконечны, то перебор первой строк не завершится никогда и ко второй строке перебор так и не приступит. Разумный перебор потенциально бесконечного многомерного пространства решений — важная часть логического программирования. Можно реализовать иной порядок перебора этого пространства:</p>
<p><img src='img/appLogic.png' width=40%/></p>
<pre><hs>(,) <$> Logic [1,2,3] <*> Logic [1,2,3,4] =
= Logic [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(2,4)...]
 
(,) <$> Logic [1..] <*> Logic [1..] =
= Logic [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1)...]</hs></pre>

Именно так определено аппликативное поведение для типа <code>Logic a</code>, которое задано в библиотеке <a href='../snippets/Logic.hs' target='_blank'><code>Logic</code></a>. Создайте файл <tt>Logic.hs</tt> и подгрузите эту библиотеку к рабочей программе.</p>

<p>Посмотрим на моноидальное и альтернативное поведение функтора <code>Logic</code>:</p>
<pre><ghci><l></l> Logic [1,2,3] <> Logic [5,6,7,8]
<o>Logic [1,2,3,5,6,7,8]</o>
<l></l> Logic [1,2,3] <|> Logic [5,6,7,8]
<o>Logic [1,5,2,6,3,7,8]</o>
<l></l> Logic [1..] <> Logic [-1,-2..]
<o>Logic [1,2,3,4,5,6,7,8,9,10...]</o>
<l></l> Logic [1..] <|> Logic [-1,-2..]
<o>Logic [1,-1,2,-2,3,-3,4,-4,5,-5...]</o></ghci></pre>

<p>Превратить этот список в обычный можно с помощью функции <code>samples</code>:
  <pre><hs>samples :: Logic a -> [a]</hs></pre></p>

<p>Благодаря тому, что функция <code>generate</code> универсальна для любых альтернативных функторов, переключить её работу на функтор <code>Logic</code> не составит труда:</p>
<pre><ghci><l></l> take 10 . samples . generate $ some (ch 'a') <> some (ch 'b')
<o>["ab","abb","aab","abbb","aabb","aaab","abbbb","aabbb","aaabb","aaaab"]</o></ghci></pre>

<p> Оформим отдельную функцию, которая по грамматике возвращает определяемый ею язык.
<pre><hs><d>language :: Alphabetic a => Grammar a -> [[a]]</d>
language = samples . generate</hs></pre></p>

<task>Сгенерируйте язык для грамматик, записанных в форме регулярных выражений:
  <pre> (0|(1(01*0)*1))+
 b[aeiou]bble
 g(ooo)+gle
 0x[0-9A-F]{2}
 (catа|ana|homo)?(log|morphism|lysis)
 [0..9]{2}[+-*/][0..9]{2}</pre></task>

<task>Напишите грамматику для целочисленных полиномов c одной переменной в канонической форме (разложенной в сумму призведений):
  <pre> x^2-10
 x-3*x^4
 -x^4
 8
 -4+45*x^3+6*x^2</pre>
</task>


<h3>Контекстно-свободные грамматики</h3>

<p>До сих пор мы ограничивались регулярными грамматиками. Они в состоянии описывать бесконечные языки, но их алфавит и описание всегда конечны и не содержат самовложений. Используя вмещающий язык и явную рекурсию мы можем с помощью типа <code>Grammar</code> генерировать и нерегулярные грамматики. Приведём классический пример нерегулярного языка: языка Дика, порождаемого грамматикой корректных скобочных выражений </p>
<pre><hs>dyck :: Grammar Char
dyck = ch '(' <> many dyck <> ch ')' <|>
       ch '[' <> many dyck <> ch ']'</hs></pre>
<pre><ghci><l></l> take 20 $ language dyck
<o>["()","[]","(())","[()]","(()())","[()()]","([])","[[]]"
,"(()()())","[()()()]","([]())","[[]()]","((()))","[(())]"
,"(()[])","[()[]]","([]()())","[[]()()]","((())())","[(())()]"]</o></ghci></pre>

<p>В ленивом языке <sl>Haskell</sl> прямая рекурсия в определении грамматики с самовложнием не мешает работе функций <code>language</code> или <code>leader</code>. Но она таит в себе опасность, поскольку определяемая таким образом грамматика, по-существу, является бесконечной. Из-за этого, например, нельзя представить её в форме строки с помощью функции <code>show</code>, либо определить алфавит, даже если он конечен.</p>

<p>Глубиной рекурсии можно явно управлять, например, с помощью счетчика, но существует иной способ, позволяющий анализировать как конечную, так и бесконечную рекурсию вовсе без использования чисел. Перепишем определение грамматики, выведя рекурсивный вызов в параметр:
  <pre><hs>dyck :: Grammar Char -> Grammar Char
dyck f = ch '(' <> many f <> ch ')' <|>
         ch '[' <> many f <> ch ']' <|>
         ch '{' <> many f <> ch '}'</hs></pre>
  
Теперь если передать в качестве параметра какое-либо конечное выражение, мы получим конечное описание грамматики. Такое представление уже даёт возможность получить алфавит языка или множество лидирующих символов:</p>
<pre><ghci><l></l> alphabeth $ dyck Epsilon
<o>"()[]{}"</o>
<l></l> leader $ dyck Epsilon
<o>"([{"</o>
</ghci></pre>
Оно же  позволяет явным образом контролировать глубину рекурсии:
<pre><ghci><l></l> take 20 $ language $ dyck Epsilon
<o>["()","[]"]</o>
<l></l> take 20 $ language $ (dyck . dyck) Epsilon
<o>["()","[]","(())","[()]","(()())","[()()]","([])","[[]]"
,"(()()())","[()()()]","([]())","[[]()]","(()[])","[()[]]"
,"([]()())","[[]()()]","(()()()())","[()()()()]","([][])"]</o></ghci></pre>
Наконец, оно даёт возможность естественным образом определить бесконечную рекурсию, с помощью универсальной комбинатора <code>fix</code>
<pre><hs><d>fix :: (t -> t) -> t</d>
fix f = f (fix f)</hs></pre>
<pre><ghci><l></l> take 20 $ language $ fix dyck
<o>["()","[]","(())","[()]","(()())","[()()]","([])","[[]]"
,"(()()())","[()()()]","([]())","[[]()]","((()))","[(())]"
,"(()[])","[()[]]","([]()())","[[]()()]","((())())","[(())()]"]</o></ghci></pre>
Такой метод используется там, где нет возможности использовать числовые величины, например, при построении рекурсивных типов.</p>

<task>Напишите определение факториала, выведя рекурсивный вызов в параметр.</task>

<task>Опишите грамматику для палиндромов (слов с зеркальной симметрией) в указанном алфавите.</task>

<p>Рассмотрим задачу генерации схем арифметических выражений по простой праворекурсивной грамматике, записанной в расширенной форме Бэкуса-Науэра:

<pre>&lt;expr&gt; ::= &lt;term&gt;{(+|-)&lt;term&gt;}
&lt;term&gt; ::= &lt;mult&gt;{(*|/)&lt;mult&gt;}
&lt;mult&gt; ::= &lt;num&gt; | -&lt;mult&gt; | '('&lt;expr&gt;')'</pre>

<p>Нетерминал <code>&lt;num&gt;</code> оставим пока свободным. Если мы переведём эту грамматику на наш язык, то получится такой код:
<pre><hs><d>arythmetics&apos; :: Grammar Char -> Grammar Char</d>
arythmetics&apos; k = term <> many (alt "+-" <> term)
  where
    term = mult <> many (alt "*/" <> mult)
    mult = alt "1234567890" <|>
           ch '-' <> mult <|>
           ch '(' <> k <> ch ')'

<d>arythmetics :: Grammar Char</d>
arythmetics = fix arythmetics&apos;</hs></pre>

Теперь можно генерировать схемы арифметических выражений:

<pre><ghci><l></l> take 20 $ language arythmetics
<o>["1","1+1","1*1","1+1+1","1*1+1","(1)","1+1*1","1*1+1+1"
,"(1)+1","1*1*1","1+1+1+1","1*1+1*1","(1)+1+1","1*1*1+1"
,"(1)*1","1+1*1+1","1*1+1+1+1","(1)+1*1","1*1*1+1+1"]</o></ghci></pre>
Никакие другие цифры кроме единицы не успели появиться оттого, что перебор цифр происходит на самом глубоком уровне выражения, после перебора вариантов знаков и скобок. На следующем занятии мы увидим, каким образом можно генерировать выражения с более разнообразным, случайным наполнением символами, оставляя структуру детерминистичной. </p>

<task>Опишите грамматику для корректных арифметических выражений в обратной польской нотации. С помощью генерации слов этого языка выясните какие числа можно получить с помощью арифметических выражений, содержащих две, три или четыре двойки. Какое число от 1 до 10 является наиболее "продуктивным", то есть, позволяет получить больше всего разнообразных значений при комбинированни с помощью простой арифметики?</task>

</div>

    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
</body>
</html>
