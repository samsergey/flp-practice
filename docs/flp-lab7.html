
<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>fmap {
      content: "hello&lt;$&gt;";
    }</style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в функциональном программировании — это больше чем описание данных. Это, в первую очередь, описание структуры образуемой данными, в виде математических законов, справедливых для этой структуры. Мы видели это на примере типов для электрических сопротивлений, разнообразных моноидов, изображений и т.д. Типы могут обладать структурой, которая позволяет не только комбинировать вычисления, но и управлять потоком вычислений. Для управления потоком в императивном программировании используются ветвление, циклы или исключения, в функциональном подходе часть и этой работы берут на себя типы.</p>
      
      <task>Простой и часто встречающийся пример — тип <code>Maybe a</code>, говорящий о&nbsp;том, что величина значения типа <code>a</code> может быть неопределена. Посмотрите информацию о типе <code>Maybe</code> с помощью команды <tt>:i</tt>.</task>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите две функции, связывающие эти два типа  <pre><hs>listToMaybe :: [a] -> Maybe a
maybeToList :: Maybe a -> [a]</hs></pre></task>

      <p>Оператор <code>(&lt;$&gt;)</code> имеет своё имя: <code>fmap</code>  и он определён для всех типов, являющихся <strong>функторами</strong>. Самое общее определение для функтора — это <strong>контекст, в котором производятся вычисления</strong>.</p>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <tt>:t</tt>. Посмотрите (с&nbsp;помощью команды <tt>:i</tt> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <h2>Аппликативные функторы</h2>
    
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с функторами. Посмотрите на то, как действуют операторы <code>&lt;|&gt;</code> и <code><*></code>, вычислив в <sl>GHCi</sl> следующие выражения.
      <pre><hs> Nothing &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Nothing
 Nothing &lt;|&gt; Nothing
 Nothing &lt;*&gt; Just 5
 Just (4*) &lt;*&gt; Just 5
 Just (2*) &lt;*&gt; Nothing
 (+) &lt;$&gt; Just 3 &lt;*&gt; Just 7
 (+) &lt;$&gt; Nothing &lt;*&gt; Just 7
 (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing</hs></pre>
      Объясните своими словами, для чего нужны операторы <code>&lt;$&gt;</code> (<code>fmap</code>), <code>&lt;|&gt;</code>, <code>&lt;*&gt;</code>, применительно к функтору <code>Maybe</code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните действие выражений:
	<pre><hs>(+2) &lt;$&gt; find (< 2) [2,3,1,4]
(*) &lt;$&gt; find odd [2,3,1,4] &lt;*&gt; find even [2,3,1,4]
(*) &lt;$&gt; find odd [2,6,10,4] &lt;*&gt; find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) &lt;$&gt; lookup "x" vars &lt;*&gt; lookup "a" vars</hs></pre>
 </task>

      <task>Посмотрите на определение функтора <code>Either</code>, и объясните его функториальные свойства, судя по примерам:
	<pre><hs>(*2) &lt;$&gt; Right 4
(*2) &lt;$&gt; Left 4
(*2) &lt;$&gt; Left "hello"
(+) &lt;$&gt; Right 8 &lt;*&gt; Right 5
(+) &lt;$&gt; Left "No!" &lt;*&gt; Right 5 </hs></pre>
      </task>			  

      <task>Напишите функцию <code>sqrtE</code>, которая вычисляет квадратный корень вещественного числа, и для отрицательных чисел возвращает сообщение об ошибке, в виде значения <code>Left "sqrt: got negative argument!"</code>. Вычислите с её помощью  выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>
     
      <task>Поэкспериментируйте с функториальными свойствами типа <code>[]</code>:      <pre><hs>[] &lt;|&gt; [2,3]
[1,2,3] &lt;|&gt; [4,5]
[2] &lt;|&gt; []
[] &lt;|&gt; []
[] &lt;*&gt; [2,3,4]
[(4*)] &lt;*&gt; [2,3,4]
[(4*), (3+)] &lt;*&gt; [2,3,4]
(+) &lt;$&gt; [2,3] &lt;*&gt; [4,5,6]
(+) &lt;$&gt; [] &lt;*&gt; [2,3]
(+) &lt;$&gt; [1,2,3] &lt;*&gt; []</hs></pre>
</task>

      <task> Получите все возможные разбиения строки пробелами
<pre><ghci><l></l> spaces "ABC"
<o>["ABC", "AB C", "A BC", "A B C"]</o></ghci></pre>

<details><summary>Вариант решения</summary>
<pre><hs>spaces s = case s of
    x:xs -> (x :) <$> go xs
    "" -> [""]
  where go s = case s of
    x:xs -> (++ [x]) <$> ["", " "] <*> go xs
    "" -> [""]</hs></pre>
</details>

      <task>Напишите функцию <code>sqrtL</code>, которая вычисляет квадратный корень вещественного числа, причём, для положительных аргументов она должна возвращать как положительное, так и отрицательное значение корня, для нулевого — только ноль, а для отрицательных значений — ни одного значения. Вычислите с её помощью выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Посмотрите на определение типа <code>IO</code> и объясните как он действует, в&nbsp;качестве функтора:
	<pre><hs> ("Hello, " ++) &lt;$&gt; getLine
 let readNum = read &lt;$&gt; getLine 
 (+) &lt;$&gt; readNum &lt;*&gt; readNum
 print 6 &lt;|&gt; error "!!"	</hs></pre>
      </task>			  
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В&nbsp;определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>empty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code> (они образуют моноид). </task>

      <task>Напишите универсальную функцию <code>sqrtA</code>, обобщающую функции <code>sqrtM</code> и <code>sqrtL</code> так, чтобы она работала c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code>, причём, для списков, возвращала несколько корней.</task>

      <task>Напишите, используя альтернативные функторы, функцию <code>bisectionA</code>, отыскивающую точку смены заданного условия методом бисекции: <pre><hs>bisectionA :: (Alternative f, Eq a)
  => (Double -> a) -> (Double, Double) -> f Double</hs></pre></task>
      <details><summary>Схема решения</summary>
	<pre><hs>bisection test (a, b)
  -- тестовая функция не меняется на границах
  | ... = empty
  -- достигнута абсолютная или относительная погрешность
  | ... = pure c
  -- шаг бисекции
  | otherwise = bisection test (a, c) <|> bisection test (c, b)
  where c = mean a b</hs></pre></details>
      
<!--       <h2>Управление сообщениями об ошибках</h2> -->
      
<!--       <p>Тип <code>Either</code> похож на тип <code>Maybe</code> тем, что у него есть одно "верное" значение — правое, и "неверное" — левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p> -->

<!--       <p>Однако тип <code>Either</code> не является альтернативным функтором. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>strongpty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>strongpty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p> -->

<!--       <pre><hs>instance Monoid m =&gt; Alternative (Either m) where -->
<!--   strongpty = Left mstrongpty -->
<!--   Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно -->
<!--   Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения -->
<!--   Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения</hs></pre> -->

<!--       <task>Убедитесь на следующих примерах, что приведённое определение работает корректно: -->

<!--       <pre><code>Left "fail" &lt;|&gt; Right 42 -->
<!-- Right 42 &lt;|&gt; Left "fail" -->
<!-- Left "I am " &lt;|&gt; Left "a fail" -->
<!-- </code></pre> -->
<!--       </task> -->

<!-- <p>Для типа <code>Either String</code> определим специальный тип:<pre><hs>type Messaged = Either String</hs></pre></p> -->
      
<!--       <p>Теперь нужно научиться вводить в программу сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали их. Эта возможность должна быть определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>sqrtA</code> для разных контестов, а это уже не DRY (Don't Repeat Yourself — один из универсальных принципов программирования).</p> -->

<!--       <p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в&nbsp;нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию — <code>message</code>.</p> -->

<!--       <pre><hs>class Alternative f =&gt; Failable f where -->
<!--   message :: String -&gt; f a -->
<!--   -- определение, используемое по умолчанию -->
<!--   message _ = strongpty -->
<!-- </hs></pre> -->

<!--       <p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Messaged</code> и <code>IO</code> — специфические:</p> -->

<!--       <pre><hs>instance Failable Maybe -->
<!-- instance Failable [] -->
<!-- instance Failable Messaged where message = Left -->
<!-- instance Failable IO where message = error -->
<!-- </hs></pre> -->

<!--       <task>Внесите в определение функции <code>sqrtA</code> изменения, позволяющие использовать её в четырёх различных контекстах: -->
<!-- 	<pre><hs> sqrtA 16 :: [Double] -->
<!--  sqrtA 16 :: Maybe Double -->
<!--  sqrtA 16 :: Messaged Double -->
<!--  sqrtA 16 -->
<!--  sqrtA (-1) :: [Double] -->
<!--  sqrtA (-1) :: Maybe Double -->
<!--  sqrtA (-1) :: Messaged Double -->
<!--  sqrtA (-1)</hs></pre> -->
<!--       </task> -->
<!--       <p> -->
<!-- 	Нам в дальнейшей работе пригодится класс <code>Failable</code>, поэтому стоит выделить его и определение экземпляров для типов <code>[]</code>, <code>Maybe</code>, <code>Messaged</code> и  <code>IO</code> в отдельный модуль <tt>Failable.hs</tt> -->
<!--       </p> -->

<!--       <task>Перепишите функцию <code>bisection</code>, так, чтобы её тип стал таким: <pre><hs>bisection :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> Double -> Double -> f Double</hs></pre></task> -->


<!--       <task>Подобно тому, как мы интегрировали функцию на указанной сетке, организуйте поиск особых точек методом бисекции на произвольной сетке:<pre><hs>findRoot :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> [Double] -> f Double</hs></pre> При этом для пустой сетки и сетки с единственной точкой должны возвращаться соответствующие сообшения об ошибках.</task> -->

      <h2>Монады</h2>
      
      <p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые возвращают значение в контексте? Например, как можно дважды применить функцию <code>sqrtM</code>, чтобы вычислить <eq>\sqrt{\sqrt{16}}</eq>? Иными словами, как выполнить композицию функций, возвращающих не просто значение, а значение в некотором контексте <code>m</code>?</p>
      
      <p>Попробуем начать с использования оператора <code>&lt;$&gt;</code>:
	<pre><ghci><l></l> sqrtM &lt;$&gt; sqrtM 16
<o>Just (Just 2)</o>
<l></l> sqrtM &lt;$&gt; sqrtM (-1)
<o>Just Nothing</o></ghci></pre>
      </p> 
      
      <p>
	Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just 2)</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>Just 2</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление.</p>

      <task> Определите функцию <code>join :: Maybe (Maybe a) -&gt; Maybe a</code>, которая занималась бы "соединением" контекстов так, чтобы можно было получить такие результаты: <pre><ghci><l></l> join $ sqrtM &lt;$&gt; sqrtM 16
<o>Just 4</o>
<l></l> join $ sqrtM &lt;$&gt; sqrtM (-1)
<o>Nothing</o></ghci></pre>
      </task>

      <p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в&nbsp;цепочки любые вычисления с контекстом. Для неё есть особое обозначение: <code>=&lt;&lt;</code></p>

<p align='center'><tt>f =&lt;&lt; x  ≡  join $ f &lt;$&gt; x</tt></p>


      <p>Мы определили для типа <code>Maybe</code> функцию <code>join</code> и сразу повысили его "ранг", позволяя объединять в цепочку функции, возвращающие значения в контексте <code>Maybe</code>. Функторы (аппликативные) для которых определено соединение <code>join</code> называются <strong>монадами</strong>. </p>
      
      <task>Сравните типы операторов <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> и <code>=&lt;&lt;</code> и объясните своими словами их действие в контекстах.</task>

      <p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

      <pre><hs>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</hs></pre>

      <task>Вычислите следующие выражения в интерпретаторе и объясните как происходят вычисления:
	<pre><hs>[-1,0,1,16] &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Just 64 &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Right 16 &gt;&gt;= sqrtA
Right (-16) &gt;&gt;= sqrtA
(read &lt;$&gt; getLine) &gt;&gt;= sqrtA &gt;&gt;= print</hs></pre></task>

      <task>Изучите типы универсальных функций для работы с функторами и монадами
	<pre><ghci>ap
(>=>)
($>)	    
mapM
foldM
sequence
traverse
replicateM</ghci></pre>
	C помощью интерпретатора познакомьтесь с их поведением для типов <code>[]</code>, <code>Maybe </code>, <code>(,) a</code>. </task>
      

      <h2>Управление семантикой вычислений</h2>
<p>Вернёмся к задаче интерпретации арифметических выражений, записанных в обратной польской нотации. Наше решение, использующее простой стековый автомат было лаконичным и эффективным, но очень ограниченным по возможностям. В нём даже нет элементарных обработок ошибочных выражений и в исключительной ситуации он просто прерывает свою работу, не сообщая о характере ошибки. Используя аппликативные функторы и монады, как абстракцию семантики вычислений мы можем существенно расширить его функционал.</p>

<p>Для начала перепишем код калькулятора, добавив в него обработку ошибок:</p>

<pre><hs>type Stack = [Double]

<d>calculate :: String -> Stack</d>
calculate = foldl interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> read n : s
      where
        binop f = case s of
          x:y:s -> f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = error $ op ++": " ++ m </hs></pre>

<task>Составьте список примеров для калькулятора и проверьте на них не только правильность его работы, но и адекватность сообщений об шибках.</task>

<p>Получился уже совсем неплохой калькулятор, надёжный, расширяемый и вполне дружелюбный. Однако у него есть существенный недостаток — в случае ошибки он прерывает выполнение не только своей работы, но и любой системы, в которую он мог бы быть включён. Например, с её помощью невозможно прогнать ряд тестов ряд из которых должен быть "провален", поскольку первый же такой тест прекратит работы всего тестирования. Это вовсе не в духе функционального программирования, где ценится тотальность и надёжность программ.</p>

<p>Стандартным решением в процедурном программировании является "поимка исключений" с помощью конструкции <code>try/catch</code>. Это добавляет программе надёжности, но позволяет потоку выполнения прерываться и перескакивать из одного блока в другой. В функциональном программирований поток вычислений непрерывен и больше похож на течение тока в электрической цепи. Здесь одним из самых типичных способов управления потоком — использование функторов и монад.</p>

<p>Мы можем воспользоваться монадой <code>Either</code> для того, чтобы ошибочные состояния превратить в данные и прерывая вычисления, не останавливать работу всей программы. </p>
  <pre><hs><d>calculateE :: String -> Either String Stack</d>
calculateE = foldM interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> Right $ sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> readE n : s
      where
        binop f = case s of
          x:y:s -> Right $ f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = Left $ op ++": " ++ m

<d>readE :: Read a => String -> Either String a</d>
readE s = case [x | (x,t) <- reads s, ("","") <- lex t] of
            [x] -> Right x
            _ -> Left $ "could not parse " ++ s</hs></pre>

<p>Здесь мы добавили собственный безопасный вариант функции <code>read</code>. Обратите внимание на то, что код программы изменился незначительно: функция свёртки оказалась заменена на монадический вариант <code>foldM</code>, и "хорошие" результаты вычислений оказались упакованы в конструктор <code>Right</code>.</p>

<task>Теперь появилась возможность прогнать все тесты сразу, поскольку ошибки превратились в данные и не прерывают работы программы. Проверьте правильность работы калькулятора на ваших примерах. </task>

  <hr/>
<p>Мощность монадических вычислений позволяет переключаться с одной семантики вычисления программы на другую, не меняя кода программы. Мы видели это на примере функции <code>bisectionA</code>. Нельзя ли и наш калькулятор сделать столь же универсальным?</p>

<p>Давайте создадим класс для монад, способных возвращать текстовые сообщения об ошибках.</p>
<pre><hs>class Monad m => Exception m where
  exception :: String -> m a</hs></pre>

<p>Экземплярами этого класса могут быть монады <code>IO</code> и <code>Either String</code></p>

<pre><hs>instance Exception IO where
  exception = error

type Err = Either String

instance Exception Err where
  exception = Left</hs></pre>


<p>Теперь можно написать обобщённый калькулятор:</p>
  <pre><hs><d>calculateE :: Exception m => String -> m Stack</d>
calculateE = foldM interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> pure $ sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> readE n : s
      where
        binop f = case s of
          x:y:s -> pure $ f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = exception $ op ++": " ++ m

<d>readE :: (Exception m, Read a) => String -> m a</d>
readE s = case [x | (x,t) <- reads s, ("","") <- lex t] of
            [x] -> pure x
            _ -> exception $ "could not parse " ++ s</hs></pre>

<p>Конкретную монаду, в которой он работает теперь способна выбирать программа, вызывающая этот калькулятор:</p>
<pre><ghci><l></l> calculateE "2 3 + 4 *" :: IO Stack
<o>[20.0]</o>
<l></l> calculateE "2 3 + 4 *" :: Err Stack
<o>Right [20.0]</o>
<l></l> calculateE "2 3 + *" :: IO Stack
<err>*** Exception: *: got only one argument!  Stack: [5.0]</err>
<l></l> calculateE "2 3 + *" :: Err Stack
<o>Left "*: got only one argument!  Stack: [5.0]"</o></ghci></pre>

<task>Добавьте определения экземпляров класса <code>Exception</code> для монад <code>[]</code> и <code>Maybe</code>. Эти монады игнорируют сообщения, но, тем не менее, способны создавать альтернативные ветви вычислений. Проверьте, что наш калькулятор способен работать и в этих монадах.</task>

    <task>Мы видели, что альтернативные функторы, позволяют производить неоднозначные вычисления со множеством вариантов ответов. Мы можем создать неоднозначным и наш калькулятор, введя операцию <eq>\pm</eq> и позволив операции <code>sqrt</code> возвращать несколько значений. Для этого нужно сделать функтор <code>Err</code> альтернативным.</task>

    <task>В стандартной библиотеке Haskell определены две  функции для работы со списками: <code>head</code> и <code>tail</code>. Их существенный недостаток состоит в том, что они не тотальны. Напишите свои варианты этих функций:
    <pre><hs>headE :: Exception m => [a] -> m a 
tailE :: Exception m => [a] -> m [a]</hs></pre></task>
    
	      </div>

    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
</body>
</html>

