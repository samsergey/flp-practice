<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>fmap {
      content: "hello&lt;$&gt;";
    }</style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в функциональном программировании — это больше чем описание данных. Это, в первую очередь, описание структуры образуемой данными, в виде математических законов, справедливых для этой структуры. Мы видели это на примере типов для электрических сопротивлений, разнообразных моноидов, изображений и т. д. Типы могут обладать структурой, которая позволяет не только комбинировать вычисления, но и управлять потоком вычислений. Для управления потоком в императивном программировании используются ветвление, циклы или исключения, в функциональном подходе часть и этой работы берут на себя типы.</p>
      
      <p>Простой и часто встречающийся пример — тип <code>Maybe a</code>, говорящий о&nbsp;том, что величина значения типа <code>a</code> может быть неопределена.</p>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите две функции, связывающие эти два типа  <pre><hs>listToMaybe :: [a] -> Maybe a
maybeToList :: Maybe a -> [a]</hs></pre></task>

      <p>Оператор <code>(&lt;$&gt;)</code> имеет своё имя: <code>fmap</code>  и он определён для всех типов, являющихся <strong>функторами</strong>. Самое общее определение для функтора — это <strong>контекст, в котором производятся вычисления</strong>.</p>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <tt>:t</tt>. Посмотрите (с&nbsp;помощью команды <tt>:i</tt> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <task>С помощью оператора <code>(&lt;$&gt;)</code> удвойте определённые элементы списка:<pre><hs>[Just 2, Nothing, Just 3, Just 15]</hs></pre> </task>
      
      <h2>Аппликативные функторы</h2>
    
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с функторами. Посмотрите на то, как действуют операторы <code>&lt;|&gt;</code> и <code><*></code>, вычислив в <sl>GHCi</sl> следующие выражения.
      <pre><hs> Nothing &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Nothing
 Nothing &lt;|&gt; Nothing
 Nothing &lt;*&gt; Just 5
 Just (4*) &lt;*&gt; Just 5
 Just (2*) &lt;*&gt; Nothing
 (+) &lt;$&gt; Just 3 &lt;*&gt; Just 7
 (+) &lt;$&gt; Nothing &lt;*&gt; Just 7
 (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing</hs></pre>
      Объясните своими словами, для чего нужны операторы <code>&lt;$&gt;</code> (<code>fmap</code>), <code>&lt;|&gt;</code>, <code>&lt;*&gt;</code>, применительно к функтору <code>Maybe</code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните действие выражений:
	<pre><hs>(+2) &lt;$&gt; find (< 2) [2,3,1,4]
(*) &lt;$&gt; find odd [2,3,1,4] &lt;*&gt; find even [2,3,1,4]
(*) &lt;$&gt; find odd [2,6,10,4] &lt;*&gt; find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) &lt;$&gt; lookup "x" vars &lt;*&gt; lookup "a" vars</hs></pre>
 </task>

      <task>Посмотрите на определение функтора <code>Either</code>, и объясните его функториальные свойства, судя по примерам:
	<pre><hs>(*2) &lt;$&gt; Right 4
(*2) &lt;$&gt; Left 4
(*2) &lt;$&gt; Left "hello"
(+) &lt;$&gt; Right 8 &lt;*&gt; Right 5
(+) &lt;$&gt; Left "No!" &lt;*&gt; Right 5 </hs></pre>
      </task>			  

      <task>Напишите функцию <code>sqrtE</code>, которая вычисляет квадратный корень вещественного числа, и для отрицательных чисел возвращает сообщение об ошибке, в виде значения <code>Left "sqrt: got negative argument!"</code>. Вычислите с её помощью  выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>
     
      <task>Поэкспериментируйте с функториальными свойствами типа <code>[]</code>:      <pre><hs>[] &lt;|&gt; [2,3]
[1,2,3] &lt;|&gt; [4,5]
[2] &lt;|&gt; []
[] &lt;|&gt; []
[] &lt;*&gt; [2,3,4]
[(4*)] &lt;*&gt; [2,3,4]
[(4*), (3+)] &lt;*&gt; [2,3,4]
(+) &lt;$&gt; [2,3] &lt;*&gt; [4,5,6]
(+) &lt;$&gt; [] &lt;*&gt; [2,3]
(+) &lt;$&gt; [1,2,3] &lt;*&gt; []</hs></pre>
</task>

      <task> Получите все возможные разбиения строки пробелами
<pre><ghci><l></l> spaces "ABC"
<o>["ABC", "AB C", "A BC", "A B C"]</o></ghci></pre>

<details><summary>Вариант решения</summary>
<pre><hs>spaces s = case s of
    x:xs -> (x :) <$> go xs
    "" -> [""]
  where go s = case s of
    x:xs -> (++ [x]) <$> ["", " "] <*> go xs
    "" -> [""]</hs></pre>
</details></task>

      <task>Напишите функцию <code>sqrtL</code>, которая вычисляет квадратный корень вещественного числа, причём, для положительных аргументов она должна возвращать как положительное, так и отрицательное значение корня, для нулевого — только ноль, а для отрицательных значений — ни одного значения. Вычислите с её помощью выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Посмотрите на определение типа <code>IO</code> и объясните как он действует, в&nbsp;качестве функтора:
	<pre><hs> ("Hello, " ++) &lt;$&gt; getLine
 let readNum = read &lt;$&gt; getLine 
 (+) &lt;$&gt; readNum &lt;*&gt; readNum
 print 6 &lt;|&gt; error "!!"	</hs></pre>
      </task>			  
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В&nbsp;определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>empty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code> (они образуют моноид). </task>

      <task>Напишите универсальную функцию <code>sqrtA</code>, обобщающую функции <code>sqrtM</code> и <code>sqrtL</code> так, чтобы она работала c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code>, причём, для списков, возвращала несколько корней.</task>

      <task>Напишите, используя альтернативные функторы, функцию <code>bisectionA</code>, отыскивающую точку смены заданного условия методом бисекции: <pre><hs>bisectionA :: (Alternative f, Eq a)
  => (Double -> a) -> (Double, Double) -> f Double</hs></pre></task>
      <details><summary>Схема решения</summary>
	<pre><hs>bisection p (a,b)
  -- тестовая функция не меняется на границах
  | ... = empty
  -- достигнута абсолютная или относительная погрешность
  | ... = pure c
  -- шаг бисекции
  | otherwise = bisection p (a,c) <|> bisection p (c,b)
  where c = mean a b</hs></pre></details>
      
<!--       <h2>Управление сообщениями об ошибках</h2> -->
      
<!--       <p>Тип <code>Either</code> похож на тип <code>Maybe</code> тем, что у него есть одно "верное" значение — правое, и "неверное" — левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p> -->

<!--       <p>Однако тип <code>Either</code> не является альтернативным функтором. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>strongpty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>strongpty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p> -->

<!--       <pre><hs>instance Monoid m =&gt; Alternative (Either m) where -->
<!--   strongpty = Left mstrongpty -->
<!--   Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно -->
<!--   Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения -->
<!--   Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения</hs></pre> -->

<!--       <task>Убедитесь на следующих примерах, что приведённое определение работает корректно: -->

<!--       <pre><code>Left "fail" &lt;|&gt; Right 42 -->
<!-- Right 42 &lt;|&gt; Left "fail" -->
<!-- Left "I am " &lt;|&gt; Left "a fail" -->
<!-- </code></pre> -->
<!--       </task> -->

<!-- <p>Для типа <code>Either String</code> определим специальный тип:<pre><hs>type Messaged = Either String</hs></pre></p> -->
      
<!--       <p>Теперь нужно научиться вводить в программу сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали их. Эта возможность должна быть определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>sqrtA</code> для разных контестов, а это уже не DRY (Don't Repeat Yourself — один из универсальных принципов программирования).</p> -->

<!--       <p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в&nbsp;нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию — <code>message</code>.</p> -->

<!--       <pre><hs>class Alternative f =&gt; Failable f where -->
<!--   message :: String -&gt; f a -->
<!--   -- определение, используемое по умолчанию -->
<!--   message _ = strongpty -->
<!-- </hs></pre> -->

<!--       <p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Messaged</code> и <code>IO</code> — специфические:</p> -->

<!--       <pre><hs>instance Failable Maybe -->
<!-- instance Failable [] -->
<!-- instance Failable Messaged where message = Left -->
<!-- instance Failable IO where message = error -->
<!-- </hs></pre> -->

<!--       <task>Внесите в определение функции <code>sqrtA</code> изменения, позволяющие использовать её в четырёх различных контекстах: -->
<!-- 	<pre><hs> sqrtA 16 :: [Double] -->
<!--  sqrtA 16 :: Maybe Double -->
<!--  sqrtA 16 :: Messaged Double -->
<!--  sqrtA 16 -->
<!--  sqrtA (-1) :: [Double] -->
<!--  sqrtA (-1) :: Maybe Double -->
<!--  sqrtA (-1) :: Messaged Double -->
<!--  sqrtA (-1)</hs></pre> -->
<!--       </task> -->
<!--       <p> -->
<!-- 	Нам в дальнейшей работе пригодится класс <code>Failable</code>, поэтому стоит выделить его и определение экземпляров для типов <code>[]</code>, <code>Maybe</code>, <code>Messaged</code> и  <code>IO</code> в отдельный модуль <tt>Failable.hs</tt> -->
<!--       </p> -->

<!--       <task>Перепишите функцию <code>bisection</code>, так, чтобы её тип стал таким: <pre><hs>bisection :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> Double -> Double -> f Double</hs></pre></task> -->


<!--       <task>Подобно тому, как мы интегрировали функцию на указанной сетке, организуйте поиск особых точек методом бисекции на произвольной сетке:<pre><hs>findRoot :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> [Double] -> f Double</hs></pre> При этом для пустой сетки и сетки с единственной точкой должны возвращаться соответствующие сообшения об ошибках.</task> -->

      <h2>Монады</h2>
      
      <p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые возвращают значение в контексте? Например, как можно дважды применить функцию <code>sqrtM</code>, чтобы вычислить <eq>\sqrt{\sqrt{16}}</eq>? Иными словами, как выполнить композицию функций, возвращающих не просто значение, а значение в некотором контексте <code>m</code>?</p>
      
      <p>Попробуем начать с использования оператора <code>&lt;$&gt;</code>:
	<pre><ghci><l></l> sqrtM &lt;$&gt; sqrtM 16
<o>Just (Just 2)</o>
<l></l> sqrtM &lt;$&gt; sqrtM (-1)
<o>Just Nothing</o></ghci></pre>
      </p> 
      
      <p>
	Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just 2)</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>Just 2</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление.</p>

      <task> Определите функцию <code>join :: Maybe (Maybe a) -&gt; Maybe a</code>, которая занималась бы "соединением" контекстов так, чтобы можно было получить такие результаты: <pre><ghci><l></l> join $ sqrtM &lt;$&gt; sqrtM 16
<o>Just 4</o>
<l></l> join $ sqrtM &lt;$&gt; sqrtM (-1)
<o>Nothing</o></ghci></pre>
      </task>

      <p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в&nbsp;цепочки любые вычисления с контекстом. Для неё есть особое обозначение: <code>=&lt;&lt;</code></p>

<p align='center'><tt>f =&lt;&lt; x  ≡  join $ f &lt;$&gt; x</tt></p>


      <p>Мы определили для типа <code>Maybe</code> функцию <code>join</code> и сразу повысили его "ранг", позволяя объединять в цепочку функции, возвращающие значения в контексте <code>Maybe</code>. Функторы (аппликативные) для которых определено соединение <code>join</code> называются <strong>монадами</strong>. </p>
      
      <task>Сравните типы операторов <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> и <code>=&lt;&lt;</code> и объясните своими словами их действие в контекстах.</task>

      <p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

      <pre><hs>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</hs></pre>

      <task>Вычислите следующие выражения в интерпретаторе и объясните как происходят вычисления:
	<pre><hs>[-1,0,1,16] &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Just 64 &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Right 16 &gt;&gt;= sqrtA
Right (-16) &gt;&gt;= sqrtA
(read &lt;$&gt; getLine) &gt;&gt;= sqrtA &gt;&gt;= print</hs></pre></task>

      <task>Изучите типы универсальных функций для работы с функторами и монадами
	<pre><ghci>ap
(>=>)
($>)	    
mapM
foldM
sequence
traverse
replicateM</ghci></pre>
	C помощью интерпретатора познакомьтесь с их поведением для типов <code>[]</code>, <code>Maybe </code>, <code>(,) a</code>. </task>

      <h2>Порождающие грамматики</h2>

<p>Используя деревья, мы уже порождали последовательность всех корректных или некорректных скобочных выражений (<a href='flp-lab5.html#tree_brackets'>см. Занятие 5</a>). Но таким образом нельзя создать что-либо сложнее свободного языка двухсимвольного алфавита <tt>(a|b)*</tt>. Аппликативные и альтернативные функторы позволят нам порождать слова для произвольной регулярной грамматики.</p>

<p>Регулярные формальные грамматики определяются алгебраически с помощью трёх операций — объединения (альтернатива), конкатенации (соединения в цепочки) и звезды Клини (многократного повторения), а также трёх базовых конструкций: пустого символа (<eq>\varepsilon</eq>), невозможного символа (<eq>\bot</eq>) и литералов.</p>

<p>Эту алгебраическую структуру можно выразить таким типом:</p>
<pre><hs>data Grammar a =
  None                            -- невозможный символ
  | Epsilon                       -- пустой символ
  | Term a                        -- литерал
  | Alt (Grammar a) (Grammar a)   -- объединение
  | Chain (Grammar a) (Grammar a) -- конкатенация
  | Kleene (Grammar a)            -- звезда Клини
    deriving (Show, Functor)</hs></pre>

<p>Этот тип вполне пригоден для описания произвольных регулярных грамматик. Но он крайне неудобен. Для примера опишем регулярное выражение, задающее двоичные числа, кратные трём  <tt>(0|(1(01*0)*1))*</tt>:</p>
<pre> Kleene (Alt (Term 0) (Chain (Term 1) (Chain (Kleene (Chain (Term 0)
 (Chain (Kleene (Term 1)) (Term 0)))) (Term 1))))</pre>
<p>Как видно, запись получается громоздкой и вовсе нечитабельной. Для упрощения работы, воспользуемся тем, что регулярные грамматики образуют моноид относительно операций объединения и конкатенации с нейтральными элементами <eq>\bot</eq> и <eq>\varepsilon</eq>, соответственно. Это свойство можно выразить с помощью классов <code>Monoid</code> и <code>Alternative</code>:</p>
<pre><hs>instance Semigroup (Grammar a) where
  (<>) = Chain

instance Monoid (Grammar a) where
  mempty = Epsilon

instance Applicative Grammar where
  pure = Term
  (<*>) = undefined

instance Alternative Grammar where
  empty = None
  (<|>) = Alt</hs></pre>

<p>Аппликативное поведение грамматики нам не нужно, однако его требуется формально определить для того, чтобы можно было объявить тип для грамматики альтернативным функтором. Теперь запись выражения <nobr><tt>(0|(1(01*0)*1))*</tt></nobr> становится более осмысленной:</p>
<pre>many (ch 0 <|> (ch 1 <> many (ch 0 <> many (ch 1) <> ch 0) <> ch 1))</pre>

  <p>Ещё стоит создать несколько вспомогательных функций:</p>
<pre><hs>-- указанный литерал
ch c = pure c
-- один из списка литералов
alt cs = foldr (<|>) empty $ ch <$> cs
-- цепочка указанных литералов
str s = foldMap ch s
-- необязательное выражение
opt g = Epsilon <|> g
-- повторение выражения 0 или более раз
many = Kleeny
-- повторение выражения 1 или более раз
some g = g <> Kleeny g</hs></pre>

<p>Теперь определять регулярные выражения становится существенно удобнее. Вот, например, как запишутся выражения <tt>b[aeiou]bble</tt>, <tt>g(ooo)+gle</tt>, <tt>0x[0-9A-F]{2}</tt></p>
<pre><hs> ch 'b' <> alt "aeiou" <> str "bble"
 ch 'g' <> some (str "ooo") <> str "gle"
 str "0x" <> 2 *<> alt (['0'..'9']++['A'..'F']) </hs></pre>

<p>Мы создали встроенный язык для описания грамматик, но без интерпретации он бесполезен. Приступим к генерации слов, соответствующих указанной грамматике. И здесь нам опять помогут концепции аппликативных и альтернативных функторов, позволяя дать изящное и универсальное решение:</p>
  
  <pre><hs><d>generate :: Alternative f => Grammar a -> f [a]</d>
generate g = case g of
   -- не генерируется ничего
   None -> empty
   -- генерируется пустая строка
   Epsilon -> pure []
   -- генерируется один символ
   Term c -> pure [c]
   -- кнкатенация (или смешение) альтернатив
   Alt a b -> generate a <|> generate b
   -- все возможные цепочки из вариантов a и b
   Chain a b -> (++) <$> generate a <*> generate b
   -- последовательность цепочек eps, a, aa, aaa, ... 
   Kleeny a -> generate Epsilon <|> generate (a <> Kleeny a)</hs></pre>

<p>  Функтором <code>f</code> может быть тип <code>Maybe</code> или список. В первом случае, мы получим какое-то одно слово, а во втором — список всех подходящих слов, возможно, бесконечный. </p>
<pre><ghci><l></l> let g1 = (str "cat" <|> str "dog") <> alt "ao" <> str "log"
<l></l> generate g1 :: Maybe String
<o>Just "catalog"</o>
<l></l> generate g1 :: [String]
<o>["catalog","catolog","dogalog","dogolog"]</o>
<l></l> take 5 $ generate $ ch 'g' <> some (str "o") <> str "gle"
<o>["gogle","google","gooogle","goooogle","gooooogle"]</o></ghci></pre>

<p>Впрочем, у такого решения есть проблема. Посмотрите, как генерируются слова простой грамматики: <tt>a+b+</tt>:
<pre><ghci><l></l> take 6 $ generate $ some (ch 'a') <> some (ch 'b')
<o>["ab","abb","abbb","abbbb","abbbbb","abbbbbb"]</o></ghci></pre>
Пока не завершится перебор всех вариантов конструкции <tt>b+</tt>, (а он не завершится никогда), мы не получим корректных коротких слов <tt>aab, aaab, aabb</tt> и им подобных.</p>

<p>Аппликативное поведение списков состоит в построчном переборе пространства вариантов:</p>
<pre>       b b bbb bbbb bbbbb ⋯
    a  1 2  3   4     5   ⋯
   aa  
  aaa
 aaaa
aaaaa
  ︙</pre>

Ко второй строке перебор так никогда и не приступит. Разумный перебор потенциально бесконечного многомерного пространства решений — важная часть логического программирования. Можно реализовать иной порядок перебора:

<pre>       b   bb bbb bbbb bbbbb ⋯
    a  1   3   6   10    15  ⋰
   aa  2   5   9   14    20  ⋰
  aaa  4   8  13   19    27  ⋰
 aaaa  7  12  18   26    35  
aaaaa  11 17  25   34    47  
  ︙      ⋰   ⋰    ⋰     ⋰</pre>

Именно так определено аппликативное поведение для типа <code>Logic a</code>, которое задано в библиотеке <a href='../snippets/Logic.hs' target='_blank'><code>Logic</code></a>. Создайте файл <tt>Logic.hs</tt> и подгрузите эту библиотеку к рабочей программе.</p>

<p>Посмотрим, как работает функтор <code>Logic</code> на конечных и бесконечных списках:</p>
<pre><ghci><l></l> samples $ Logic [1,2,3] <> Logic [5,6,7,8]
<o>[1,2,3,5,6,7,8]</o>
<l></l> samples $ Logic [1,2,3] <|> Logic [5,6,7,8]
<o>[1,5,2,6,3,7,8]</o>
<l></l> samples $ (,) <$> Logic [1,2,3] <*> Logic [5,6,7,8]
<o>[(1,5),(1,6),(2,5),(1,7),(2,6),(3,5),(1,8),(2,7),(3,6),(2,8),(3,7),(3,8)]</o>
<l></l> takeLogic 10 $ Logic [1..] <> Logic [-1,-2..]
<o>[1,2,3,4,5,6,7,8,9,10]</o>
<l></l> takeLogic 10 $ Logic [1..] <|> Logic [-1,-2..]
<o>[1,-1,2,-2,3,-3,4,-4,5,-5]</o>
<l></l> takeLogic 10 $ (,) <$> Logic [1..] <*> Logic [-1,-2..]
<o>[(1,-1),(1,-2),(2,-1),(1,-3),(2,-2),(3,-1),(1,-4),(2,-3),(3,-2),(4,-1)]</o></ghci></pre>

<p>Благодаря тому, что функция <code>generate</code> универсальна для любых альтернативных функторов, переключить её работу на функтор <code>Logic</code> не составит труда:</p>
<pre><ghci><l></l> takeSamples 10 $ generate $ some (ch 'a') <> some (ch 'b')
<o>["ab","abb","aab","abbb","aabb","aaab","abbbb","aabbb","aaabb","aaaab"]</o></ghci></pre>

<task>Сгенерируйте списки слов для следующих грамматик:
  <pre> (cat|dog)(a|o)+(log|morphism)
 (0|(1(01*0)*1))*
 b[aeiou]bble
 g(ooo)+gle
 0x[0-9A-F]{2}
 [0..9]{2}[+-*/][0..9]{2}</pre></task>

<p>До сих пор мы ограничивались регулярными грамматиками, но используя явную рекурсию мы можем генерировать и нерегулярные и даже контекстно-зависимые грамматики. Приведём классический пример нерегулярного языка: языка, порождаемого грамматикой корректных скобочных выражений </p>
<pre><hs>brs = ch '(' <> many brs <> ch ')'</hs></pre>
<pre><ghci><l></l> takeLogic 20 $ generate brs
<o>["()","(())","(()())","((()))","(()()())","((())())",
 "((()()))","(()(()))","((())()())","((()())())",
 "(((())))","(()()()())","((())(()))","((()())()())",
 "(((()))())","((()()()))","(()(())())","((())()()())",
 "((()())(()))","(((()))()())"]</o>
</ghci></pre>

<task>Дополните грамматику <code>brs</code> так, чтобы она порождала три различных вида скобок: круглые, квадратные и фигурные.</task>

<task>Проверьте, как работает генерация скобочных выражений в функторе <code>[]</code>.</task>

<p>Напоследок, рассмотрим задачу генерации арифметических выражений по простой праворекурсивной грамматике:
  <pre><eq>E \to T\,(( '+' | '-' )\,T)\!*</eq>
<eq> T \to M\,((\mathbf{'\times'} \ |\ \mathbf{'/'})\,M)\!*</eq>
<eq> M \to N \ |\  \mathbf{'('}\ E\ \mathbf{')'}</eq>
<eq> N \to [1-9][0-9]\!*</eq> 
  </code></pre>

Если мы переведём её на наш язык для описания грамматик, то получится такой код:
<pre><hs><d>arythmetics :: Grammar Char</d>
arythmetics = expr
  where
    expr = term <> many (alt "+-" <> term)
    term = mult <> many (alt "*/" <> mult)
    mult = num <|> ch '(' <> expr <> ch ')'
    num = alt ['1'..'9']
</hs></pre>

Теперь можно генерировать схемы арифметических выражений:

<pre><ghci><l></l> takeLogic 20 $ generate arythmetics
<o>["1","1+1","1*1","1+1+1","1*1+1","(1)","1+1*1",
 "1*1+1+1","(1)+1","1*1*1","1+1+1+1","1*1+1*1",
 "(1)+1+1","1*1*1+1","(1)*1","1+1*1+1","1*1+1+1+1",
 "(1)+1*1","1*1*1+1+1","(1)*1+1"]</o>
</ghci></pre>
</p>


<!--
      <h2>Управление семантикой вычислений</h2>
<p>Вернёмся к задаче интерпретации арифметических выражений, записанных в обратной польской нотации. Наше решение, использующее простой стековый автомат было лаконичным и эффективным, но очень ограниченным по возможностям. В нём даже нет элементарных обработок ошибочных выражений и в исключительной ситуации он просто прерывает свою работу, не сообщая о характере ошибки. Используя аппликативные функторы и монады, как абстракцию семантики вычислений мы можем существенно расширить его функционал.</p>

<p>Для начала перепишем код калькулятора, добавив в него обработку ошибок:</p>

<pre><hs>type Stack = [Double]

<d>calculate :: String -> Stack</d>
calculate = foldl interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> read n : s
      where
        binop f = case s of
          x:y:s -> f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = error $ op ++": " ++ m </hs></pre>

<task>Составьте список примеров для калькулятора и проверьте на них не только правильность его работы, но и адекватность сообщений об шибках.</task>

<p>Получился уже совсем неплохой калькулятор, надёжный, расширяемый и вполне дружелюбный. Однако у него есть существенный недостаток — в случае ошибки он прерывает выполнение не только своей работы, но и любой системы, в которую он мог бы быть включён. Например, с её помощью невозможно прогнать ряд тестов ряд из которых должен быть "провален", поскольку первый же такой тест прекратит работы всего тестирования. Это вовсе не в духе функционального программирования, где ценится тотальность и надёжность программ.</p>

<p>Стандартным решением в процедурном программировании является "поимка исключений" с помощью конструкции <code>try/catch</code>. Это добавляет программе надёжности, но позволяет потоку выполнения прерываться и перескакивать из одного блока в другой. В функциональном программирований поток вычислений непрерывен и больше похож на течение тока в электрической цепи. Здесь одним из самых типичных способов управления потоком — использование функторов и монад.</p>

<p>Мы можем воспользоваться монадой <code>Either</code> для того, чтобы ошибочные состояния превратить в данные и прерывая вычисления, не останавливать работу всей программы. </p>
  <pre><hs><d>calculateE :: String -> Either String Stack</d>
calculateE = foldM interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> Right $ sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> readE n : s
      where
        binop f = case s of
          x:y:s -> Right $ f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = Left $ op ++": " ++ m

<d>readE :: Read a => String -> Either String a</d>
readE s = case [x | (x,t) <- reads s, ("","") <- lex t] of
            [x] -> Right x
            _ -> Left $ "could not parse " ++ s</hs></pre>

<p>Здесь мы добавили собственный безопасный вариант функции <code>read</code>. Обратите внимание на то, что код программы изменился незначительно: функция свёртки оказалась заменена на монадический вариант <code>foldM</code>, и "хорошие" результаты вычислений оказались упакованы в конструктор <code>Right</code>.</p>

<task>Теперь появилась возможность прогнать все тесты сразу, поскольку ошибки превратились в данные и не прерывают работы программы. Проверьте правильность работы калькулятора на ваших примерах. </task>

  <hr/>
<p>Мощность монадических вычислений позволяет переключаться с одной семантики вычисления программы на другую, не меняя кода программы. Мы видели это на примере функции <code>bisectionA</code>. Нельзя ли и наш калькулятор сделать столь же универсальным?</p>

<p>Давайте создадим класс для монад, способных возвращать текстовые сообщения об ошибках.</p>
<pre><hs>class Monad m => Exception m where
  exception :: String -> m a</hs></pre>

<p>Экземплярами этого класса могут быть монады <code>IO</code> и <code>Either String</code></p>

<pre><hs>instance Exception IO where
  exception = error

type Err = Either String

instance Exception Err where
  exception = Left</hs></pre>


<p>Теперь можно написать обобщённый калькулятор:</p>
  <pre><hs><d>calculateE :: Exception m => String -> m Stack</d>
calculateE = foldM interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> pure $ sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> readE n : s
      where
        binop f = case s of
          x:y:s -> pure $ f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = exception $ op ++": " ++ m

<d>readE :: (Exception m, Read a) => String -> m a</d>
readE s = case [x | (x,t) <- reads s, ("","") <- lex t] of
            [x] -> pure x
            _ -> exception $ "could not parse " ++ s</hs></pre>

<p>Конкретную монаду, в которой он работает теперь способна выбирать программа, вызывающая этот калькулятор:</p>
<pre><ghci><l></l> calculateE "2 3 + 4 *" :: IO Stack
<o>[20.0]</o>
<l></l> calculateE "2 3 + 4 *" :: Err Stack
<o>Right [20.0]</o>
<l></l> calculateE "2 3 + *" :: IO Stack
<err>*** Exception: *: got only one argument!  Stack: [5.0]</err>
<l></l> calculateE "2 3 + *" :: Err Stack
<o>Left "*: got only one argument!  Stack: [5.0]"</o></ghci></pre>

<task>Добавьте определения экземпляров класса <code>Exception</code> для монад <code>[]</code> и <code>Maybe</code>. Эти монады игнорируют сообщения, но, тем не менее, способны создавать альтернативные ветви вычислений. Проверьте, что наш калькулятор способен работать и в этих монадах.</task>

    <task>Мы видели, что альтернативные функторы, позволяют производить неоднозначные вычисления со множеством вариантов ответов. Мы можем создать неоднозначным и наш калькулятор, введя операцию <eq>\pm</eq> и позволив операции <code>sqrt</code> возвращать несколько значений. Для этого нужно сделать функтор <code>Err</code> альтернативным.</task>

    <task>В стандартной библиотеке Haskell определены две  функции для работы со списками: <code>head</code> и <code>tail</code>. Их существенный недостаток состоит в том, что они не тотальны. Напишите свои варианты этих функций:
    <pre><hs>headE :: Exception m => [a] -> m a 
tailE :: Exception m => [a] -> m [a]</hs></pre></task> -->
    
	      </div>

    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
</body>
</html>

