<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <h2>Использование и расширение комбинаторов</h2>

<task>Используя универсальную функцию <code>collect</code> для поиска подстрок, описываемых транслятором <code>p</code>  
  <pre><hs>collect :: Monoid b => Parser i b -> Parser i b
collect p = mmany (p <|> mempty <$ next)</hs></pre>
  определите следующие функции:
  <pre><hs>count :: Parser [i] a -> Parser [i] Integer
search :: Parser [i] a -> Parser [i] [a]
longest :: Parser [i] [a] -> Parser [i] [a]</hs></pre>
   Ниже приводятся примеры их использования:
<pre><ghci><l></l> run (count integer) "5 pigs, 122 cows, 47 cats"
<o>Ok 3 ""</o>
<l></l> run (search integer) "5 pigs, 122 cows, 47 cats"
<o>Ok [5,12,47] ""</o>
<l></l> run (longest (some digit)) "5 pigs, 122 cows, 47 cats"
<o>Ok "122" ""</o>
</ghci></pre>			    
				      
<task>Реализуйте комбинатор <code>&lt;?></code>, с помощью которого, можно было бы отфильтровывать трансляторы по указанному предикату для возвращаемого значения. Так, например можно было бы отыскивать в тексте только нечётные числа:
<pre><ghci><l></l> run (search (integer &lt;?> odd)) "5 pigs, 122 cows, 47 cats"
<o>Ok "" [5,47]</o></ghci></pre>
</task>

 <task>Напишите транслятор <code>replace p f</code>, который изменял бы части входной последовательности, описываемые транслятором <code>p</code> с помощью функции <code>f</code>:<pre><hs>replace :: Parser [b] a -> (a -> [b]) -> Parser [b] [b]</hs></pre> Например:
 <pre><ghci><l></l> run (replace (string "cat") (const "kitten")) "the cat has a cup"
<o>Ok "the kitten has a cup" ""</o>
<l></l> run (replace (term `oneof` "cat") (\x -> [toUpper x])) "the cat has a cup"
<o>Ok "The CAT hAs A Cup" ""</o></ghci></pre> В последнем примере используется функция <code>toUpper</code> из библиотеки <code>Data.Char</code>.</task>				
      
      
					
<h2>Функциональные цепочки</h2>

 <p> Моноидальные свойства трансляторов позволят нам изящно определить ещё пару полезных комбинаторов <code>chainl</code> и <code>chainr</code>. Прежде чем их реализовывать, посмотрим, какие возможности они нам дадут:
   <pre><ghci><l></l> let add = (+) <$ term '+'
<l></l> let sub = (-) <$ term '-'
<l></l> run (chainl integer add) "23+7+170"
<o>Ok 200 ""</o>
<l></l> run (chainl integer sub) "23-7-170"
<o>Ok (-154) ""</o>
<l></l> run (chainr integer sub) "23-7-170"
<o>Ok 186 ""</o>
<l></l> run (chainl integer (add <|> sub) "23+7-170"
<o>Ok (-140) ""</o>   </ghci></pre>
   В этих вычислениях можно разглядеть левую и правую свёртки, только сворачивающей функцией и элементами для сворачивания являются трансляторы.</p>

 <p>Моноиды позволили нам с помощью единственной функции <code>foldMap</code> построить правую и левую свёртки. Аналогом <code>foldMap</code> для трансляторов является функция <code>mmany</code>, и с её помощью мы можем повторить "фокус" с  моноидами <code>Endo</code>  и <code>Dual</code>: </p>

<pre><hs>chainr p o = appEndo <$> mmany terms <*> p
  where
    terms = Endo <$> (p <**> o)

chainl p o = p <**> (appEndo . getDual <$> mmany terms)
  where
    terms = Dual . Endo <$> ((flip <$> o) <*> p)
</hs></pre>

<task>Изучите тип оператора <code>(<**>)</code> и объясните его роль в определениях <code>chainl</code> и <code>chainr</code>.</task>

<task>С помощью функции <code>assoc</code> убедитесь в том, что функции <code>chainl</code> и <code>chainr</code> соответствуют цепочкам лево- и правоассоциативных операций.
<pre><hs>assoc a b = "(" ++ show a ++ "," ++ show b ++ ")"</hs></pre></task>

      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

