<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class="tasks">

      <h2>Итеративные и рекурсивные процессы</h2>

      <p>Любая серьёзная программа содержит в себе в том или ином виде повторение вычислительных действий. Для этого используются циклические конструкции. В большинстве процедурных языков программирования для этого используются такие конструкции:
	<ul>
	  <li><code>for</code> для циклов с фиксированным числом повторений и счётчиком;</li>
	  <li><code>foreach</code> для обработки конечных структур;</li>
	  <li><code>while</code> для циклов с неизвестным заранее (возможно, бесконечным) числом итераций.</li>
	</ul>
      </p>
      <p>В функциональном программировании циклические конструкции устроены иначе. Мы уже говорили, что решив использовать только чистые функции, мы отказываемся от использования изменяемых данных и операции присваивания. Как же в таком случае реализовывать циклические процессы с изменяемыми параметрами, такие, как цикл <tt>while</tt> или итератор <tt>for</tt>? В функциональной парадигме для этого используется рекурсивный вызов, или рекурсия — вызов функции из её собственного тела.</p>
      <p> Пусть нам нужно найти сумму квадратов целых чисел от 1 до <eq>n</eq>. В большинстве императивных языков программирования мы организовали бы цикл, в котором некая переменная пробегала бы по заданному диапазону и искомая сумма вычислялась, например, по следующей схеме:</p>
<pre><cs>i := 1
sum := 0
while i &lt; n do
  sum := sum + i^2
  i := i + 1
return sum </cs></pre>
	  
      <p>Но что делать, если у нас нет присваиваний, или мы не хотим ими пользоваться? Эту задачу можно решить при помощи рекурсии. 
	<pre><hs><d>sumsq :: Integer -> Integer</d>
sumsq 0 = 0
sumsq n = n^2 + sumsq (n-1)</hs></pre>
В этом определении мы заменяем решение исходной задачи решением меньшей задачи, понимая, что постепенно придём к минимальному, нулевому значению. </p>

      <p>В теории вычислений важным является вопрос завершаемости вычислительного процесса. Для получения результата цепочка рекурсивных вызовов должна, рано или поздно, прекратиться. Таким образом, рекурсивная функция обязательно должна включать в себя конструкцию выбора, определяющую условие (или условия) выхода из рекурсии. Такие условия называют <strong>базой рекурсии</strong>.</p>

      <p> В ходе вычисления рекурсивной функции, происходит расширение вычисляемого
	выражения, по мере того, как процесс строит цепочку отложенных операций, а затем происходит сжатие, тогда, когда выполняются эти отложенные операции. Для хранения отложенных вчислений и результатов обычно используется стек — структура данных в памяти, работающая по правилу «последним вошёл — последним вышел». В Haskell вместо стека используется динамически выделяемая память.</p>
      <p> Проследим, как действует функция <code>sumsq</code> при вычислении суммы квадратов первых трёх натуральных чисел.
	<pre><hs> sumsq 4 
 16 + sumsq 3
 16 + (9 + sumsq 2)
 16 + (9 + (4 + sumsq 1))
 16 + (4 + (9 + (1 + sumsq 0)))
 16 + (9 + (4 + (1 + 0)))
 16 + (9 + (4 + 1))
 16 + (9 + 5)
 16 + 14
 30</hs></pre>

	Такой тип процесса, который характеризуется цепочкой отложенных операций, называется <strong>рекурсивным процессом</strong>.
      <p> Реализация итерационного цикла на регистровой машине более эффективна, чем реализация рекурсии, поскольку итерации не требуют использования стека для хранения отложенных операций и вычисление не имеет двух этапов — расширения и сжатия. По этой причине у рекурсии сложилась «дурная репутация» в мире императивных языков программирования. В некоторых руководствах по программированию рекомендуют, по-возможности, избегать использования рекурсии.</p>
      <p> Однако, в рамках чистого функционального программирования без рекурсии не обойтись. Значит ли это, что мы обречены на неэффективные функциональные программы? Оказывается, можно так построить рекурсивное определение функции, что оно будет эквивалентно итерационному циклу и по скорости выполнения и по использованию памяти (стека).</p>

      <p>Посмотрите на следующую схему вычислений:
	<pre><hs><d>sumsq&#39; :: Integer -> Integer</d>
sumsq&#39; n = iter 0 1
  where iter s i = if (i > n)
                   then s
                   else iter (s + i^2) (i + 1)</hs></pre>
	Она соответствует итеративному решению. Здесь так же, введены две переменные — изменяющийся счётчик <code>i</code> и накопитель <code>s</code>, но мы обошлись без присваивания. Инициализация переменных произошла при первом вызове функции <code>iter</code>, а последовательное изменение их значений происходит во время рекурсивного вызова этой функции.</p>

      <p>Изобразим по шагам процесс вычисления <code>sumsq&#39; 4</code>, показывая, чему равны текущие значения аргументов функции <code>iter</code>:
<pre><hs>sumsq&#39; 4
iter 0 1                i = 1 s = 0
iter (0 + 1) (1 + 1)    i = 2 s = 1
iter (1 + 4) (2 + 1)    i = 3 s = 5
iter (5 + 9) (3 + 1)    i = 4 s = 14
iter (14 + 16) (4 + 1)  i = 5 s = 30
30</hs></pre>
При <eq>i=5</eq> срабатывает условие <eq>i>n</eq> и возвращается текущее
значение аккумулятора <code>s</code>. Рассмотренный нами процесс не растёт и не сжимается. На каждом шаге при любом значении <eq>n</eq> необходимо помнить лишь текущие значения переменных <eq>i</eq> и <eq>s</eq>. Такой процесс называется <strong>итеративным</strong>, в нём решение задачи заменяется решением другой задачи.</p>

      <task>Напишите функцию <code>sum f a b</code> возвращающую сумму значений произвольной функции <code>f</code> в целых числах от <code>a</code> до <code>b</code>, реализуя рекурсивный и итеративный процессы.</task>

      <task>Напишите обобщённую итеративную функцию <code>accumulate g x0 f a b</code>, такую, чтобы функцию <code>sum</code> можно было бы выразить через неё: <pre><hs>sum = accumulate (+) 0</hs></pre></task>

      <p>Разницу между рекурсивным и итеративным процессами хорошо показывает пример вычисления чисел Фибоначчи, которые определяются соотношением <eqn>f_n = f_{n-1} + f_{n-2},\quad f_1 = 0, f_2 = 1.</eqn>  Вычислительная эффективность рекурсивной реализации имеет порядок <eq>O(1.6^n)</eq>, так что время вычисления <eq>f_{20}</eq> и <eq>f_{30}</eq> отличаются в <eq>1.6^{10} = 110</eq> раз! В тоже самое время, простой итеративный алгоритм имеет линейную сложность <pre><code lang="python">fib (n):
  a = 0, b = 1, i = n
  if (i == 1) return a
  if (i == 2) return b
  while i &gt; 2 do
    i  = i - 1
    (a, b) = (b, b + a)
  return a </code></pre></p>
	<task>Напишите простую рекурсивную реализацию функции <code>fib n</code> а также функцию <code>fib&#39 n</code>, реализующую итеративный процесс. Вычислите с их помощью <eq>f_{10}, f_{20}, f_{30}</eq>.
	<details><summary>Вариант решения</summary>
	  <pre><hs><d>fib :: Int -> Integer</d>
fib 1 = 0
fib 2 = 1
fib n = fib (n-1) + fib (n-2)

<d>fib&#39; :: Int -> Integer</d>
fib&#39; n = go 0 1 n
  where go a b 1 = a
        go a b 2 = b
        go a b i = go b (a+b) (i-1) </hs></pre>
	</details>
	Убедитесь в том, что в отличие от рекурсивной,  итеративная реализация способна вычислить хначения <eq>f_{100}, f_{1000}</eq> и <eq>f_{10000}</eq>.
      </task>

      <h2>Знакомство со списками</h2>

      <p>Чистые функции можно представить в виде чёрных ящиков, имеющих один или несколько входов и единственный выход. Если типы входов и выходов согласуются, то две функции можно соединять в цепь. Каждая такая цепь сама будет представлять собой чистую функцию, то есть, чёрный ящик, пригодный для построения новых и новых цепей.</p>
      
      <p> Легко вообразить однократное вычисление с помощью функциональной программы: на еë вход подаются какие-то допустимые значения, а на выходе получается результат. Если же логика программы-функции предполагает еë многократное исполнение, то на вход можно подать поток данных, получая поток результатов. Мы уже делали это с помощью оператора <code><$></code>, применяя функцию к списку (потоку) данных и преобразуя их в список (поток) результатов.</p>
      
      <p>Если продолжить аналогию с потоками, то можно расширить инструментарий, добавив к преобразователям потоков функции, управляющие ими. Потоки данных можно порождать, соединять, ограничивать, фильтровать и поглощать, превращая в какое-то одно результирующее значение. Именно такое применение функционального подхода к композиции вычислений вы можете встретить в большинстве современных языков ( C#, Python, JavaScript, Ruby и т. д.).</p>
      
      <p>В функциональном программировании роль потока данных выполняют ленивые списки. В ленивом языке Haskell, они совпадают с обыкновенными списками данных.	</p>

      <p>Рассмотрим, в качестве примера, задачу представления чисел в виде строки из цифр в указанной системе счисления. Императивный алгоритм, записывающий число <eq>n</eq> в указанной системе с основанием <eq>b</eq>, может выглядеть так:</p>

      <pre><code class="cs"> def base(n, b):
   if n == 0:
     return [0]
   res = []
   while n > 0:
     m = mod(n, b) # вычисляем цифру, как остаток от деления n на b.
     res = [m] + res # добавляем цифру
     n = div(n, b) # вычисляем частное от деления n на b
   return res</code></pre>

      <p>Функциональная программа, которая в точности повторяет логику процедурного решения и реализует такой же вычислительный процесс может быть рекурсивной (реализующей итеративный процесс):</p>

      <pre><hs><d>toBase :: Int -> Int -> [Int]</d>
toBase b 0 = [0]
toBase b n = go [] n
  where
    go res 0 = res
    go res n = go (mod n b : res) (div n b)</hs></pre>

      <p>Однако можно организовать функциональную программу совсем иначе — в виде потоков данных. Давайте сформулируем декларативное определение результата программы:</p>

      <div class="disclaimer" id="toBase">
	Цифры в позиционной записи числа <eq>n</eq> — это остатки от деления на <eq>b</eq>
	последовательности отличных от нуля частных деления числа <eq>n</eq> на <eq>p</eq>.
      </div>

      <p>Переводя на язык обработчиков списков, получаем такую программу:
	
	<pre><hs>toBase b n = reverse
           $ map (`mod` b)
           $ takeWhile (> 0)
           $ iterate (`div` b) n</hs></pre>

	Или такую, если будем использовать композицию:

	<pre><hs>toBase b = reverse
         . map (`mod` b)
         . takeWhile (> 0)
         . iterate (`div` b)</hs></pre>
      </p>

      <task>Разберитесь, какую роль играет каждый этап обработки данных функцией <code>toBase</code>. Объясните зачем завершает цепочку вычислений функция <code>reverse</code>. Переведите с помощью функции <code>toBase</code> число 2021 в систему с основаниями 2, 3, 5, 16 и 100.</task>

      <task>Выясните с помощью интерпретатора что делает функция <code>replicate</code>. Разберитесь как работают рекурсивное и потоковое определения этой функции:
	<pre><hs>-- рекурсивное определение
replicate1 0 _ = []
replicate1 n x = x : replicate1 (n - 1) x

-- определение, использующее концепцию потоков
replicate2 n x = const x <$> [1..n]</hs></pre>
	Выясните тип этих функций и удостоверьтесь, что они работают верно. Объясните смысл функции <code>const</code> и её тип.</task>

      <task>Выясните и объясните тип функций <code>take</code>, <code>map</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>filter</code>. Вычислите следующие примеры в интерпретаторе и объясните своими словами, что делают эти функции.</task>
      <pre><hs> take 5 [1..10]
 take 5 [1..3]
 take 5 [1..]
 map (+1) [1..5]
 takeWhile (&lt; 5) [1..20]
 dropWhile (&lt; 5) [1..20]
 take 3 $ dropWhile (&lt; 5) [1..]
 filter (\i -> i^2 &lt; 5) [1..20]</hs></pre>
      
      <task>Вычислите в GHCi следующие выражения и объясните что делают функции <code>zip</code>, <code>zipWith</code>, <code>tail</code> и <code>sum</code></task>
      <pre><hs> zip [1..4] [5..8]
 zipWith (+) [1..4] [5..8]
 tail [2,3,5,78]
 zip lst (tail lst) where lst = [1..5]
 sum [2,4,6]</hs></pre>
      
      <task>Выясните экспериментально и с помощью типов что делают функции <code>any</code>, <code>each</code>, <code>and</code>, <code>or</code>. </task>
      
      <h2>Списки и циклические конструкции</h2>
      
       На практике явной рекурсии при организации циклических процессов можно избежать, сведя задачу к комбинации простых рекурсивных схем, оперирующих потоками данных:
	<ul>
	  <li><i>источник</i> — порождение потоков данных;</li>
	  <li><i>преобразователь</i> — последовательное преобразование или фильтрация всех элементов потока;</li>
	  <li><i>ограничитель</i> потока</li>
	  <li><i>слияние</i> потоков</li>
	  <li><i>сток</i> — свёртка или аггрегация потока.</li>
	</ul>
      </p>

      <task>Определите какие схемы реализуют следующие фукции Haskell:
	<pre><hs> [1..13]
 sum      
 map
 takeWhile
 [1..]
 length
 iterate
 product
 zipWith
 dropWhile
 filter
 zip
 or
 any</hs></pre></task>

      <task> Напишите потоковый вариант функции <code>sum f a b</code>. Задачу можно разбить на три части:
	<ul>
	  <li>создайте поток чисел от <eq>a</eq> до <eq>b</eq>;</li>
	  <li>преобразуйте этот поток в поток квадратов чисел;</li>
	  <li>просуммируйте полученный поток.</li>
	</ul>
      </task>     

      
      <task> Вычислите приближение основания натурального логарифма <eq>e</eq> в виде частичной суммы ряда:
	<eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
	с точностью до 14 знаков после запятой.
	<details><summary>Возможная схема решения</summary>
	<ul>
	  <li>определите функцию, вычисляющую факториал от <eq>n</eq>, как произведение ряда натуральных чисел от <eq>1</eq> до <eq>n</eq>; </li>
	  <li>сгенерируйте последовательность чисел от 0 до бесконечности;</li>
	  <li>превратите её в последовательность значений <eq>1/i!</eq>;</li>
	  <li>ограничьте полученную последовательность элементами, превышающими указанную <eq>10^{-14}</eq> (используйте функцию <code>takeWhile</code>);</li>
	  <li>просуммирупйте последовательность.</li>
	</ul></details>
	Оцените количество операций, необходимых для вычисления этой функции.
      </task>

      <task>Вычислите с помощью частичного суммирования или перемножения ряда число <eq>\pi</eq>.</task>
      
      <task>Напишите функцию <code>count p lst</code>, которая считает сколько раз в списке встречается элемент, удовлетворяющий предикату <code>p</code>. Как с её помощью подсчитать в строке количество цифр?</task>

      <task>Найдите сколько точек на целочисленной сетке попадают в круг указанным целочисленным радиусом. Оцените число <eq>\pi</eq> с помощью круга радиусом 100. Здесь для каждого элемента списка следует создать и обработать ещё один список, таким образом реализуется вложенный цикл.<br/> Посмотрите в справке о <a href ='haskell-ref.html#Генераторы списков' target='_blank'>генерации списков</a>.</task>

      <task>Решите в одну строчку. Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробeг на 10% от пробега предыдущего дня. Определите, в какой день лыжник должен будет пробежать 100 км. Найдите в какой день суммарный пробег за все дни превысит 100 км. </task>

      <task><a name="Floyd"></a>Наряду с задачей FizzBuzz для обучения программированию и для собеседований часто используется ещё одна несложная задача: треугольник Флойда. Она состоит в выводе на печать такой последовательности строк:<pre>1
2 3
4 5 6
7 8 9 10
...</pre>

	Решите эту задачу на Haskell доступными вам способами (рекурсия, генераторы списков и т. п.).
	
      <details><summary>Вариант решения</summary>
	<pre><hs>floyd = (\i -> [arsum i + 1 .. arsum (i + 1)]) <$> [1..]
  where tr n = n*(n - 1) `div` 2</hs></pre>
	<p>Здесь <code>arsum n</code> — сумма арифметической прогрессии <eq>1,2,..,n</eq></p>
      </details>

      </task>
      
      <task>Для повышения точности численного интегрирования (см. занятие 1),  интервал интегрирования разбивается на несколько маленьких интервалов и на каждом из них интеграл вычисляется методом Гаусса, после чего результаты суммируются. Напишите функцию <code>integrate f mesh</code>, вычисляющую интеграл таким способом, используя задаваемую пользователем сетку <code>mesh</code>. <br/>

	Сравните получаемую точность интегрирования для различного числа разбиений на примере <eqn>\int_0^{20} \sin x\,dx = 1 - \cos\,20.</eqn></task>


      <h2>Данные и коданные</h2>

      <p>В большинстве парадигм программирования списки играют роль данных, которые обрабатывает программа. В функциональном программировании это тоже, как правило, так. Однако здесь есть возможность порождать список (поток) и "поглощать" его в одной программе и даже в одной функции. В ленивых вычислениях, накакого списка в памяти в таком случае так и не создаётся, он существует только в коде программы. Данные такого рода называются <strong>коданными</strong> (codata) — то есть сущностью, дуальной данным.</p>


      <task>Известно, что коэффициенты при всех степенях в разложении полинома <eq>(a + b)^n</eq> можно получить с помощью треугольника Паскаля. Треугольник Паскаля — бесконечная таблица, имеющая треугольную форму.
	<p><img src="img/PascalTriangle.png" alt="" width='40%'/><img src="img/imgFig1.gif" alt="" width='60%'/></p>
	<ul>
	  <li>Определите функцию <code>pascalStep</code>, которая для любой строки в треугольнике строит следующую строку, складывая почленно строку саму с собой, сдвинутой на один элемент. Проверьте правильность её работы на простых примерах.</li>
	  <li>Определите с помощью <code>pascalStep</code> бесконечную последовательность строк треугольника Паскаля <code>pascal</code>.</li>
	  <li> Найдите с помощью оператора <code>!!</code> коэффициенты разложения <eq>(a+b)^{15}</eq>.</li>
	  <li> Определите функцию <code>binomial n k</code>, как коэфициент при <eq>x^k</eq> в разложении <eq>(1+x)^n</eq> и сравните с биномиальным коэффициентом явно вычисленным по формуле: <eqn> C_{n}^{k} = \frac {n!}{k!(n-k)!}.</eqn>
	  <li>  Найдите коэффициент при <eq>x^{10}</eq> в разложении <eq>(1+x)^{10000}</eq>.</li>
	  <li>После этого вычислите в этом же разложении коэффициент при <eq>x^{9}</eq> и <eq>x^{11}</eq>. Обратите внимание на разницу в скорости вычисления коэффициентов и попробуйте её объяснить.</li>
	  <li>Покажите, что сумма <eq>n</eq>-ного ряда треугольника Паскаля равна <eq>2^n</eq>.</li>
      </ul></task>

      <p>Последовательность <code>pascal</code>, образованная рядами треугольника Паскаля, является не данными, а коданными, поскольку она никогда не появляется в памяти целиком. Каждый её элемент порождается по мере необходимости и тут же используется для вычислений.</p>

      <p>В роли коданных могут выступать не только линейные потоки. Принцип замены явной рекурсии порождением и обработкой индуктивных данных может быть обобщен и его можно применить к другим индуктивным структурам, например, к деревьям.</p>
      <p>Покажем это на примере рекурсивной функции <code>bisection</code>, кторую мы писали на прошлом занятии. Вспомним реализуемый ею алгоритм:
	<ul>
	  <li> задан отрезок <eq>(a,b)</eq>;</li>
	  <li> задано условие <eq>p</eq>, которое в некоторой точке на отрезке меняет значение (например, меняется знак числовой функции); 
	  <li> если <eq>p(a) = p(b)</eq>, считаем, что искомой точки на отрезке нет;
	  <li> если отрезок достаточно мал, решением является его средняя точка;
	  <li> в противном случае решение находится либо в правой, либо в левой половине отрезка.
	  </ul></p>

      <p>Можно выполнить его полную декомпозицию, используя в качестве коданных бесконечное дерево разбиений интервала:
      <ul>
	<li>Порождаем бесконечное дерево вложенных интервалов, деля их пополам.</li>
	<li>В этом дереве отыскиваем путь, соответствующий смене значения тестовой функции, представляющий собой бесконечную последовательность уменьшающихся интервалов.</li>
	<li>Отыскиваем в этой последовательности первый достаточно малый интервал.</li>
      </ul></p>

      <p>Для бесконечного дерева можно создать такой тип:
<pre><hs>data Tree a = Node a (Tree a) (Tree a) deriving Show</hs></pre>
Он параметризован типом <code>a</code>, так что наше дерево может содержать любые данные. Порождать это дерево можно такой функцией:
<pre><hs><d>tree :: (a -> (a, a)) -> a -> Tree a</d>
tree f x = let (a, b) = f x
           in Node x (tree f a) (tree f b)</hs></pre>

      А выделять в нём путь — с помощью какого-то условия так:
      
<pre><hs><d>path :: (a -> Bool) -> Tree a -> [a]</d>
path p (Node a t1 t2) =
  if p a then [] else [a] ++ path p t1 ++ path p t2 
</hs></pre>

      Наконец, мы готовы написать альтернативный вариант функции <code>bisection</code>:
      <pre><hs><d>bisection&#39
  :: Eq a2 =>
     (Double -> a2) -> (Double, Double) -> Maybe Double</d>
bisection&#39 p =
  (uncurry mean <$>)
  . find (\(a, b) -> abs (b - a) < 1e-11)
  . path (\(a, b) -> p a == p b)
  . tree (\(a, b) -> let c = mean a b in ((a,c),(c,b)))
</hs></pre>
      Здесь мы используем функцию <code>find</code> из библиотеки <code>Data.List</code> и функцию <code>uncurry</code>, которая функцию двух аргументов превращает в функцию от пары.</p>

      <p>Характерная особенность такого подхода состоит в том, что решение задачи сводится к комбинации универсальных инструментов: ни одна из функций <code>find</code>, <code>path</code> или <code>tree</code> изначально ничего "не знает" о том, какую именно задачу мы решаем. О конкретной постановке задачи они узнают от переданных им аргументов — лямбда-функций.</p>
      
      <task>Убедитесь в том, что <code>bisection&#39</code> работает точно также как и функция, реализованная нами на прошлом занятии.</task>
      
      <p>Это решение мы рассмотрели скорее для расширения сознания. Метод бисекции проще реализуется простой рекурсией. Однако, подобная декомпозиция становится по-настощему полезной при работе со сложными многоступенчатыми алгоритмами, такими как генерация сеток для численного моделирования или поиск оптимального хода в шахматах.</p>

    </div>

    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

