<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Полугруппы и моноиды</h2>

      <task>Загрузите модуль <code>Data.Monoid</code>. Изучите информацию о классе <code>Monoid</code>, используя команду <tt>:i</tt> в <sl>GHCi</sl>.</task>

      <task>Для функции <code>mappend</code> определено обозначение в виде оператора: <code>&lt;&gt;</code>. Поэкспериментируйте со следующими моноидами:
	<pre><hs> [1,2,3] <> [5,6]
 "Hello" <> " world" <> "!"
 mempty :: String
 Sum 5 <> Sum 10
 mempty :: Sum Int
 Product 3 <> Product 5
 mempty :: Product Int
 Any True <> Any False
 All True <> All False</hs></pre>
      </task>

      <task>С помощью функции <code>foldMap</code> найдите для списка <code>[2,4,-3,10,6]</code>
	<ul>
	  <li> сумму,
	  <li> произведение,
	  <li> все ли элементы списка чётные,
	  <li> есть ли в списке отрицательные числа
	</ul>
      </task>

      <p>Сами по себе моноиды были бы не столь полезны в программировании, если бы не два их свойства: моноидами являются<ul>
	  <li> произведение типов-моноидов
	    <pre> (Monoid m, Monoid n) => Monoid (m, n)
 (m1, m2) <> (n1, n2) = (m1 <> n1, m2 <> n2)
 mempty = (mempty, mempty)</pre> 
	  <li> функции, возвращающие моноид
	    <pre> Monoid m => Monoid (a -> m)
 f <> g = \x -> f x <> g x
 mempty = const mempty</pre> 
	</ul>
	</p>
      
      <h2>Произведение типов-моноидов</h2>

      <task>Используя свойство произведения моноидов, получите за один проход списка сумму и произведение его элементов. Посчитайте за один проход по списку чисел значение их среднего арифметического.</task>

      <task>Определите экземпляр класса <code>Monoid</code> для типов <code>Min a</code> и <code>Max a</code>, соответствующих минимальному и максимальному значению аргумента, имеющего тип <code>a</code>. Включите нейтральные элементы в описание этих типов.</task>

      <task>Найдите для заданного списка чисел за один проход сумму и произведение элементов, а также минимальный и максимальный элементы.</task>
     
      <task>Определите оператор <code>&&&</code> имеющий тип:<pre><hs> (&&&) :: (a -> b) -> (a -> c) -> (a -> (b,c))</hs></pre> Решите с его помощью предыдущую задачу.</task>

      <task>Исключите нейтральные элементы из определения типов <code>Min a</code> и <code>Max a</code>, и определите экземпляр класса <code>Monoid</code> для типов <code>Maybe (Min a)</code> и <code>Maybe (Max a)</code>. Удостоверьтесь, что минимальное и максимальное значения в списках находятся правильно.</task>
      
      <h2>Функции, возвращающие моноид</h2>

      <task>Удостоверьтесь на нескольких примерах в том, что функции, возвращающие моноид, сами образуют моноид. Напишите определение функции <code>when p m</code>, которая превращает предикат <eq>p</eq> в моноидальную функцию: <pre><hs>when :: Monoid m => (a -> Bool) -> m -> a -> m</hs></pre> Решите задачу <a href="flp-lab1.html#FizzBuzz" target='_blank'>FizzBuzz</a>, используя эту функцию и то обстоятельство, что строки образуют моноид.</task>
      
      <task>Моноид образует тип <code>Ordering</code>. Выясните, что является моноидальной суммой и нейтральным элементом для этого типа.</task>

      <task>Определите тип <code>Person</code> для записи информации о клиенте, содержащий имя, возраст и семейное положение:
	<pre><hs>data Person = Person { name :: String
                     , age :: Int
                     , married :: Bool } deriving Show</hs></pre> Создайте небольшую "клиентскую базу" из 6–8 записей. Напишите функцию <code>comparing</code>, которая позволит сравнивать записи по отдельным полям <pre><hs>comparing :: Ord b => (a -> b) -> a -> a -> Ordering</hs></pre> Выясните тип для композиции <pre><hs> comparing name <> comparing age</hs></pre> </task>

      <task>С помощью функции <code>sortBy</code> из модуля <code>Data.List</code>, отсортируйте вашу базу, используя следующие приоритеты ключей:
	<ul>
	  <li>возраст <eq>\to</eq> имя,
	  <li> имя  <eq>\to</eq> семейное положение,
	  <li> семейное положение <eq>\to</eq> возраст <eq>\to</eq> имя.
	</ul>
      </task>
      
      <h2>Быстрое умножение</h2>
      
      <p>Быстрое умножение, известное как "русское" или "египетское" умножение, — это метод, позволяющий производить многократную композицию бинарной операции над моноидом. Под умножением моноида на число будем понимать следующее:</p>
	<p class='equation' style='width:30%'><tt>0×a = mempty<br/>
1×a = a<br/>
2×a = a <> a<br/>
3×a = a <> a <> a<br/>
...</tt></p>
	
      <p>
	Способ основан на очень простых преобразованиях:</p>
      <p>если числовой множитель <eq>n</eq> чётный:
	<eqn>n \times a = \frac{n}{2}\times(2\times a),</eqn></p>
      <p>если числовой множитель нечётный:
	<eqn>(n+1)\times a = n \times a + a.</eqn></p>

      <p>
	Ниже приводится классический вариант быстрого умножения для чисел.
	<pre><hs><d>times :: (Num n, Integral i) => i -> n -> n</d>
times 0 _ = 0
times 1 a = a
times 2 a = a + a
times n a
  | even n = (n `div` 2) `times` (a + a)
  | odd n  = (n - 1) `times` a + a</hs></pre></p>

      <task> Обобщите определение <code>times</code> для произвольного моноида.
	Проверьте правильность его работы на примерах:
	<pre><hs> 5 `times` Sum 3
 5 `times` Product 3
 5 `times` [3]</hs></pre>
      </task>

      <task>Сравните производительность быстрого умножения и простого многократного сложения на двух примерах:
	<pre><hs> sum $ replicate 10000 3
 10000 `times` Sum 3</hs></pre> несколько раз увеличивая множитель на порядок.</task>
      
      <p>Важным приложением быстрого умножениия является возведение в&nbsp;степени матриц. Определим тип для матрицы, представляемой в виде списка списков, следующим образом:
	<pre><hs>data M a = M [[a]] | I deriving Show</hs></pre>
      </p>

      <task>Определите экзепляр класса <code>Monoid</code> для умножения матриц. Для этого определите скалярное произведение векторов, представленных списками. Проверьте правильность работы умножения на следующих примерах:
	<eqn>
	  \begin{pmatrix}
	  1 & 2 \\ 3 & 4
	  \end{pmatrix} \cdot
	\begin{pmatrix}
	  5 & 6 \\ 7 & 8
	  \end{pmatrix} =
	\begin{pmatrix}
	  19 & 22 \\ 43 & 50
	  \end{pmatrix}
	</eqn>
	<eqn>
	  \begin{pmatrix}
	  1 & 2 \\ 3 & 4
	  \end{pmatrix} \cdot
	\begin{pmatrix}
	  -2 & 1 \\ 3/2 & -1/2
	  \end{pmatrix} =
	\begin{pmatrix}
	  1 & 0 \\ 0 & 1
	  \end{pmatrix}
	</eqn>
	<eqn>
	  \begin{pmatrix}
	  1 & 2 \\ 3 & 4
	  \end{pmatrix} \cdot
	\begin{pmatrix}
	  5 \\ -6
	  \end{pmatrix} =
	\begin{pmatrix}
	  -7 \\ -9
	  \end{pmatrix}
	</eqn>
      </task>

      <p>С возведением матриц в большие степени связан ряд задач комбинаторики и динамического программирования. Мы рассмотрим пример использования этой операции для эффективного вычисления линейных рекуррентных отношений. Задача состоит в отыскании <eq>n</eq>-ного решения для уравнения:
	<eqn>x_n = a_1 x_{n-1} + ... + a_k x_{n-k},</eqn> при известных начальных <eq>x_1,x_2,...,x_k</eq>. Решение этой задачи сводится к возведению в степень <eq>n</eq> матрицы
	<eqn>
	  \begin{pmatrix}
	  a_1 & a_2 & \cdots & a_{k-1} & a_k\\
	  1 & 0 & \cdots & 0 & 0\\
	  0 & 1 & \cdots & 0 & 0\\
	  \vdots & & \ddots & & \vdots\\
	  0 & 0 & \cdots & 1 & 0
	  \end{pmatrix}</eqn> и умножении на вектор начальных значений.
      </p>

      <task>Напишите функцию вычисляющую <eq>n</eq>-ое число Фибоначчи, которое определяется соотношением <eqn>f_n = f_{n-1} + f_{n-2},\quad f_1 = 1, f_2 = 1.</eqn>
	Вычислите <eq>f_n</eq> для <eq>n = 1,10,10^3,10^6</eq>, недоступные даже для итеративной реализации наивного алгоритма.
      </task>

      <task>Числа одинаковых предметов, которые можно сложить в правильный многоугольник, образуют последовательности, называемые полигональными числами <p align='center'><img src="img/triangular.gif" alt="" width='60%'/><br/><img src="img/square.gif" alt="" width='60%'/><br/><img src="img/pentagonal.gif" alt="" width='60%'/></p> Последовательность полигональных чисел для <eq>k</eq>-угольника можно получить с помощью рекурретного уравнения<eqns>P^k_n = 3P^k_{n-1} - 3P^k_{n-2} + P^k_{n-3},\\ P^k_0 = 0, P^k_1 = 1, P^k_2=k.</eqns> Напишите функцию <code>polygonal k n</code>, вычисляющую <eq>n</eq>-ное полигональное число для <eq>k</eq>-угольника. Эти числа применяются в теории графов и в теории компьютерных сетей. Например минимальное число соединений, необходимыле для организации полносвязной сети из <eq>n</eq> процессоров равно <eq>P^3_{n-1}</eq>.</task>

      <task>Существует определение для ряда чисел Фибоначчи, использующее концепцию коданных: <pre><hs>fibs = 0 : 1 : zipWith (+) fibs (tail fibs)</hs></pre> Объясните как оно работает и сравните производительность двух определений, <code>fib n</code> и <code>fibs !! n</code>. Напишите подобное определение для полиномиальных чисел.</task>

      <h2>Моноиды и свёртка</h2>
      <p>Свёртка и моноид -- очень мощные и универсальные концепции, позволяющие единообразно обрабатывать алгебраические типы данных. Также как использование моноидов не ограничивается числами, свёртка не ограничивается обработкой списков. Сворачивать можно любые типы, являющиеся экземплярами класса <code>Foldable</code>.</p>

      <task>Загрузите модуль <code>Data.Foldable</code>. Посмотрите информацию о классе <code>Foldable</code>. Обратите внимание на то, как много встречавшихся нам ранее функций, обрабатывающих списки, определены для этого класса, а также на то, к каким ещё типам можно применить эти функции. </task>

      <task>Вернитесь к типу <code>Tree</code> из <a href="flp-lab3.html#За пределами списков">занятия 3</a> и определите его экземпляром класса <code>Foldable</code>, определив моноидальную свёртку <code>foldMap</code>. После этого, определите функцию <code>path</code> через <code>foldMap</code>.</task>

      <p>В определении класса <code>Foldable</code> есть важная строчка:
	<pre><ghci><o> ...
 {-# MINIMAL foldMap | foldr #-}
 ...</o></ghci></pre>
	Она означает, что определяя экземпляр этого класса для произвольного типа достаточно определить только одну из этих двух функций, все остальные могут быть выражены через них. Получается, что функция <code>foldMap</code>, работающая с моноидами является фундаментальной для свёртки.</p>
      
      <p>Посмотрим, как вычисляется свёртка списка правоассоциативной функцией <code>f</code>:</p>
      <p align='center'><tt>foldr f x₀ [a,b,c] = f a (f b (f c x₀))</tt></p>
      <p>
	Эту цепочку можно представить в виде цепочки композиций:</p>
      <p align='center'><tt>(f a) <eq>\circ</eq> (f b) <eq>\circ</eq> (f c) $ x₀</tt></p>
      
      <p>Если сворачивающая функция имела тип <code>f :: a -> b -> b</code>, то все функции в этой композиции будут иметь одинаковый тип <code>(f _) :: b -> b</code>. Такие функции называются <strong>эндоморфизмами</strong> и они образуют моноид относительно композиции. Нейтральным элементом для композиции является тождественное отображение <code>id</code>.</p>
      
      <p>Для эндоморфизмов в модуле <code>Data.Monoid</code> определён тип <code>Endo</code>, применить функцию, являющуюся эндоморфизмом можно с помощью функции <code>appEndo</code>
	<pre><hs>appEndo :: Endo a -> a -> a</hs></pre>
      </p>

      <task>Напишите реализацию функции <code>foldr</code>, используя только <code>foldMap</code> и тип <code>Endo</code>.</task>

      <p>Для левой свёртки цепочка вычислений в виде композиции записывается в обратном порядке:</p>
      <p align='center'><tt>(((x₀ `f` a) `f` b) `f` c) = (`f` c) <eq>\circ</eq> (`f` b) <eq>\circ</eq> (`f` a) $ x₀</tt></p>
      <p>
	Если ввести оператор <eq>\bar{\circ}</eq> для композиции с обратным порядком аргументов, то получится такая цепочка:
      </p>
      <p align='center'><tt>(`f` a)  <eq>\bar{\circ}</eq> (`f` b)  <eq>\bar{\circ}</eq> (`f` c) $ x₀</tt></p>
	
      <p>
	Для любого моноида существует т.н. дуальный моноид, отличающийся лишь порядком операндов. В модуле <code>Data.Monoid</code> определяется тип <code>Dual m</code>, который для любого моноида <code>m</code> представляет дуальный ему. Таким образом, моноиду <code>Endo</code> c операциeй <eq>\circ</eq> соответствует моноид <code>Dual&nbsp;(Endo&nbsp;a)</code> с операцией <eq>\bar{\circ}</eq>, и определять эту операцию специально не нужно.
      </p>
      
      <task>Определите левую свёртку <code>foldl</code>, через <code>foldMap</code>, <code>Endo</code> и <code>Dual</code>.</task>

    </div>      
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

