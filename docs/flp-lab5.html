<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      
      <h2>Полугруппы и моноиды</h2>

      <p>Алгебраический подход в программировании ярче всего выражается в концепциях полугруппы и моноида. <b>Полугруппой</b> называется множество <eq>A</eq>, на котором определена бинарная ассоциативная операция <eq>(\diamond) :: A \to A \to A</eq>. Это значит, что для любых элементов множества <eq>a</eq>, <eq>b</eq> и <eq>c</eq> выполняется  равенство:
	<eqn>(a \diamond b) \diamond c = a \diamond (b \diamond c) </eqn>

	Если в полугруппе <eq>A</eq> существует единственный элемент <eq>e</eq>, такой что <eqn>a \diamond e = e \diamond a = a </eqn> для всех <eq>a</eq>, то полугруппа называется <b>моноидом</b>, а <eq>e</eq> — его <b>нейтральным элементом</b>.</p>

      <task>Загрузите модули <code>Data.Semigroup</code>, <code>Data.Monoid</code>. Изучите информацию о классах <code>Semigroup</code> и <code>Monoid</code>, используя команду <tt>:i</tt> в <sl>GHCi</sl>.</task>

      <task>Поэкспериментируйте со следующими моноидами:
	<pre><hs> [1,2,3] <> [5,6]
 "Hello" <> " world" <> "!"
 mempty :: String
 Sum 5 <> Sum 10
 mempty :: Sum Int
 Product 3 <> Product 5
 mempty :: Product Int
 Any True <> Any False
 All True <> All False</hs></pre>
      </task>
      
      <h2>Класс Foldable</h2>

      <p>Основное применение концепции моноидов в программировании — ассоциативное объединение данных, организованных в сложные структуры. Добавим в список импорта модуль <code>Data.Foldable</code>, которое определяет инструменты для работы с такими структурами.</p>

      <pre><hs>import Data.Foldable</hs></pre>
      
      <p>Универсальной основой для обработки комплексных структур служит функция свёртки <code>foldMap</code>:</p>
      <pre><hs>foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m</hs></pre>
      <p>Тип этой функции говорит о том, что с её помощью можно объединить элементы любого сворачиваемого (<i>foldable</i>) контейнера <code>t a</code>, хранящего элементы типа <code>a</code> в моноид типа <code>m</code>. Например, для списков эта функция действует так:</p>
      <pre><hs>foldMap f [a, b, c, d] = f a <eq>\diamond</eq> f b <eq>\diamond</eq> f c <eq>\diamond</eq> f d</hs></pre>
      <p>При этом, в силу ассоциативности моноидальной операции, неважно как именно сворачивается список: справа или слева.</p>
<pre><hs> ((f a <eq>\diamond</eq> f b) <eq>\diamond</eq> f c) <eq>\diamond</eq> f d = f a <eq>\diamond</eq> (f b <eq>\diamond</eq> (f c <eq>\diamond</eq> f d))</hs></pre>
  
 <p>Конкретный моноид, возвращаемый функцией <code>f</code>, определяет что именно получится в результате.</p>
      
      <task>С помощью функции <code>foldMap</code> найдите для списка <code>[2,4,-3,10,-7,6]</code>
	<ul>
	  <li> сумму элементов (тип <code>Sum</code>),
	  <li> произведение элементов (тип <code>Product</code>),
	  <li> все ли элементы списка чётные (тип <code>All</code>),
	  <li> есть ли в списке отрицательные числа (тип <code>Any</code>),
	  <li> минимальный и максимальный элементы (типы <code>Min</code> и <code>Max</code>),
	  <li> количество элементов (тип <code>Sum</code>),
	  <li> список чётных чисел (тип <code>[]</code>).
	</ul>
      </task>

      <task>Посмотрите какие функции определены для экземпляров класса <code>Foldable</code> с помощью команды <code>:browse Data.Foldable</code> в интерпретаторе. </task>

      <p>Вернёмся к типу <a href="flp-lab3.html#Tree"><code>Tree</code><a> из Занятия 3 и определим его экземпляром класса <code>Foldable</code>. Для этого нужно определить моноидальную свёртку <code>foldMap</code> для бинарного дерева. Например, это может быть нисходящий поиск в глубину с обходом дерева слева:
	    <pre><hs>instance Foldable Tree where
  foldMap _ Empty = mempty
  foldMap f (Tree a l r) = f a <> foldMap f l <> foldMap f r</hs></pre>
Теперь мы можем найти все перечисленные в предыдущем задании свойства элементов для конечных бинарных деревьев.</p>

      <task>Вычислите для произвольного конечного дерева, содержащего в узлах числа, список его элементов, количество элементов, их сумму, максимальное значение, содержит ли дерево отрицательные числа и другие свойства, определённые для экземпляров класса <code>Foldable</code>.</task>

      <p>Для обработки потенциально бесконечных бинарных деревьев эффективнее использовать нисходящий обход дерева в ширину, а не в глубину. Для этого можно написать функцию <code>breadthFirst</code>, которая обходя дерево создаёт список элементов, хранящихся в узлах:</p>
      <pre><hs><d>breadthFirst :: Tree a -> [a]</d>
breadthFirst t = case t of
   Empty           -> []
   Node n Empty r  -> n : breadthFirst r
   Node n l Empty  -> n : breadthFirst l
   Node n l r      -> n : x : y : (xs +++ ys)
     where
       x:xs = breadthFirst l
       y:ys = breadthFirst r</hs></pre>
      <p>Такой список уже можно сворачивать с помощью функции <code>foldMap</code> и любого нужного моноида. </p>
      <task>Определите оператор <code>(+++)</code>, который объединяет два списка, чередуя их элементы:
	<pre><hs>infixr 5 +++
(+++) :: [a] -> [a] -> [a]</hs></pre>
	<pre><ghci><l></l> [1..5] +++ [10,20..50]
<o>[1,10,2,20,3,30,4,40,5,50]</o>
<l></l> [1..10] +++ [10,20..50]
<o>[1,10,2,20,3,30,4,40,5,50,6,7,8,9,10]</o>
<l></l> [1,2,3] +++ [20,30,40] +++ [400,500,600]
<o>[1,20,2,400,3,30,500,40,600]</o>
<l></l> take 10 $ [1..] +++ [10,20..]
<o>[1,10,2,20,3,30,4,40,5,50]</o>
<l></l> take 10 $ [1..3] +++ [10,20..]
<o>[1,10,2,20,3,30,40,50,60,70]</o></ghci></pre></task>

      <a name='tree_brackets'></a><task>Убедитесь в том, что функция <code>breadthFirst</code> работает корректно на примере бесконечного дерева скобочных выражений, порожденного функцией <pre><hs> tree (\x -> ('(':x, ')':x)) []</hs></pre> Создайте с его помощью бесконечный список всех возможных корректных скобочных выражений.</task>

      <task>Образуют ли списки полугруппу или моноид с операцией <code>(+++)</code>?</task>
      
      <h2>Операции с моноидами</h2>

      <p>Сами по себе моноиды были бы не столь полезны в программировании, если бы не два их свойства: моноидами являются произведение (пара) типов-моноидов
	    <pre><hs>instance (Semigroup m, Semigroup n) => Semigroup (m, n) where 
  (m1, m2) <> (n1, n2) = (m1 <> n1, m2 <> n2)

instance (Monoid m, Monoid n) => Monoid (m, n) where
  mempty = (mempty, mempty)</hs></pre> 
	  и функции, возвращаgющие моноид
	    <pre><hs>instance Semigroup m => Semigroup (a -> m) where
  f <> g = \x -> f x <> g x

instance Monoid m => Monoid (a -> m) where
  mempty = const mempty</hs></pre> 

	</p>
          
      <task>Используя свойство произведения моноидов, получите за один проход списка или дерева сумму и произведение его элементов. Посчитайте за один проход по списку или дереву чисел значение их среднего арифметического.</task>

      <task>Найдите для заданного списка чисел за один проход сумму и произведение элементов, а также минимальный и максимальный элементы.</task>
     
      <task>Определите оператор <code>&&&</code> имеющий тип:<pre><hs> (&&&) :: (a -> b) -> (a -> c) -> (a -> (b,c))</hs></pre> Решите с его помощью предыдущую задачу.</task>

     
      <task>Напишите определение функции <code>when m p</code>, которая превращает предикат <eq>p</eq> в моноидальную функцию: <pre><hs>when :: Monoid m => (a -> m) -> (a -> Bool) -> a -> m</hs></pre></task>

      <p>С помощью концепции моноидов можно изящно решить задачу <a href="flp-lab1.html#FizzBuzz" target='_blank'>FizzBuzz</a>:
      <pre><hs>fizzBuzz n = let divisibleBy n x = x `mod` n == 0
             in show n `max`
                (const "Fizz" `when` divisibleBy 3 <>
                 const "Buzz" `when` divisibleBy 5) n</hs></pre>

      Это решение хорошо тем, что не требует проверки делимости на 15 и легко расширяется. Например, если нужно добавить условие, что если число делится на 7, но должно выводиться "Quxx", то достаточно добавить одно моноидальное слагаемое:
      <pre><hs> const "Quxx" `when` divisibleBy 7</hs></pre></p>
      
<!--
      <task>Моноид образует тип <code>Ordering</code>. Выясните, что является моноидальной суммой и нейтральным элементом для этого типа.</task>

      <task>Определите тип <code>Person</code> для записи информации о клиенте, содержащий имя, возраст и семейное положение:
	<pre><hs>data Person = Person { name :: String
                     , age :: Int
                     , married :: Bool } deriving Show</hs></pre> Создайте небольшую "клиентскую базу" из 6–8 записей. Напишите функцию <code>comparing</code>, которая позволит сравнивать записи по отдельным полям <pre><hs>comparing :: Ord b => (a -> b) -> a -> a -> Ordering</hs></pre> Выясните тип для композиции <pre><hs> comparing name <> comparing age</hs></pre> </task>

      <task>С помощью функции <code>sortBy</code> из модуля <code>Data.List</code>, отсортируйте вашу базу, используя следующие приоритеты ключей:
	<ul>
	  <li>возраст <eq>\to</eq> имя,
	  <li> имя  <eq>\to</eq> семейное положение,
	  <li> семейное положение <eq>\to</eq> возраст <eq>\to</eq> имя.
	</ul>
      </task> -->
      
      <h2>Быстрое умножение</h2>
      
      <p>Быстрое умножение, известное как "русское" или "египетское" умножение позволяет производить многократную композицию бинарной операции над моноидом. Под умножением моноида на число будем понимать следующее:</p>
	<p class='equation' style='width:30%'><tt>0×a = mempty<br/>
1×a = a<br/>
2×a = a <eq>\diamond</eq> a<br/>
3×a = a <eq>\diamond</eq> a <eq>\diamond</eq> a<br/>
...</tt></p>
	
      <p>
	Способ быстрого умножения основан на очень простых преобразованиях:</p>
      <p>если числовой множитель <eq>n</eq> чётный:
	<eqn>n \times a = \frac{n}{2}\times(a + a),</eqn></p>
      <p>если числовой множитель нечётный:
	<eqn>n \times a = (n - 1) \times a + a.</eqn></p>

      <p>
	Ниже приводится классический вариант быстрого умножения для чисел.
	<pre><hs><d>times :: (Num n, Integral i) => i -> n -> n</d>
0 `times` _ = 0
1 `times` a = a
2 `times` a = a + a
n `times` a
  | even n = (n `div` 2) `times` (a + a)
  | odd n  = a + (n - 1) `times` a

-- короткое обозначение в виде оператора
infixl 7 *<>
n *<> m = times n m </hs></pre></p>

<pre class='animate' id='times'></pre>
      
      <task> Обобщите определение <code>times</code> для произвольного моноида.
	Проверьте правильность его работы на примерах:
	<pre><hs> 5 *<> Sum 3
 5 *<> Product 3
 5 *<> [3]</hs></pre>
      </task>

      <task>Сравните производительность быстрого умножения и простого многократного сложения на двух примерах:
	<pre><hs> sum $ replicate 10000 3
 10000 *<> Sum 3</hs></pre> несколько раз увеличивая множитель на порядок.</task>
      
      <p>У алгоритма быстрого умножения есть важное приложение: с его помощью можно многократно перемножать матрицы, то есть, возводить их в&nbsp;степени. Определим тип для матрицы, представляемой в виде списка рядов, следующим образом:
	<pre><hs>data M a = M [[a]] -- прямоугольная матрица
         | I       -- единичная матрица
  deriving Show</hs></pre>

	Например, матрица <eq>\begin{pmatrix} 1 & 2 \\ 3 & 4 \end{pmatrix}</eq> будет представлена с его помощью так:
	<pre><hs>M [[1,2],[3,4]]</hs></pre> </pп>

      <task>Определите экзепляр класса <code>Monoid</code> для умножения матриц. Для этого определите скалярное произведение векторов, представленных списками. Проверьте правильность работы умножения на следующих примерах:
	<eqn>
	  \begin{pmatrix}
	  1 & 2 \\ 3 & 4
	  \end{pmatrix} \cdot
	\begin{pmatrix}
	  5 & 6 \\ 7 & 8
	  \end{pmatrix} =
	\begin{pmatrix}
	  19 & 22 \\ 43 & 50
	  \end{pmatrix}
	</eqn>
	<eqn>
	  \begin{pmatrix}
	  1 & 2 \\ 3 & 4
	  \end{pmatrix} \cdot
	\begin{pmatrix}
	  -2 & 1 \\ 3/2 & -1/2
	  \end{pmatrix} =
	\begin{pmatrix}
	  1 & 0 \\ 0 & 1
	  \end{pmatrix}
	</eqn>
	<eqn>
	  \begin{pmatrix}
	  1 & 2 \\ 3 & 4
	  \end{pmatrix} \cdot
	\begin{pmatrix}
	  5 \\ -6
	  \end{pmatrix} =
	\begin{pmatrix}
	  -7 \\ -9
	  \end{pmatrix}
	</eqn>
      </task>

      <p>С возведением матриц в большие степени связан ряд задач комбинаторики и динамического программирования. Мы рассмотрим пример использования этой операции для эффективного вычисления линейных рекуррентных отношений. Задача состоит в отыскании <eq>n</eq>-ного решения для уравнения:
	<eqn>x_n = a_1 x_{n-1} + ... + a_k x_{n-k},</eqn> при известных начальных <eq>x_1,x_2,...,x_k</eq>. Решение этой задачи сводится к возведению в <eq>n</eq>-ную степень матрицы
	<eqn>
	  \begin{pmatrix}
	  a_1 & a_2 & \cdots & a_{k-1} & a_k\\
	  1 & 0 & \cdots & 0 & 0\\
	  0 & 1 & \cdots & 0 & 0\\
	  \vdots & & \ddots & & \vdots\\
	  0 & 0 & \cdots & 1 & 0
	  \end{pmatrix}</eqn> и умножении на вектор начальных значений.
      </p>

      <task>Напишите функцию вычисляющую <eq>n</eq>-ое число Фибоначчи, которое определяется соотношением <eqn>f_n = f_{n-1} + f_{n-2},\quad f_1 = 1, f_2 = 1.</eqn> то есть, с помощью матрицы <eq>\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}</eq> и вектора <eq>\begin{pmatrix} 0 \\ 1 \end{pmatrix}</eq>.
	<p>Итеративный способ вычисления чисел Фибоначчи плохо справляется с <eq>n > 10^6</eq>. Вычислите с помощью матричного умножения сколько цифр в числах <eq>f_n</eq> для <eq>n = 10^5, 10^6, 10^7</eq>. Проверьте являются ли чётными числа Фибоначчи для <eq>n = 10^7</eq>, <eq>n = 10^7 + 1</eq> и <eq>n = 10^7 + 2</eq>.</p>
      </task>

      <hr/>
      <p>Эффективное возведение матриц в степени можно применить в теории графов и в теории игр. Например, для графа элементы его матрицы смежности <eq>M</eq>, возведённой в степень <eq>n</eq>, указывают на число путей длины <eq>n</eq> между вершинами в графе. Диагональные элементы матрицы <eq>(M^n)_{ii}</eq> равны числу циклов длины <eq>n</eq>, проходящих через вершину <eq>i</eq>.</p>

      <task>Для графа, изображённого на рисунке найдите число циклов длины 5, 10, 20 и 100. Для этого нужно вычислить след (сумму диагональных элементов) матрицы смежности, возведённой в соответствующую степень. Определите цикл максимальной длины, которого нет в этом графе. <br/><img src='img/graph.png' width='50%'/></task>
      
      <p>Многие случайные процессы и игры описываются так называемыми цепями Маркова: множеством состояний с известными вероятностями переходов между ними. Такие цепи описываются как взвешенные орентированные графы. Если матрицу весов такого графа <eq>M</eq> возвести в степень <eq>n</eq>, то её элементы покажут вероятности переходов между состояниями для <eq>n</eq> временны́х шагов системы. Если <eq>n \to \infty</eq>, то матрица <eq>M^n</eq> покажет вероятности обнаружить систему в каждом из состояний при длительном наблюдении.</p>
      
      <p>Расмотрим простой пример использования марковских цепей в маркетинговом анализе. Поведение покупателя можно представить в виде пяти состояний: <eq>I</eq>&nbsp;—&nbsp;неведение, <eq>A</eq>&nbsp;—&nbsp;осведомлённость, <eq>C</eq>&nbsp;—&nbsp;заинтересованность, <eq>P</eq>&nbsp;—&nbsp;покупка и <eq>D</eq>&nbsp;—&nbsp;отказ от покупки. Цель маркетингового анализа&nbsp;— измерение доли клиентов, находящихся в этих состояниях и поиск способов увеличить долю <eq>P</eq>. Анкетирование и опросы позволяют оценить вероятности переходов между этими состояниями, а значит, можно построить цепь Маркова и вычислить стационарные вероятности всех состояний, возводя матрицу переходов цепи в достаточно большую степень.</p>

	<p>Предположим, в одном из торговых предприятий результаты опросов показали такую диаграмму вероятностей (они указаны в процентах):
<p><img src='img/merch.png' width='60%'/></p>

	<p>Эту диаграмму можно представить в форме матрицы переходов:
	<pre><hs>--      I     A      C      P     D
M [ [ 0.98, 0.015, 0.005, 0,    0    ]   -- I
  , [ 0.09, 0.61,  0.10,  0.12, 0.08 ]   -- A
  , [ 0.07, 0.05,  0.25,  0.53, 0.10 ]   -- C
  , [ 0,    0.01,  0.05,  0.70, 0.24 ]   -- P
  , [ 0,    0.50,  0.20,  0.15, 0.15 ] ] -- D</hs></pre> Такая матрица называется вероятностной матрицей. У таких матриц есть важная особенность: сумма элементов в каждом её ряду равна 1. Это свойство сохраняется и для произведения вероятностных матриц.</p>

	<task>Найдите стационарные доли клиентов, находящихся в каждом из этих пяти состояний. Выясните как увеличение охвата рекламой (увеличение вероятности переходов <eq>I \to A</eq> и <eq>I \to C</eq>) может увеличить ожидаемую долю продаж (<eq>P</eq>).</task>
	<task>Сравните чувствительность продаж к рекламе и к работе консультантов, которые увеличивают вероятность перехода <eq>A \to C</eq>. Чувствительность можно вычислять, как производную целевой вероятности как функции изменяемого параметра. Вводя параметр, необходимо следить за тем, чтобы сумма значений во всех строках вероятностной матрицы была равна 1.</task>
      
      
 <!--     <task>Числа одинаковых предметов, которые можно сложить в правильный многоугольник, образуют последовательности, называемые полигональными числами <p align='center'><img src="img/triangular.gif" alt="" width='60%'/><br/><img src="img/square.gif" alt="" width='60%'/><br/><img src="img/pentagonal.gif" alt="" width='60%'/></p> Последовательность полигональных чисел для <eq>k</eq>-угольника можно получить с помощью рекурретного уравнения<eqns>P^k_n = 3P^k_{n-1} - 3P^k_{n-2} + P^k_{n-3},\\ P^k_0 = 0, P^k_1 = 1, P^k_2=k.</eqns> Напишите функцию <code>polygonal k n</code>, вычисляющую <eq>n</eq>-ное полигональное число для <eq>k</eq>-угольника. Эти числа применяются в теории графов и в теории компьютерных сетей. Например минимальное число соединений, необходимыле для организации полносвязной сети из <eq>n</eq> процессоров равно <eq>P^3_{n-1}</eq>.</task> -->

<!--      <task>Существует определение для ряда чисел Фибоначчи, использующее концепцию коданных: <pre><hs>fibs = 0 : 1 : zipWith (+) fibs (tail fibs)</hs></pre> Объясните как оно работает и сравните его производительность с итеративным и моноидальным решениями <a href="flp-lab3.html#Fib">(Занятие 3)</a>.</task> -->

	<h2>Эндоморфизмы и свёртка</h2>

<p>Функции, имеющие тип <code>a -> a</code>, называются <strong>эндоморфизмами</strong>. Они тоже образуют моноид с операцией композиции и тождественной функцией в качестве нейтрального элемента:</p>
<eqn>(f \circ g) \circ h = f \circ (g \circ h),\quad \mathrm{id} \circ f = f \circ \mathrm{id} = f</eqn>

<p>Для них в модуле <code>Data.Monoid</code> определён моноид <code>Endo</code>:
  <pre><hs>newtype Endo a = Endo { appEndo :: a -> a }

instance Semigroup (Endo a) where
  Endo f <> Endo g = Endo $ f . g

instance Monoid (Endo a) where
  mempty = Endo id</hs></pre></p>

      <p>Свёртка и моноид — очень мощные и универсальные концепции, позволяющие единообразно обрабатывать алгебраические типы данных. Также как использование моноидов не ограничивается числами, свёртка не ограничивается обработкой списков. Сворачивать можно любые типы, являющиеся экземплярами класса <code>Foldable</code>.</p>

      <task>Загрузите модуль <code>Data.Foldable</code>. Посмотрите информацию о классе <code>Foldable</code>. Обратите внимание на то, как много встречавшихся нам ранее функций, обрабатывающих списки, определены для этого класса, а также на то, к каким ещё типам можно применить эти функции. </task>


      <p>В определении класса <code>Foldable</code> есть любопытная строчка:
	<pre><ghci><o> ...
 {-# MINIMAL foldMap | foldr #-}
 ...</o></ghci></pre>
	Она говорит о том, что определяя экземпляр этого класса для какого-то типа, достаточно определить только одну из этих двух функций, все остальные могут быть выражены через них. Получается, что функция <code>foldMap</code>, работающая с моноидами, является фундаментальной для свёртки.</p>
      
      <p>Посмотрим, как вычисляется свёртка списка правоассоциативной функцией <code>f</code>:</p>
      <pre><hs> foldr f x₀ [a, b, c] = f a (f b (f c x₀))</hs></pre>
      <p>
	Эту цепочку можно представить в виде цепочки аппликаций:</p>
      <pre><hs> f a . f b . f c $ x₀</hs></pre>
      
      <p>Если сворачивающая функция имела тип <code>f :: a -> b -> b</code>, то все функции в этой композиции будут иметь одинаковый тип: <code>b -> b</code>, то есть, являются эндоморфизмами. Это значит, что цепочку аппликаций, вычисляемую свёрткой, можно записать с помощью типа <code>Endo</code>:
	<pre><hs> f a . f b . f c = Endo (f a) <eq>\diamond</eq> Endo (f b) <eq>\diamond</eq> Endo (f c)</hs></pre></p>

      <task>Напишите реализацию функции <code>foldr</code>, используя только <code>foldMap</code> и тип <code>Endo</code>.</task>

      <p>Для левой свёртки цепочка вычислений в виде аппликаций записывается в обратном порядке:</p>
      <pre><hs>((x₀ `f` a) `f` b) `f` c = (`f` c) . (`f` b) . (`f` a) $ x₀</hs></pre>

<p> Для любого моноида существует так называемый <b>дуальный моноид</b>, отличающийся лишь порядком операндов. В модуле <code>Data.Monoid</code> определяется тип <code>Dual m</code>, который для любого моноида <code>m</code> представляет дуальный ему.
  <pre><hs>instance Semigroup m => Semigroup (Dual m) where 
  Dual m1 <> Dual m2 = Dual (m2 <> m1)

instance Monoid m => Semigroup (Dual m) where 
  mempty = Dual mempty</hs></pre> 
  Таким образом, моноиду <code>Endo</code> c операциeй <tt>(.)</tt> соответствует моноид <code>Dual . Endo</code> с операцией <tt>flip (.)</tt>. Для левой свёртки цепочка вычислений в виде аппликаций записывается так:</p>
      <pre><hs>Endo (`f` c) <eq>\diamond</eq> Endo (`f` b) <eq>\diamond</eq> Endo (`f` a) = 
 = Dual (Endo (`f` a)) <eq>\diamond</eq> Dual (Endo (`f` b)) <eq>\diamond</eq> Dual (Endo (`f` c))</hs></pre>
      
      <task>Определите левую свёртку <code>foldl</code>, через <code>foldMap</code>, <code>Endo</code> и <code>Dual</code>.</task>

    </div>      
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
    <script>
      var timesLines=`times 621 123 
times 621 123 = <rs>123</rs> + times 620 123
times 621 123 = <rs>123</rs> + times 310 (<r>123 + 123</r>)
times 621 123 = <rs>123</rs> + times 310 246
times 621 123 = <rs>123</rs> + times 155 (<r>246 + 246</r>)
times 621 123 = <rs>123</rs> + times 155 492
times 621 123 = <r>123 + 492</r> + times 154 492
times 621 123 = <rs>615</rs> + times 154 492
times 621 123 = <rs>615</rs> + times 77 (<r>492 + 492</r>)
times 621 123 = <rs>615</rs> + times 77 984
times 621 123 = <r>615 + 984</r> + times 76 984
times 621 123 = <rs>1599</rs> + times 76 984
times 621 123 = <rs>1599</rs> + times 38 (<r>984 + 984</r>)
times 621 123 = <rs>1599</rs> + times 38 1968
times 621 123 = <rs>1599</rs> + times 19 (<r>1968 + 1968</r>)
times 621 123 = <rs>1599</rs> + times 19 3936
times 621 123 = <r>1599 + 3936</r> + times 18 3936
times 621 123 = <rs>5535</rs> + times 18 3936
times 621 123 = <rs>5535</rs> + times 9 (<r>3936 + 3936</r>)
times 621 123 = <rs>5535</rs> + times 9 7872
times 621 123 = <r>5535 + 7872</r> + times 8 7872
times 621 123 = <rs>13407</rs> + times 8 7872
times 621 123 = <rs>13407</rs> + times 4 (<r>7872 + 7872</r>)
times 621 123 = <rs>13407</rs> + times 4 15744
times 621 123 = <rs>13407</rs> + times 2 (<r>15744 + 15744</r>)
times 621 123 = <rs>13407</rs> + times 2 31488
times 621 123 = <rs>13407</rs> + (<r>31488 + 31488</r>)
times 621 123 = <r>13407 + 62976</r>
times 621 123 = <rs>76383</rs>
times 621 123 = <rs>76383</rs>`
    
    animateText('times', timesLines, 800)
  </script>
  </body>
</html>

