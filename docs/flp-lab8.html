
<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>fmap {
      content: "hello&lt;$&gt;";
    }</style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
    
    <h2>Управление изменяемым состоянием</h2>

<p>Вычислительная мощность монад уже достаточно велика, для того чтобы с их помощью можно было решить любую алгоритмическую задачу. Существует огромное число самых разных монад и функторов, для различных целей. Они даже позволяют ввести в программу изменяемое состояние, не изменяя при этом принципам чистого функционального программирования.</p>

<p>Рассмотрим несложную задачу генерации бинарного дерева, хранящего в листьях и узлах какие-то значения:</p>
<pre><hs>data BTree a = Leaf a
             | Node a (BTree a) (BTree a)
    deriving Show</hs></pre>

<p>Пусть перед нами стоит задача сгенерировать сбалансированное дерево заданной глубины, последовательно нумеруя при этом листья и узлы. В нефункциональных языках мы бы завели переменный счётчик и по мере создания дерева увеличивали бы его значение. Но переменных у нас нет, как нет и понятия времени, то есть чётко заданной последовательности действий.</p>

<p>С помощью монад мы способны задать семантику вычислений, в которой появляются и изменяемое состояние и время. Для этого создадим новый тип-контейнер <code>State</code>:</p>
<pre><hs>data State s a = State (s -> (s, a))</hs></pre>

    <p>и две функции для работы с этим типом:</p>

    <pre><hs><d>runState :: State s a -> s -> (s, a)</d>
runState (State f) = f

<d>evalState :: State s a -> s -> a</d>
evalState (State f) = snd . f</hs></pre>
<p>Тип <code>State</code> представляет собой обёртку для функции, которая принимает состояние типа <code>s</code> и возвращает новое состояние и некий результат типа <code>a</code>. Тип <code>State</code> можно объявить экзепляром классов <code>Functor</code>, <code>Applicative</code> и <code>Monad</code>:</p>
<pre><hs>instance Functor (State s) where
  fmap f p = State $ \s -> f <$> runState p s

instance Applicative (State s) where
  pure x  = State $ \s -> (s, x)
  (<*>) = ap
  
instance Monad (State s) where
  p >>= f = State $ \s -> let (s', y) = runState p s
                          in runState (f y) s'</hs></pre>

<p>Эти определения стоят того, чтобы над ними помедитировать. Монадическое поведение <code>State</code> состоит в передаче состояния от вычисления к вычислению.</p>

<p>Для того, чтобы состояние использовать и изменять нужны вспомогательные функции:</p>
<pre><hs><d>get :: State s s</d>
get = State $ \s -> (s, s)

<d>set :: s -> State s s</d>
set s = State $ const (s, s)

<d>modify :: (s -> s) -> State s s</d>
modify f = get >>= set . f</hs></pre>
<p>Функция <code>get</code> превращает состояние в результат вычисления, функция <code>set</code> устанавливает значение состоянию, а <code>modify</code> их комбинирует и изменяет состояние с помощью указанной функции. Вот как они работают:</p>
<pre><ghci><l></l> runState get 6
<o>(6,6)</o>
<l></l> runState (set 5) 6
<o>(5,5)</o>
<l></l> runState (modify (+ 1)) 6
<o>(7,7)</o></ghci></pre>

<p>Это пока выглядит достаточно абстрактно, а вот процесс использования достаточно прост и прямолинеен. Вот как с их помощью можно решить задачу генерации дерева с нумерованными узлами и вершинами:</p>
<pre><hs>mkTree 0 = Leaf <$> modify (+ 1)
mkTree n = Node <$> modify (+ 1)
                <*> mkTree (n - 1)
                <*> mkTree (n - 1)</hs></pre>
<pre><ghci><l></l> mkTree 2 `evalState` 0
<o>(7, Node 1 (Node 2 (Leaf 3) (Leaf 4))
           (Node 5 (Leaf 6) (Leaf 7)))</o></ghci></pre>
<p>Здесь состоянием является целое число, играющее роль счетчика. Мы вызываем генератор дерева с начальным значением счётчика 0, по мере своей работы он создёт элементы дерева, увеличивая это значение. В конце мы получаем готовое дерево и текущее значение счетчика — 7. Функция <code>mkTree</code> чистая и повторный её вызов всегда будет приводить к одинаковому результату.</p>

    <p>Аппликативное определение функции <code>mkTree</code>, которое мы дали выше можно переписать с помощью монадической операции <code>>>=</code> так, чтобы стал виден порядок вычислений:</p>
<pre><hs>mkTree n = modify (+ 1)
           >>= \i -> mkTree (n - 1)
                     >>= \l -> mkTree (n - 1)
                               >>= \r -> pure (Node i l r)</hs></pre>

<p>Такая запись громоздка и для неё в языке Haskell существует специальная синтаксическая форма:</p>
<pre><hs>mkTree n = do i <- modify (+ 1)
              l <- mkTree (n - 1)
              r <- mkTree (n - 1)
              pure $ Node i l r</hs></pre>
 <p>Она уже очень похожа на императивную программу! Давате поменяем порядок обхода дерева:</p>
<pre><hs>mkTree n = do l <- mkTree (n - 1)
              i <- modify (+ 1)
              r <- mkTree (n - 1)
              pure $ Node i l r</hs></pre>
<pre><ghci><l></l> mkTree 2 `evalState` 0
<o>(7, Node 4 (Node 2 (Leaf 1) (Leaf 3))
           (Node 6 (Leaf 5) (Leaf 7)))</o></ghci></pre>
<p>Как полагается, при изменении состояния, порядок вычислений начинает играть существенную роль, и теперь мы получили левый обход дерева!</p>

<task>Напишите обход дерева в глубину слева и правый обход дерева.</task>

<p>Наконец, давайте полностью инкапсулируем монадические вычисления:</p>
<pre><hs><d>enumTree :: Int -> BTree Int</d>
enumTree n = evalState (mkTree n) 0</hs></pre>

<p>В таком виде функцию <code>enumTree</code> можно использовать в любых вычислениях, она имеет тип, ничего не говорящий о том, что внутри неё работала монада <code>State</code>.</p>


<task>Напишите функцию, создающую треугольник Флойда с использованием сквозного счетчика в монаде <code>State</code>.
  <details><summary>Вариант решения</summary>
    <pre><hs>floyd = mapM (`replicateM` (modify (+ 1))) [1 ..]</hs></pre>
    Это решение требует ленивой реализации монады <code>State</code>. 
<pre><hs>instance Monad (State s) where
  p >>= f = State $ \s -> let ~(s', y) = runState p s
                          in runState (f y) s'</hs></pre>
Разница между ленивой и строгой реализацияей состоит лишь в знаке ленивого сопоставления с образцом <code>~</code>.
		    </details>
</task>

<h2>Генерация псевдослучайных чисел</h2>

<p>Монада <code>State</code> позволяет изящно реализовать работу со случайными числами, которые бывают нужны в самых разных задачах: методе Монте-Карло, тестировании больших чисел на простоту, написании игр, генерации тестовых данных и пр.</p>

<p>Мы реализуем линейный конгруэнтный метод генерации натуральных псевдослучайных чисел, использующий следующую итерационную формулу: 
<eqn>X_{n+1} = (a X_n + c)\ \mathrm{mod}\ m.</eqn>
В основных реализациях языка C (ANSI C, C++, gcc) используются такие значения: <eq>a=1103515245</eq>, <eq>c=12345</eq> и <eq>m=2^{31}-1</eq>. Этот метод требует начального значения <eq>X_0</eq> (random seed) для генерации последовательности <eq>X</eq>, обычно для него используется внутренее абсолютное время процессора.</p>

<p>Определим наш генератор последовательности псевдослучайных целых чисел на отрезке <eq>[0, k]</eq> таким образом:</p>
<pre><hs>type Random a = State Integer a

<d>random :: Integral a => a -> Random a</d>
random k = rescale <$> modify iter 
  where
    iter x = (x * a + c) `mod` m
    (a, c, m) = (1103515245, 12345, 2^31-1)
    rescale x = fromIntegral x `mod` k</hs></pre>

<p>Вот примеры его работы:</p>
<pre><ghci><l></l> random 100 `runState` 42
<o>(1250496027,27)</o>
<l></l> replicateM 10 (random 100) `runState` 42
<o>(1535244752,[27,64,53,6,35,32,33,66,59,52])</o></ghci></pre>

<p>Первое число в паре -- текущее состояние генератора псевдослучайных чисел,
а второй элемент пары содержит результат вычислений: число или, например, список. 
Если нам требуется только это значение, будем использовать функцию <code>evalState</code>.</p>

<p>Вот как можно сгенерировать случайное дерево ограниченное указанной глубиной:</p>
<pre><hs>randomTree 0 = Leaf <$> random 100
randomTree n = Node <$> random 100
               <*> (random n >>= randomTree)
               <*> (random n >>= randomTree)</hs></pre>
<pre><ghci><l></l> randomTree 3 `evalState` 41
<o>Node 82 (Leaf 44) (Node 82 (Leaf 40) (Leaf 66))</o>
<l></l>  randomTree 3 `evalState` 42
<o>Node 27 (Node 53 (Leaf 35) (Leaf 33)) (Leaf 59)</o>
<l></l>  randomTree 3 `evalState` 43
<o>Node 24 (Node 62 (Leaf 88) (Leaf 26)) (Node 52 (Node 54 (Leaf 72) (Leaf 82)) (Node 0 (Leaf 78) (Leaf 92)))</o></ghci></pre>

<p>Наконец, можно выйти во внешний мир с помощью монады <code>IO</code> и запросить абсолютное время у процессора в качестве затравки генератора. Функция <code>getCPUTime</code> определена в библиотеке <tt>System.CPUTime</tt>. </p>
<pre><hs><d>randomIO :: Integral a => a -> IO a</d>
randomIO n = evalState (random n) <$> getCPUTime</hs></pre>
<pre><ghci><l></l> randomIO 100
<o>5</o>
<l></l> randomIO 100
<o>21</o>
<l></l> replicateM 10 (randomIO 100)
<o>[17,5,13,61,53,93,33,9,29,33]</o></ghci></pre>

<p>Теперь вы никогда не получите два одинаковых случайных дерева, но вынуждены будете всегда работать в монаде <code>IO</code>.</p>

<hr/>
    
<p>Созданная нами на прошлом занятии система генерации выражений какого-то языка 
по заданной грамматике способна работать в монаде <code>State</code>.
 Для этого можно определить инструменты для погружения элементов грамматики в аппликативный контекст:
  <pre><hs>-- указанный символ
chA = pure . pure
-- любой из указанных символов
altA = getAlt . foldMap (Alt . chA)
-- цепочка указанных символов
strA xs = foldMap chA xs
-- случайный символ из списка символов
rnd cs = pure $ randomSample cs

-- случайный элемент списка
<d>randomSample :: [a] -> Random a</d>
randomSample lst = (lst !!) <$> random (length lst)
	  
-- генерация внутри аппликативного функтора
<d>languageA :: Grammar (Random a) -> Random [[a]]</d>
languageA = fmap samples . traverse sequenceA . generate  </hs></pre>
</p>

Для того, чтобы эти определения прошли проверку типов нужно объявить тип <code>Random a</code> экземплярами классов
<code>Alphabetic</code> и <code>Eq</code>:
<pre><hs>instance Alphabetic a => Alphabetic (Random a) where
  charset = pure <$> charset

instance Eq (Random a) where
  a == b = False</hs></pre>

<p>Порождающая грамматика арифметических выражений со случайными числами будет мало отличаться от варианта, не использующего изменяемое состояние:</p>
<pre><hs><d>arythmeticsA :: Grammar (Random Char)</d>
arythmeticsA = expr
  whereg
    expr = term <> many (altA "+-" <> term)
    term = mult <> many (altA "*/" <> mult)
    mult = num <|> chA '(' <> expr <> chA ')'
    num = rnd "123456789"</hs></pre>

<pre><ghci><l></l> take 20 $ languageA arythmeticsA `evalState` 42
<o>["4","6+7","7*5","2+5+7","6*1+1","(2)","1+3*9"
,"6*8+9+6","(8)+3","6*1*7","6+6+2+7","3*5+8*7"
,"(6)+7+9","9*3*2+3","(5)*4","8+8*6+1"
,"9*3+4+2+4","(3)+3*3","3*1*4+7+3","(8)*9+4"]</o></ghci></pre>


<details><summary><b>Дополнительный материал</b></summary>

<p>Давайте, завершая тему случайных чисел, напишем классическую игру в угадайку, которая есть во всех курсах по элементарному программированию. Программа должна "задумать" случайное число, а человек в диалоге с ней попытаться его угадать, получая подсказки типа "больше" или "меньше". </p>
    <p>Наша программа будет генерировать случайное число и передавать его интерактивному собеседнику — функции <code>dialog</code>:</p>
    <pre><hs><d>ugadaika :: Integer -> IO ()</d>
ugadaika n = randomIO n >>= dialog</hs></pre>
    <p>Функция <code>dialog</code> может быть устроена, например, так:</p>
    <pre><hs><d>dialog :: Integer -> IO ()</d>
dialog x = do
  y <- read <$> getLine
  case compare x y of
    LT -> print "less" >> dialog x
    GT -> print "greater" >> dialog x
    EQ -> print "yes!"</hs></pre>

    <p>Вот и всё, можно играть!</p>
<pre><ghci><l></l> ugadaika 100
<o>67
less
30
less
10
greater
13
yes!</o></ghci></pre>

<task>Если угадывать число методом деления отрезка пополам, то это можно сделать достаточно эфеективно. Измените программу <code>ugadaika</code> так, чтобы количество угадываний было ограничено, например оно может быть на единицу больше целой части логарифма по основанию 2 от диапазона, в котором лежит задуманное число.</task>

<pre><ghci><l></l> ugadaika 100
<o>You have 8 guesses
50
less (7 guesses left)
25
less (6 guesses left)
12
greater (5 guesses left)
17
...</o></ghci></pre>
</details>

 <h2>Трансляция арифметических выражений. Алгоритм Дейкстры</h2>

  <p>Мы научились генерировать арифметические выражения в традиционной нотации, теперь пора перейти к более важной обратной задаче — к чтению и трансляции этих выражений.</p><p> Существует эффективный алгоритм трансляции традиционной нотации арифметики в обратную польскую, известный как алгоритм сортировочной станции или алгоритм Дейкстры. Он состоит из двух частей: лексического анализа и трансляции. Лексический анализ превращает последовательность символов в последовательность токенов (лексем) — базовых единиц языка, таких как числа, операции, идентификаторы и т. д. На этом этапе удаляются незначащие пробелы и обнаруживаются синтаксические ошибки связанные с нераспознанными символами. Второй этап трансляции пробразует последовательность лексем в выходную последовательность, выполняя операции со стеком согласно следующему алгоритму:</p>

      <ul>
	<li> Пока не все токены обработаны:</li>
	<ul>
	  <li> Прочитать токен.</li>
	  <li> Если токен — оператор <eq>op_1</eq>, то:</li>
	  <ul>
	    <li> Пока присутствует на вершине стека токен оператор <eq>op_2</eq>, чей приоритет выше или равен приоритету <eq>op_1</eq>, и при равенстве приоритетов <eq>op_1</eq> является левоассоциативным:</li>
	    <ul>
	      <li> переложить <eq>op_2</eq> из стека в выходную очередь;</li>
	    </ul>
	    <li> Положить <eq>op_1</eq> в стек.</li>
	  </ul>
	  <li> Если токен — открывающая скобка, то положить его в стек.</li>
	  <li> Если токен — закрывающая скобка:</li>
	  <ul>
	    <li>Пока токен на вершине стека не является открывающей скобкой, перекладывать операторы из стека в выходную очередь.</li>
	    <li>Выкинуть открывающую скобку из стека, но не добавлять в очередь вывода.</li>
	    <li> Если стек закончился до того, как был встречен токен открывающая скобка, то в выражении пропущена открывающая скобка.</li>
	  </ul>
	  <li> Если больше не осталось токенов на входе:</li>
	  <ul>
	    <li>Пока есть токены операторы в стеке:</li>
	    <ul>
	      <li>Если токен оператор на вершине стека — скобка, то в выражении присутствует незакрытая скобка.</li>
	      <li>Переложить оператор из стека в выходную очередь.</li>
	    </ul>
	  </ul>
	  <li> Если токен — число, то добавить его в очередь вывода.</li>
	</ul>
      </ul>

<p>Вот как работатет этот алгоритм на простом примере:</p>
      <pre class="animate" id='dijkstraA'></pre>
      
<p>Алгоритм Дейкстры можно реализовать практически один в один в чистой функциональной программе с использованием монады <code>State</code>. Для этого напишем полезные универсальные функции для работы со стеком.</p>
<pre><hs>type StackFn a = State [a] [a]

<d>evalStackFn :: StackFn a -> [a]</d>
evalStackFn fn = evalState fn []

-- поместить значение на вершину стека
<d>push :: a -> StackFn a</d>
push x = modify (x:) >> return []

-- получить значение на вершине стека
<d>peek :: StackFn a</d>
peek = take 1 <$> get

-- снять значение с вершины стека
<d>pop :: StackFn a</d>
pop = get >>= split
  where split [] = return []
        split (x:s) = set s >> return [x]

-- снимать с вершины стека все значения
-- до тех пор, пока выполняется указанное условие
<d>popWhile :: (a -> Bool) -> StackFn a</d>
popWhile p = do (r, s') <- span p <$> get
                set s'
                return r</hs></pre>

 <p>Эти функции используют монаду <code>[]</code> для обработки исключительных ситуаций. С их помощью шаг алгоритма Дейкстры можно записать буквально так:</p>

 <pre><hs><d>step :: String -> StackFn String</d>
step x
  | isOperator x =
      do r <- popWhile (\y -> prec x < prec y)
         push x
         return r
  | x == "(" = push "("
  | x == ")" =
      do r <- popWhile (/= "(")
         pop
         return r
  | otherwise = return [x]
 
isOperator = (`elem` ["+","-","*","/"])

prec x = case x of
  "*" -> 2
  "/" -> 2
  "+" -> 1
  "-" -> 1
  "(" -> 0</hs></pre>

<p>Все этапы обработки возвращают списки результатов (возможно, пустые). Это позволяет представить основной цикл алгоритма Дейкстры в виде моноидальной свёртки.</p>
 
 <pre><hs><d>dijkstra :: [String] -> [String]</d>
dijkstra s = evalStackFn $ (<>) <$> foldMapM step s <*> get</hs></pre>

<p>Моноидальную свёртку, выполняемую в какой-то монаде определить нетрудно:</p>

  <pre><hs><d>foldMapM :: (Monoid b, Monad m) => (a -> m b) -> [a] -> m b</d>
foldMapM f xs = mconcat <$> mapM f xs</hs></pre> 

<p>Наконец, добавим простой лексический анализ, то есть, превращение строки в последовательность токенов — чисел, операторов и скобок. И эту задачу тоже легко можно выполнить с помощью моноидов:</p>

<pre><hs><d>lexer :: String -> [String]</d>
lexer = words . foldMap separate
  where separate x
          | x `elem` "+-*/()" = " " <> [x] <> " "
          | otherwise = [x]</hs></pre>


<task>Соберите все написанные нами части в функцию <code>toRPN</code>, которая транслирует строку с арифметическим выражением в инфиксной нотации в обратную польскую нотацию. </task>
<pre><hs>toRPN "23 + 8"           ==> "23 8 +"
toRPN "23 + 8*66"        ==> "23 8 66 * +"
toRPN "(23 + 8)*66"      ==> "23 8 + 66 *"
toRPN "14 - (23 - 8)"    ==> "14 23 8 - -"
toRPN "(14 - 23) - 8"    ==> "14 23 - 8 -"
toRPN "(((14)))"         ==> "14"
toRPN "(2 + 13*4 - 6)*5" ==> "2 13 4 * + - 6 5 *"</hs></pre>

<task>Напишите интерактивную программу-калькулятор <code>calcIO :: IO ()</code>, способную вычислять арифметические выражения, считывая задачи с клавиатуры.</task>
<pre><ghci><l></l> calcIO
34
> 34.0
34+98
> 132.0
5 + 7*7
> 54.0
(5 + 7)*7
> 84.0
9 - 4 - 2
> 7.0</ghci></pre>

	      </div>

<p id="footer"></p>

<script src="lib/postprocessing.js"></script>
<script>
  var dijkstraHeader = `<rs>             вывод</rs><r>     стек</r>  вход`

  var dijkstraLines = `<rs>                   </rs><r>       []</r>  ( 2 + 13 * 4 - 6 ) * 5
<rs>                   </rs><r>       []</r>  ( 2 + 13 * 4 - 6 ) * 5
<rs>                   </rs><r>      [(]</r>  2 + 13 * 4 - 6 ) * 5
<rs>                  2</rs><r>      [(]</r>  + 13 * 4 - 6 ) * 5
<rs>                  2</rs><r>    [+ (]</r>  13 * 4 - 6 ) * 5
<rs>               2 13</rs><r>    [+ (]</r>  * 4 - 6 ) * 5
<rs>               2 13</rs><r>  [* + (]</r>  4 - 6 ) * 5
<rs>             2 13 4</rs><r>  [* + (]</r>  - 6 ) * 5
<rs>           2 13 4 *</rs><r>    [+ (]</r>  - 6 ) * 5
<rs>         2 13 4 * +</rs><r>      [(]</r>  - 6 ) * 5
<rs>       2 13 4 * + -</rs><r>      [(]</r>  6 ) * 5
<rs>     2 13 4 * + - 6</rs><r>      [(]</r>  ) * 5
<rs>     2 13 4 * + - 6</rs><r>       []</r>  * 5
<rs>     2 13 4 * + - 6</rs><r>      [*]</r>  5
<rs>   2 13 4 * + - 6 5</rs><r>      [*]</r>  
<rs> 2 13 4 * + - 6 5 *</rs><r>       []</r>  
<rs> 2 13 4 * + - 6 5 *</rs><r>       []</r>`
  
  animateText('dijkstraA', dijkstraLines, 800, dijkstraHeader)
  
</script>
</body>
</html>

