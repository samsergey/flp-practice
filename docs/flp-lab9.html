<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = "Parsing";
    </script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <p>Начиная  с этого занятия мы будем последовательно создавать систему для комбинáторного синтаксического разбора (парсинга) и трансляции произвольных языков. Результатом этой работы станет легко расширяемый и очень гибкий инструментарий, подобный промышленным комбинáторным парсерам <code>Parsec</code> в Haskell или <code>Parser Combinators</code> для Scala .</p>

      <p>Определения для этих занятий предлагаем записывать в модуль <code>Parsing.hs</code>. Нам потребуются некоторые библиотеки.</p>
      <pre><hs>module Parsing where

import Control.Monad
import Control.Applicative
import Data.Char</hs></pre></p>
      
      <h2>Транслятор и результат трансляции</h2>

      <p>Транслятор арифметических выражений, написанный нами на прошлом занятии, "обучен" только одной грамматике, которая вшита в него в неявном виде. Его непросто расширить для того, чтобы разбирать что-то ещё кроме арифметических выражений.</p>
      
      <p>Универсальный транслятор мы построим на базе аппликативного альтернативного функтора с возможностями генерации сообщений об ошибках. Тип транслятора для строк, в самом общем случае, может быть таким:</p>

      <pre><hs>data Parser a = Parser { run :: String -> Result a }

data Result a = Ok a String
              | Fail String
              | Error String
  deriving (Show, Eq)</hs></pre>
      
      <p>где <code>a</code>&nbsp;— тип результата трансляции. Разница между состояниями <code>Fail</code> и <code>Error</code> состоит в том, что <code>Error</code> прерывает разбор, выдавая сообщение об ошибке, а <code>Fail</code> позволяет продолжить его по какой-то альтернативной ветке в грамматике.</p>

      <p>Можно создать первый почти тривиальный, но полезный комбинатор, считывающий первый произвольный символ в строке. Он соответствует метасиволу <tt>.</tt> в регулярных выражениях.</p>
      <pre><hs>next = Parser $ \r -> case r of
  x:xs -> Ok x xs
  [] -> Fail r</hs></pre>
      <p>Вот примеры его работы:</p>
      <pre><ghci><l></l> run next "abc"
<o>Ok 'a' "bc"</o>
<l></l> run next ""
<o>Fail ""</o></ghci></pre>      

      <task>Напишите определение для парсера <code>end</code>, который распознаёт пустую строку.
      
      <pre><ghci><l></l> run end "123"
<o>Fail "123"</o>
<l></l> run end ""
<o>Ok () ""</o></ghci></pre>
      <details><summary>Вариант решения</summary>
	<pre><hs>end :: Parser ()
end = Parser $ \r -> case r of
  [] -> Ok () []
  r  -> Fail r</hs></pre>
      </details>
      </task>
      
      <task>Напишите определение для парсера <code>check p</code>, который распознаёт символ по указанному предикату <code>p</code>:
      <pre><ghci><l></l> run (check isDigit) "123"
<o>Ok '1' "123"</o>
<l></l> run (check isDigit) "abc"
<o>Fail "abc"</o>
<l></l> run (check isUpper) "Abc"
<o>Ok 'A' "bc"</o>
<l></l> run (check isUpper) "abc"
<o>Fail "abc"</o></ghci></pre>
      <details><summary>Вариант решения</summary>
	<pre><hs>check :: (Char -> Bool) -> Parser Char
check p = Parser $ \r -> case r of
  x:xs | p x -> Ok x xs
  _          -> Fail r </hs></pre>
      </details>

      С его помощью определите несколько полезных парсеров:
      <ul>
	<li> <code>char c</code> — распознаёт конкретный символ <code>c</code>,</li>
	<li> <code>digit</code> — распознаёт произвольную цифру.</li>
	<li> <code>set s</code> — распознаёт символы из указанного списка.</li>
      </ul>      </task>

      <pre><hs>char :: Char -> Parser Char
digit :: Parser Char
set :: [Char] -> Parser Char </hs></pre>
      <pre><ghci><l></l> run (char 'x') "xor"
<o>Ok 'x' "or"</o>
<l></l> run digit "123"
<o>Ok '1' "23"</o>
<l></l> run (set "()[]{}") "(+ 1 2)"
<o>Ok '(' "+ 1 2)"</o>
<l></l> run (set ['a'..'z']) "cat"
<o>Ok 'c' "at"</o></ghci></pre> </task>

      <h2>Обработка результата трансляции</h2>
      
      <p>Наполним теперь наши типы семантикой. Первым делом, полезно будет сделать результат разбора функтором:</p>
      <pre><hs>instance Functor Result where
  fmap f r = case r of
    Ok a s -> Ok (f a) s
    Fail s -> Fail s
    Error m -> Error m</hs></pre>

      <pre><ghci><l></l> toUpper <$> run next "abc"
<o>Ok 'A' "bc"</o>
<l></l> isDigit <$> run next "abc"
<o>Ok False "bc"</o></ghci></pre>      

      <p>Теперь функтором несложно сделать любой парсер, так чтобы он сам мог "отвечать" за преобразование результата:</p>
      <pre><hs>instance Functor Parser where
  fmap f p = Parser $ \s -> f <$> run p s</hs></pre>
      

      <pre><ghci><l></l> run (toUpper <$> next) "abc"
<o>Ok 'A' "bc"</o>
<l></l> run (isDigit <$> next) "abc"
<o>Ok False "bc"</o></ghci></pre>      
      
      <h2>Последовательное выполнение трансляторов</h2>

<p>Последовательное выполнение трансляции подразумевает передачу разбираемой строки от одного транслятора к другому в цепочке подобно тому, как это делалось в монаде <code>State</code>. При этом, если какой-то из трансляторов в цепочке завершил свою работу неудачей или ошибкой, то и разбор цепочки на этом должен прекращаться. Такое поведение проще всего описать с помощью оператора <code><*></code>, наделив тип <code>Parser</code> аппликативными свойствами.</p>

<pre><hs>instance Applicative Parser where
  pure x = Parser $ Ok x
  p1 <*> p2 = Parser $ \s ->
    case run p1 s of
      Ok f s' -> f <$> run p2 s'
      Fail s' -> Fail s'
      Error m -> Error m</hs></pre>

<p>Аппликативное поведение даёт нам очень много возможностей для трансляции цепочек. Например, таким образом можно считать два первых символа в разбираемой строке и вернуть их в виде кортежа:</p>
<pre><ghci><l></l> run ((,) <$> next <*> next) "abc"
<o>Ok ('a','b') "c"</o></ghci></pre>

<p>В библиотеке <tt>Control.Applicative</tt> кроме оператора <code><*></code> определены "однобокие" операторы <code>*></code> и <code><*</code>, которые игнорируют результат левого и правого аргументов, соответственно. Они позволяют отбрасывать считываемые символы, если они не нужны в результате:</p>
<pre><ghci><l></l> run (next *> next) "abc"
<o>Ok 'b' "c"</o>
<l></l> run (next <* next) "abc"
<o>Ok 'a' "c"</o>
<l></l> run (char '(' *> digit <* char ')') "(4)"
<o>Ok '4' ""</o></ghci></pre>

<p>Для всех аппликативных функторов определены две функции <code>sequenceA</code> и <code>traverse</code> вот их тип (немного упрощённый):
  <pre><hs>sequenceA :: Applicative f => [f a] -> f [a]
traverse :: Applicative f => (a -> f b) -> [a] -> f [b]</hs></pre>
Они позволяют превратить последовательность аппликативных функторов, в результат их последовательной работы. В нашем случае ос их помощью можно список парсеров превратить в парсер, распознающий их последовательность, и возвращающий список результатов разбора:</p>
<pre><ghci><l></l> run (sequenceA [char 'c', char 'a']) "catana"
<o>Ok "ca" "tana"</o>
<l></l> run (sequenceA [char 'c', char 'a']) "city"
<o>Fail "ity"</o>
<l></l> run (traverse char "cat") "catalog"
<o>Ok "cat" "alog"</o></ghci></pre>

  <hr/>

<task>Напишите парсер <code>string s</code>, распознающий конкретную строку</task>
<pre><ghci><l></l> run (string "cat") "catana"
<o>Ok "cat" "ana"</o></ghci></pre>

  <hr/>

<task>Напишите комбинатор <code>rep n p</code>, распознающий повторение указанного парсера <code>p</code> ровно <code>n</code> раз и возвращающего список результатов.</task>
<pre><ghci><l></l> run (rep 3 next) "catalog"
<o>Ok "cat" "alog"</o>
<l></l> run (rep 4 digit) "123456"
<o>Ok "1234" "56"</o>
<l></l> run (rep 4 digit) "123"
<o>Fail ""</o></ghci></pre>

<p>С помощью функции <code>pure</code> мы можем вводить любые значения в результат разбора. В частности, с его помощью можно определить пустой символ <eq>\varepsilon</eq>: </p>
<pre><hs>epsilon :: Parser ()
epsilon = pure ()</hs></pre>

  <pre><ghci><l></l> run epsilon "abc"
<o>Ok () "abc"</o>
<l></l> run (next *> epsilon *> next) "abc"
<o>Ok 'b' "c"</o></ghci></pre>
  
  <hr/>
  
<task>Напишите универсальный комбинатор <code>neg</code>, который возвращал бы отрицание указанного транслятора <code>p</code>, то есть, "что угодно, только не <code>p</code>".</task> 
<pre><ghci><l></l> run (neg end) "abc"
<o>Ok () "abc"</o>
<l></l> run (neg digit) "abc"
<o>Ok () "abc"</o>
<l></l> run (neg digit) "123"
<o>Fail "123"</o>
<l></l> run (neg $ string "cat") "dog"
<o>Ok () "dog"</o>
<l></l> run (neg $ string "cat") "cat"
<o>Fail "cat"</o></ghci></pre>

      <h2>Альтернативное выполнение трансляторов</h2>

      <p> В формальных грамматиках есть цепочки элементов грамматики и альтернативы. Цепочки мы строить умеем с помощью аппликативных свойств, приступим к альтернативным свойствам.</p>

      <pre><hs>instance Alternative Parser where
  empty = Parser Fail
  p1 <|> p2 = Parser $ \s ->
    case run p1 s of
      Ok x s' -> Ok x s'
      Fail _ -> run p2 s
      Error m -> Error m</hs></pre>

      <p> Теперь у нас появился выбор!!</p>
      <pre><ghci><l></l> run (char 'a' <|> char 'b') "abab"
<o>Ok 'a' "bab"</o>
<l></l> run (char 'a' <|> char 'b') "bbab"
<o>Ok 'b' "bab"</o>
<l></l> run (char 'a' <|> char 'b') "vbbab"
<o>Fail "vbbab"</o>
<l></l> run (string "cat" <|> string "dog") "cat"
<o>Ok "cat" ""</o>
<l></l> run (string "cat" <|> string "dog") "dog"
<o>Ok "dog" ""</o></ghci></pre>

      <p> Наличие свободного выбора и умение им пользоваться&nbsp;— это поистине великая вещь! Теперь мы можем определить транслятор для любой контекстно-свободной грамматики, ведь они описываются правилами такого рода:</p>
    <eqn>
A \rightarrow \alpha ~|~ \beta ~|~ \gamma ~|~ ...
    </eqn>
      <p>где <eq>\alpha, \beta, \gamma...</eq>&nbsp;— цепочки элементов грамматики: терминалов и нетерминалов. Цепочки мы создавать умеем и альтернативы определять можем, а сами правила соответствуют определениям функций. То есть, определяя функцию, мы определяем нетерминальный символ, и задание анализатора для КС-грамматики&nbsp;— это последовательность определений функций-нетерминалов через комбинации цепочек и альтернатив.</p>

      <p>Построенная нами система трансляции называется <em>"трансляцией методом рекурсивного спуска"</em>. Она начинает разбор с самого общего нетерминала и далее, вызывая функции-нетерминалы, которые используются в правых частях определений, спускается вниз по синтаксическому дереву.</p>

      <p> У этого метода есть серьёзное ограничение на допустимые грамматики&nbsp;— они не должны быть <em>лево-рекурсивными</em>.</p>

      <details><summary>Подробнее о L-грамматиках</summary>

	<p>Лево-рекурсивной (или L-грамматикой) называется грамматика, которая содержит правила вида:</p>

	<eqns>A \rightarrow A \alpha ~|~ \alpha'</eqns>

	<p> Метод рекурсивного спуска, встретив левую рекурсию, "проваливается" в бесконечный цикл. Это существенное ограничение, но любое лево-рекурсивное правило можно преобразовать в эквивалентное не лево-рекурсивное:</p>

	<eqns>A \rightarrow \alpha' A'\\
	  A' \rightarrow  \alpha A' ~|~ \varepsilon
	</eqns>

<p>Например, грамматика для левоассоциативного вычитания лево-рекурсивна (что естественно):
	<eqns>E \rightarrow E - T | T</eqns>
	но её можно преобразовать, исключив левую рекурсию:
	<eqns>E \rightarrow T E'\\
	  E' \rightarrow  - T E' ~|~ \varepsilon
	</eqns>

	<p>Это можно сделать автоматически, но обычно об этом заботится тот, кто пишет грамматику для конкретного анализатора.</p>

      </details>

      <p>Давайте же определим анализатор для какой-нибудь простой нерегулярной грамматики! Например, для такой, которая порождает цепочки вида <eq>(ab)^nba^n</eq>:</p>

    <eqns>
      A \rightarrow \text{'a'}~\text{'b'}~A~\text{'a'} ~|~ \text{'b'} 
    </eqns>
    <pre><hs>_A = (char 'a' *> char 'b' *> _A *> char 'a') 
     <|> char 'b'</hs></pre>

    <task>Протестируйте правильность работы парсера <code>_A</code>.</task>

    
    <p>А как насчёт более сложной грамматики для арифметических выражений с целыми числами, правоассоциативной операцией сложения и скобками?</p>

    <eqns>
      E \rightarrow T ~\text{'+'}~ E ~|~ T\\
      T  \rightarrow \text{'('}~E~\text{')'} ~|~ N\\
      N \rightarrow d ~(N ~|~ \varepsilon)
    </eqns>

    
   <pre><hs>_E = _T >> term '+' >> _E <|> _T
_T = term '(' >> _E >> term ')' <|> _N
_N = digit >> (_N <|> epsilon)</hs></pre>

    <p>Выглядит неплохо. Но не компилируется!</p>

    <pre><ghci><err>parserM.hs:83:37-38: Couldn't match type ‘()’ with ‘Char’ …
    Expected type: Parser [Char] Char
      Actual type: Parser [Char] ()
    In the second argument of ‘(<|>)’, namely ‘_N’
    In the expression: term '(' >> _E >> term ')' <|> _N
Compilation failed.</err></ghci></pre>

    <details><summary>Учите английский!!</summary>
    <pre><ghci><err>parserM.hs:83:37-38: Не смог сопоставить тип ‘()’ с ‘Char’ …
     Ожидаемый тип: Parser [Char] Char
    Полученный тип: Parser [Char] ()
    Во втором аргументе ‘(<|>)’, а именно ‘_N’
    В выражении: term '(' >> _E >> term ')' <|> _N
Компиляция не удалась.</err></ghci></pre></details>
    
    <p>Компилятор даёт исчерпывающее объяснение, что именно ему не понравилось. Вот бы все компиляторы так внятно изъяснялись! То есть, транслятор <code>term</code> возвращает тип <code>Char</code>, а анализатор <code>_N</code>&nbsp;— <code>()</code>, и их нельзя комбинировать оператором <code><|></code>. Вот его тип:</p>

    <pre><ghci><l></l> :t (<|>)
<o>(<|>) :: Parser i a -> Parser i a -> Parser i a</o></ghci></pre>

    <p>Значит, надо привести типы комбинируемых выражений к одному. Проще всего это сделать так:</p>

   <pre><hs>_T = term '(' >> _E >> term ')' >> epsilon <|> _N</hs></pre>

      <p> Добавление пустого элемента ничего не изменяет в цепочке. А оператор <code>>></code> вернёт тип своего второго операнда: <code>()</code>. Для анализаторов это очень частый случай, значит можно ввести для этого специальный комбинатор. Назовём его <code>?></code>:
 <pre><hs>(?>) :: Parser i a -> Parser i b -> Parser i ()
 p1 ?> p2 = p1 >> epsilon >> p2 >> epsilon</hs></pre>
и перепишем код для анализаторов арифметических выражений:
   <pre><hs>_E = _T ?> term '+' ?> _E <|> _T
_T = term '(' ?> _E ?> term ')' <|> _N
_N = digit ?> (_N <|> epsilon)</hs></pre>
</p>
      Теперь всё компилируется и можно проверять работу анализатора:</p>
    <pre><hs>test_E = runTestsFor _E "E"
  [ ("12",            Ok () "" )
  , ("(1+2)+3",       Ok () "" )
  , ("1+(2+3)",       Ok () "" )
  , ("1+2+3",         Ok () "" )
  , ("((123+4))",     Ok () "" )
  , ("(13+4)+6345",   Ok () "" )
  , ("(13+4)+(6+32)", Ok () "" ) ]</hs></pre>

    <pre><ghci><l></l> testsG1</ghci></pre>

    <task> Напишите анализатор <code>maybe p</code>, позволяющий выразить мысль, что элемент <code>p</code> может встретиться, а может и не встретиться.</task>
    
    <task> Напишите анализатор <code>bracket</code>, распознающий правильные скобочные выражения с круглыми и квадратными скобками. </task>
    
    <task> Определите анализатор строк, представляющих простой e-mail адрес.</task>


      
      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

