<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <p>Начиная  сэтого занятия мы будем последовательно создавать систему для комбинаторного синтаксического разбора (парсинга) и трансляции произвольных последовательностей символов. Результатом этой работы станет легко расширяемый и очень гибкий инструментарий, подобный промышленным комбинаторным парсерам <code>Parsec</code>.</p>

      <p>Определения для этих занятий предлагаем записывать в модуль <code>Parsing.hs</code>.</p>
      
      <h2>Транслятор и результат трансляции</h2>

      <p>Транслятор арифметических выражений, который мы написали на прошлом занятии, "обучен" только одной грамматике, которая вшита в него в неявном виде. Его непросто расширить для того, чтобы разбирать что-то ещё кроме арифметических выражений.</p>
      <p>Универсальный транслятор будет базироваться на идее монады <code>State</code>, но дополнит её идеями из альтернативных ф можно представить как функцию, которая преобразует входную последовательность символов (строку, или поток лексем) в некий результат. Результатом может быть любое значение: логическое, если нас интересует только соответствие текста заданной грамматике, последовательность выходных значений, синтаксическое дерево, или даже просто число. То есть, тип транслятора, в самом общем случае, может быть каким-то таким:</p>

      <pre><hs>data Parser i a = Parser (i -> a)</hs></pre>
      
      <p>где <code>i</code>  тип элементов входного потока, а <code>a</code>&nbsp;— тип результата. Например, лексический анализатор, читающий программу в виде строки, и возвращающий список лексем может иметь тип <code>Parser String [Token]</code>.</p>
      
      <p>Для того, чтобы нам было легче применять спрятанную в тип <code>Parser</code> функцию-преобразователь, дадим ей имя:</p>

      <pre><hs>data Parser i a = Parser { run :: i -> a }</hs></pre>
      
      <p>Определим какой-нибудь самый простой транслятор. Очень простой. </p>

      <pre><hs>next = Parser head</hs></pre>

     
      <p>  Он просто возвращает первый элемент разбираемой последовательности, каким бы он ни был:</p>

      <pre><ghci><l></l> run next "abab"
<o>'a'</o>
<l></l> run next "bab"
<o>'b'</o></ghci></pre>

      <p> Транслятор работает, но он практически бесполезен, ведь мы потеряли информацию о разбираемой строке и не сможем продолжить разбор. Это приводит к мысли, что возвращаемый результат должен каким-то образом содержать в себе разбираемую строку. Объединим их в типе <code>Result</code>, на который можно посмотреть и сравнить с чем-нибудь:</p>

      <pre><hs>data Parser i a = Parser { run :: i -> Result i a}

data Result i a = Result i a
  deriving (Show, Eq)
	  
next = Parser $ \(x:xs) -> Result xs x</hs></pre>

      <pre><ghci><l></l> run next "abab"
<o>Result "bab" 'a'</o></ghci></pre>

      <p> Теперь работа транслятора стала более осмысленной, он вернул первый элемент и сократил разбираемую строку.</p>
    
      <p>А что дальше? Как нам снова применить функцию <code>next</code> к полученному результату?</p>

      <h2>Последовательное выполнение трансляторов</h2>

      <p>Притворимся, что мы ничего не знаем о функторах и монадах и придумаем их ещё раз, чтобы лучше понять, для чего они нужны и как устроены. Чтобы притвориться по-настоящему, скроем определения для монадических операторов, загружаемых стандартной библиотекой:
            <pre><hs>import Prelude hiding ((>>),(>>=),return, pure)</hs></pre>
      </p>
      
      <p>Определим комбинатор <code>>></code>, "соединяющий" трансляторы в цепочку: </p>

      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Result r' _ -> run t2 r'  </hs></pre>

      <p>Форма <code>case</code> потребовалась нам для того, чтобы "разобрать" результат работы транслятора <code>t1</code> и добыть остаток строки. Можно было воспользоваться формой <code>let</code> или <code>where</code>, но, во-первых, она читается более естественно: от <code>t1</code> к <code>t2</code>, а во-вторых, скоро мы добавим другие альтернативы.</p>
    
      <p>  Комбинатор <code>>></code> возвращает новый транслятор, так что его тоже можно применить к разбираемой строке с помощью функции <code>run</code>. Попробуем его использовать:</p>     
      <pre><ghci><l></l> run (next >> next) "abab"
<o>Result "ab" 'b'</o>
<l></l> run (next >> next >> next) "abab"
<o>Result "b" 'a'</o></ghci></pre>
      
      <p>Переходя ко второму транслятору и далее мы потеряли информацию о первом встреченном символе, но пока она и не нужна: транслятор <code>next</code> её всё равно не использует. И мы тоже пока об этом думать не будем.</p>

      <h2>Право на ошибку</h2>

      <p> Пора научится задавать для разбираемой последовательности какие-либо правила. Например, можно потребовать, чтобы первым символом был символ <code>'a'</code>, и если это так, продолжить разбор. А если не так? В этом случае надо прекратить разбор выражения и как-то показать, что трансляция завершилась неудачно.</p>
    
      <p> Расширим тип для результата трансляции, разделив его на успешную трансляцию и неудачную:</p>

      <pre><hs>data Result i a = Ok a i | Fail i
  deriving (Show, Eq)</hs></pre>

      <p> В случае неудачи, тип содержит неразобранную часть строки. На всякий случай.</p>
 
      <p>Раз мы изменили описание типа <code>Result</code>, нужно поменять и определение комбинатора <code>>></code>, чтобы он учитывал возможные исходы разбора и в случае неудачи, постигшей первый транслятор, не пытался вызывать следующий:</p>
      
      <pre><hs>p1 >> p2 = Parser $ \r -> case run p1 r of
  Ok _ r' -> run p2 r'
  Fail r' -> Fail r'</hs></pre>

      <p> Кроме того, транслятор <code>next</code> может стать несколько "умнее"&nbsp;— если строка пуста, никакого следующего символа в ней нет, а это означает неудачу в разборе:</p>

      <pre><hs>next = Parser $ \r -> case r of
  [] -> Fail r
  x:xs -> Ok x xs</hs></pre>
          
      <p>Напишем теперь транслятор, который будет требовать, чтобы анализируемая строка начиналась с символа, удовлетворяющему указанному предикату:</p>

      <pre><hs>check p = Parser $ \r -> case r of
  x:xs | p x -> Ok () (x:xs)
  _          -> Fail r</hs></pre>

      <p>В случае успеха, этот транслятор возвращает пустой символ <code>()</code>. Такие трансляторы мы будем называть анализаторами. Посмотрим, как он работает:</p>

      <pre><ghci><l></l> run (check (=='a')) "abab"
<o>Ok () "abab"</o>
<l></l> run (check (=='b')) "abab"
<o>Fail "abab"</o>
<l></l> run (check (/='a')) "123"
<o>Ok () "123"</o>
<l></l>  run (check (/='a')) "abab"
<o>Fail "abab"</o></ghci></pre>

      <p>Теперь можно написать транслятор для конкретного символа:</p>
      <pre><hs>term c = check (== c) >> next</hs></pre>	

<hr/>
      
      <p> В дальнейшей работе нам поможет тестирование. Напишем простую функцию-тестировщик.</p>

	<pre><hs>runTests name ts = when (fails /= []) $
                   print name *> putStr fails
  where
    fails = mconcat $ zipWith test [1..] ts
    test i (p, inp, outp) = when (res /= outp) msg
      where
        res = run p inp 
        msg = unlines $ [ "Fail in test: " <> show i
                        , "  expected: " <> show outp
                        , "  got:      " <> show res ]</hs></pre>

      <p>Здесь нам понадобилась функция <code>when</code> (Занятие 5). А вот пример набора юнит-тестов:</p>
    
      <pre><hs>tests = do
  runTests "term"
    [ (term 'a',             "abab", Ok 'a' "bab")
    , (term 'a',             "bbab", Fail "bbab")
    , (term 'a' >> term 'b', "abab", Ok 'b' "ab")
    , (term 'b' >> term 'b', "abab", Fail "abab") ]

  runTests "next"
    [ (next,         "abab", Ok 'a' "bab")
    , (next >> next, "abab", Ok 'b' "ab")
    , (next,         "",     Fail "") ]</hs></pre>
      
      <p> Запускаем тесты...</p>
      <pre><ghci><l></l> tests</ghci></pre>
      <p> и видим, что ничего не выводится. Значит, у нас всё хорошо. Испортите какой-нибудь из тестов и посмотрите, что будет.</p>
      </task>

      <p>Теперь можно смело двигаться дальше!</p>

       <task> С помощью анализатора <code>check</code> определите транслятор <code>digit</code>, ожидающий вначале строки цифру. Для него должны выполняться, например, такие тесты:
	 <pre><hs> runTests "digit"
   [ (digit,          "23x", Ok '2' "3x")
   , (digit,          "abc", Fail "abc")
   , (digit >> digit, "23x", Ok '3' "x") ]</hs></pre>
      </task>

      <task>Напишите анализатор <code>end</code>, ожидающий окончания строки. А чтобы не было скучно, добавьте универсальный комбинатор <code>neg</code>, который возвращал бы отрицание указанного транслятора <code>p</code>: "что угодно, только не <code>p</code>".
	<p> Добавим в список тестов такие проверки:</p>

	<pre><hs> runTests "negation"
   [ (neg end, "abc", Ok () "abc")
   , (term 'a' >> end, "a", Ok () "")
   , (neg digit, "abc", Ok () "abc")
   , (neg digit, "2bc", Fail "2bc") ]</hs></pre>

      </task> 

      <h2>Альтернативное выполнение трансляторов</h2>

      <p> В формальных грамматиках есть цепочки элементов грамматики и альтернативы. Цепочки мы строить умеем с помощью комбинатора <code>>></code>. Приступим к альтернативам. Если входная строчка не соответствует одному транслятору, то может быть она подойдёт другому?</p>

      <pre><hs> p1 <|> p2 = Parser $ \r -> case run p1 r of
  Fail _ -> run p2 r
  Ok x r' -> Ok x r'</hs></pre>

      <p> Теперь у нас появился выбор!!</p>
      <pre><ghci><l></l> run (term 'a' <|> term 'b') "abab"
<o>Ok 'a' "bab"</o>
<l></l> run (term 'a' <|> term 'b') "bbab"
<o>Ok 'b' "bab"</o>
<l></l> run (term 'a' <|> term 'b') "vbbab"
<o>Fail "vbbab"</o>  </ghci></pre>

      <p> Наличие свободного выбора и умение им пользоваться&nbsp;— это поистине великая вещь! Теперь мы можем определить транслятор для любой контекстно-свободной грамматики, ведь они описываются правилами такого рода:</p>
    <eqn>
A \rightarrow \alpha ~|~ \beta ~|~ \gamma ~|~ ...
    </eqn>
      <p>где <eq>\alpha, \beta, \gamma...</eq>&nbsp;— цепочки элементов грамматики: терминалов и нетерминалов. Цепочки мы создавать умеем и альтернативы определять можем, а сами правила соответствуют определениям функций. То есть, определяя функцию, мы определяем нетерминальный символ, и задание анализатора для КС-грамматики&nbsp;— это последовательность определений функций-нетерминалов через комбинации цепочек и альтернатив.</p>

    <p> Сделаем маленькое дополнение. В стандартной математической записи приоритет у операции последовательности в цепочке выше, чем у оператора альтернативы. В языке Haskell тоже можно определять приоритет инфиксных операторов. Сделаем приоритет операции <code>>></code> выше чем у операции <code><|></code>.</p>
    <pre><hs>infixl 0 <|>
infixl 1 >></hs></pre>

      <p>Заодно, мы объявили, что эти операции левоассоциативны. Это значит, что <pre>  a >> b >> c = (a >> b) >> c
a <|> b <|> c = (a <|> b) <|> c</pre></p>

      <p>Построенная нами система трансляции называется <em>"трансляцией методом рекурсивного спуска"</em>. Она начинает разбор с самого общего нетерминала и далее, вызывая функции-нетерминалы, которые используются в правых частях определений, спускается вниз по синтаксическому дереву.</p>

      <p> У этого метода есть серьёзное ограничение на допустимые грамматики&nbsp;— они не должны быть <em>лево-рекурсивными</em>.</p>

      <details><summary>Подробнее о L-грамматиках</summary>

	<p>Лево-рекурсивной (или L-грамматикой) называется грамматика, которая содержит правила вида:</p>

	<eqns>A \rightarrow A \alpha ~|~ \alpha'</eqns>

	<p> Метод рекурсивного спуска, встретив левую рекурсию, "проваливается" в бесконечный цикл. Это существенное ограничение, но любое лево-рекурсивное правило можно преобразовать в эквивалентное не лево-рекурсивное:</p>

	<eqns>A \rightarrow \alpha' A'\\
	  A' \rightarrow  \alpha A' ~|~ \varepsilon
	</eqns>

<p>Например, грамматика для левоассоциативного вычитания лево-рекурсивна (что естественно):
	<eqns>E \rightarrow E - T | T</eqns>
	но её можно преобразовать, исключив левую рекурсию:
	<eqns>E \rightarrow T E'\\
	  E' \rightarrow  - T E' ~|~ \varepsilon
	</eqns>

	<p>Это можно сделать автоматически, но обычно об этом заботится тот, кто пишет грамматику для конкретного анализатора.</p>

      </details>

      <p>Давайте же определим анализатор для какой-нибудь простой нерегулярной грамматики! Например, для такой, которая порождает цепочки вида <eq>(ab)^nba^n</eq>:</p>

    <eqns>
      A \rightarrow \text{'a'}~\text{'b'}~A~\text{'a'} ~|~ \text{'b'} 
    </eqns>
    <pre><hs>_A = term 'a' >> term 'b' >> _A >> term 'a' 
     <|> term 'b'</hs></pre>

    <pre><hs>runTestsFor p name tst = runTests name tst'
  where tst' = map (\(i,o) -> (p,i,o)) tst

test_A = runTestsFor _A "A"
    [ ("abba", Ok 'a' "")
    , ("ababbaa", Ok 'a' "")
    , ("abababbaaa", Ok 'a' "")
    , ("aba", Fail "aba")
    , ("ababa", Fail "ababa")] </hs></pre>

    
    <pre><ghci><l></l> test_A</ghci></pre>

    
    <p>Что же, похоже анализатор работает и его определение в программе замечательно соответствует описанию грамматики.</p>

    
    <p>Как насчёт более сложной грамматики для арифметических выражений с целыми числами, правоассоциативной операцией сложения и скобками?</p>

    <eqns>
      E \rightarrow T ~\text{'+'}~ E ~|~ T\\
      T  \rightarrow \text{'('}~E~\text{')'} ~|~ N\\
      N \rightarrow d ~(N ~|~ \varepsilon)
    </eqns>

    <p>    Первым делом, возникает потребность в пустом символе <eq>\varepsilon</eq>. Определим его так:</p>

    <pre><hs>epsilon = Parser $ Ok ()</hs></pre>

    <p>Теперь можно определять грамматику:</p>

   <pre><hs>_E = _T >> term '+' >> _E <|> _T
_T = term '(' >> _E >> term ')' <|> _N
_N = digit >> (_N <|> epsilon)</hs></pre>

    <p>Выглядит неплохо. Но не компилируется!</p>

    <pre><ghci><err>parserM.hs:83:37-38: Couldn't match type ‘()’ with ‘Char’ …
    Expected type: Parser [Char] Char
      Actual type: Parser [Char] ()
    In the second argument of ‘(<|>)’, namely ‘_N’
    In the expression: term '(' >> _E >> term ')' <|> _N
Compilation failed.</err></ghci></pre>

    <details><summary>Учите английский!!</summary>
    <pre><ghci><err>parserM.hs:83:37-38: Не смог сопоставить тип ‘()’ с ‘Char’ …
     Ожидаемый тип: Parser [Char] Char
    Полученный тип: Parser [Char] ()
    Во втором аргументе ‘(<|>)’, а именно ‘_N’
    В выражении: term '(' >> _E >> term ')' <|> _N
Компиляция не удалась.</err></ghci></pre></details>
    
    <p>Компилятор даёт исчерпывающее объяснение, что именно ему не понравилось. Вот бы все компиляторы так внятно изъяснялись! То есть, транслятор <code>term</code> возвращает тип <code>Char</code>, а анализатор <code>_N</code>&nbsp;— <code>()</code>, и их нельзя комбинировать оператором <code><|></code>. Вот его тип:</p>

    <pre><ghci><l></l> :t (<|>)
<o>(<|>) :: Parser i a -> Parser i a -> Parser i a</o></ghci></pre>

    <p>Значит, надо привести типы комбинируемых выражений к одному. Проще всего это сделать так:</p>

   <pre><hs>_T = term '(' >> _E >> term ')' >> epsilon <|> _N</hs></pre>

      <p> Добавление пустого элемента ничего не изменяет в цепочке. А оператор <code>>></code> вернёт тип своего второго операнда: <code>()</code>. Для анализаторов это очень частый случай, значит можно ввести для этого специальный комбинатор. Назовём его <code>?></code>:
 <pre><hs>(?>) :: Parser i a -> Parser i b -> Parser i ()
 p1 ?> p2 = p1 >> epsilon >> p2 >> epsilon</hs></pre>
и перепишем код для анализаторов арифметических выражений:
   <pre><hs>_E = _T ?> term '+' ?> _E <|> _T
_T = term '(' ?> _E ?> term ')' <|> _N
_N = digit ?> (_N <|> epsilon)</hs></pre>
</p>
      Теперь всё компилируется и можно проверять работу анализатора:</p>
    <pre><hs>test_E = runTestsFor _E "E"
  [ ("12",            Ok () "" )
  , ("(1+2)+3",       Ok () "" )
  , ("1+(2+3)",       Ok () "" )
  , ("1+2+3",         Ok () "" )
  , ("((123+4))",     Ok () "" )
  , ("(13+4)+6345",   Ok () "" )
  , ("(13+4)+(6+32)", Ok () "" ) ]</hs></pre>

    <pre><ghci><l></l> testsG1</ghci></pre>

    <task> Напишите анализатор <code>maybe p</code>, позволяющий выразить мысль, что элемент <code>p</code> может встретиться, а может и не встретиться.</task>
    
    <task> Напишите анализатор <code>bracket</code>, распознающий правильные скобочные выражения с круглыми и квадратными скобками. </task>
    
    <task> Определите анализатор строк, представляющих простой e-mail адрес.</task>


      
      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

