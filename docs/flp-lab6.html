<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>
      .col1 {
      width:7em;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>
    
    <h2>Язык для описания изображений</h2>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о моноидах, построим гибкую и расширяемую систему для вывода графики, использующую общедоступный web-интерфейс. Наша система будет представлять собой небольшой <em>встроенный предметно-ориентированный язык</em> (EDSL) для декларативного описания графики. Этот язык будет транслироваться в изображения формата SVG (Scalable Vector Graphics) — это текстовый формат, используемый веб-браузерами и многими векторными графическими редакторами, такими как <lang>Corel Draw</lang>, <lang>Inkscape</lang> и т. п.</p>

      <p>Опишем возможности разрабатываемого языка. С его помощью можно:<ul>
	  <li> описывать элементарные фигуры: ломаные линии, точки, круги и <nobr>т. д.</nobr>;
	  <li> трансформировать эти фигуры: вращать, масштабировать, перемещать;
	  <li> задавать стиль элементов изображения: цвет, заливку, толщину линий и т. п.;
	  <li> и, самое главное, комбинировать изображения: накладывать друг на друга, размещать их, указывая что один объект находится сбоку или сверху от другого и т. д. 
	</ul>
	По существу, мы построим алгебру изображений и научимся её вычислять (интерпретировать), получая реальные изображения в общедоступном графическом формате.</p>

     
      <p>Определим тип <code>Primitive</code> для представления двух (для начала) графических примитивов: точек и ломаных линий. Изображение будет представлено типом <code>Picture</code>, объединяющим множество примитивов:</p>
      <pre><hs>data Pt = Pt Float Float deriving Show
  
data Primitive = Point Pt
               | Line [Pt] deriving Show

data Picture = Picture [Primitive] deriving Show

<d>contents :: Picture -> [Primitive]</d>
contents (Picture c) = c </hs></pre>

      <p>Сразу продумаем как можно комбинировать примитивы и изображения. Самый непротиворечивый способ — накладывать их друг на друга, то есть, изображать на одном холсте.</p>
      <div class='equation' style='width:70%'>
	<table>
	  <tr>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<circle cx='44' cy='34' r='30'  fill='red' stroke='black'/>
	    </svg></td>
	    <td><code>&lt;&gt;</code></td>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<polyline points=' 4,34 4,4 34,4 34,34 4,34' fill='blue' stroke='black'/>
	    </svg></td>
	    <td>=</td>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<circle cx='44' cy='34' r='30' fill='red' stroke='black'/>
		<polyline points=' 4,34 4,4 34,4 34,34 4,34' fill='blue' stroke='black'/>
	    </svg></td>
	  </tr>
      </table></div>

	
      <p>
	Более того, изображения образуют моноид с операцией наложения (убедитесь мысленно, что наложение ассоциативно). Определим экземпляр классов  <code>Semigroup</code> и <code>Monoid</code> для типа <code>Picture</code>:</p>
      <pre><hs>instance Semigroup Picture where
  Picture p1 <> Picture p2 = Picture $ p1 <> p2

instance Monoid Picture where
  mempty = Picture mempty
</hs></pre>

      <task>Напишите функции-конструкторы для элементарных фигур:
	<pre><hs>point :: (Float, Float) -> Picture
line :: [(Float, Float)] -> Picture
rectangle :: (Float, Float) -> Float -> Float -> Picture
square :: (Float, Float) -> Float -> Picture
triangle :: (Float, Float) -> Float -> Float -> Picture</hs></pre>
	У всех этих функций первый аргумент — это координата нижнего левого угла фигуры, другие агрументы задают ширину и высоту фигуры.
      </task>

      <task>Опишите с помощью имеющихся примитивов простенький рисунок, например, квадратный домик с треугольной крышей.</task>
      <details><summary>Схема решения</summary>
	<pre><hs>house = walls <> window <> roof
  where walls = ...
        roof = ...
        window = ...</hs></pre> </details>
      

      <h2>Представление примитивов в формате SVG</h2>
      
      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle cx='x' cy='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <p>SVG — это текстовый формат.  Для того, чтобы упростить его генерацию воспользуемся функцией <code>printf</code> из библиотеки <code>Text.Printf</code> для форматирования строк по шаблону. Вот примеры её работы:
	<pre><ghci><l></l> printf "%s said: '%s'" "John" "Hello!" :: String
<o>"John said: 'Hello!'" </o>
<l></l> printf "x=%f, y=%f" 4.0 5.0 :: String
<o>"x=4.0, y=5.0"</o></ghci></pre>
      </p>

      <p>В формате SVG можно представлять отдельные координаты, примитивы и целые изображения, то есть, объекты различных типов. Для того, чтобы делать это единообразно, определим собственный класс типов для всего того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
  toSVG :: a -> String</hs></pre></p>

      <p>Его можно воспринимать, как интерфейс, предоставляющий для всех экземпляров этого класса функцию <code>toSVG</code>. Каждый тип-экземпляр этого класса будет реализовывать его по-своему. Вот, например, как это можно сделать для типа <code>Pt</code>:
	<pre><hs>instance SVG Pt where
  toSVG (Pt x y) = printf "%f,%f " x y</hs></pre>
      </p>

      <p>Работая с классами типов можно пойти на некоторые удобные хитрости. Например, если мы знаем как транслировать в SVG какой-то объект <nobr>типа <code>a</code>,</nobr> то мы можем транслировать и список таких объектов, задав универсальный экземпляр для списка:
      <pre><hs>instance SVG a => SVG [a] where
  toSVG = foldMap toSVG</hs></pre>
      В этом определении мы используем то обстоятельство, что элементы SVG (строки) образуют моноид. Теперь можно единообразно транслировать как отдельные координаты, так и их списки:
      <pre><ghci><l></l> toSVG (Pt 1 2)
<o>"1.0,2.0 "</o>
<l></l> toSVG [Pt 1 2, Pt 3 4, Pt 2 6]
<o>"1.0,2.0 3.0,4.0 2.0,6.0 "</o></ghci></pre></p>

      <task> Определите экземпляр класса <code>SVG</code> для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG p = case p of
    Point pt -> _
    Line pts -> _</hs></pre>
      </task>
      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='blue'&gt;...&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения,  параметры <tt>fill</tt> и <tt>stroke</tt> задают графические атрибуты, используемые по умолчанию.</p>

      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code>, задав фиксированные размеры изображения, скажем, 400×300.</task>

      <task>Запишите SVG-выражение, описывающее домик в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в веб-браузере. Создайте вспомогательную функцию <code>writeSVG</code> для удобного экспорта изображений в файл. <pre><hs>writeSVG :: String -> Picture -> IO ()</hs></pre></task>

      <task>Напишите конструктор <pre><hs>polygon :: (Float, Float) -> Int -> Float -> Picture</hs></pre> для правильных многоугольников заданного размера (размер задаётся радиусом описанной окружности). Первый аргумент определяет центр пногоугольника.</task>
      <task>Создайте изображение, показанное на рисунке:
	<p align='center'><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>

      <h2>Определение размеров изображения</h2>

      <p>Правильнее было бы не фиксировать размеры поля изображения в SVG-описании, а вычислять его, находя минимальные и максимальные значения координат примитивов. Эта информация будет нужна нам и для размещения изображений друг относительно друга.</p>

      <p>При объединении изображений объединяются и их обрамляющие рамки. Это означает, что они могут образовывать моноид и этим стоит воспользоваться. Создадим синоним типа для обрамляющей рамки:
<pre><hs>type Box = ( (Min Float, Min Float)
           , (Max Float, Max Float) )</hs></pre>
      В этом типе первая пара задаёт левый нижний угол изображения, а вторая – правый верхний. Для того, чтобы использовать полугруппы <code>Min</code> и <code>Max</code>, экпортируем их (и только их) из библиотеки <code>Data.Semigroup</code>. <pre><hs>import Data.Semigroup (Min(..), Max(..))</hs></pre> Для того, чтобы тип <code>Box</code> стал моноидом, определим минимальную и максимальную границы значений координат. </p>
      <pre><hs>instance Bounded Float where
  minBound = -1/0
  maxBound = 1/0</hs></pre>

      <p>Размеры изображения складываются из размеров примитивов, его составляющих. Значит, имеет смысл определить класс для всех типов, имеющих размер. Создадим такой класс, и определим пару универсально полезных функций, имеющих смысл для всех экземпляров класса:
	<pre><hs>class Boxed a where
  {-# MINIMAL box #-}
  box :: a -> Box
	    
  width :: a -> Float
  width p = x2 - x1
    where ((Min x1,_),(Max x2,_)) = box p

  height :: a -> Float
  height p = y2 - y1
    where ((_,Min y1),(_,Max y2)) = box p
	    
instance Boxed a => Boxed [a] where
  box = foldMap box</hs></pre></p>

      <p>Так, например определяется экземпляр <code>Boxed</code> для точки:
	<pre><hs>instance Boxed Pt where
  box (Pt x y)= ((Min x, Min y), (Max x, Max y))
  width _ = 0
  height _ = 0 </hs></pre> </p>

      <p>Обрамляющую рамку изображения можно вычислить по его примитивам, но делать это всякий раз, как она потребуется не эффективно. Вместо этого, мы включим рамку в определение типа <code>Picture</code>:
	<pre><hs>data Picture = Picture (Box, [Primitive]) deriving Show

<d>contents :: Picture -> Primitive</d>
contents (Picture (_, c)) = c
	    
instance Boxed Picture where
  box (Picture (b, _)) = b</hs></pre></p>

      <p>Поскольку пара моноидов тоже образует моноид, мы таким образом получим моноидальные свойства рамок и картинок "автоматически", ничего не изменяя в определении экземпляра <code>Monoid&nbsp;Picture</code>.</p>

      <task>Определите экземпляр <code>Boxed Primitive</code>. Используйте моноидальные свойства типа <code>Box</code> при вычислении рамки для примитива <code>Line</code>.</task>
      
      <task>Переопределите конструкторы <code>point, line, square, ...</code>
	Для этого имеет смысл определить вспомогательную функцию <code>primitive</code>, которая выполняла бы необходимые вычисления обрамляющей рамки для формируемого изображения:
	<pre><hs><d>primitive :: Primitive -> Picture</d>
primitive p = Picture (box p, [p])</hs></pre>
      </task>

      <task>Наконец, используйте информацию об обрамляющей рамке изображения для вычисления размеров, указываемых в заголовке SVG-файла.</task>

      <task>Определите внутри класса <code>Boxed</code> универсальную функцию <code>corner</code>, возвращающую углы обрамляющей рамки изображения, или примитива
	<pre><hs>corner :: a -> (((Float,Float), (Float,Float))
               ,((Float,Float), (Float,Float)))</hs></pre> и четыре селектора <code>left, right, upper, lower</code>
      так, чтобы можно было бы получить, например, правый нижний угол изображения с помощью выражения:
      <pre><hs> right . lower . corner :: Picture -> (Float, Float)</hs></pre></task>
      
      <h2>Преобразования изображений</h2>

      <p>
	Давайте научимся двигать изображения. Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги, повороты и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг (или их композицию), а вектор <eq>\vec v</eq> — параллельный перенос. Такое преобразование можно представить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преобразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т. п.) используется именно такая реализация афинных преобразований. 
      </p>

      <p>Приведём три основные вида преобразований:
	<ul>
	  <li> масштабирование осей <eq>x</eq> и <eq>y</eq> с множителями <eq>a</eq> и <eq>b</eq>:
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос вдоль вектора <eq>(x,y)</eq>:
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на угол <eq>\alpha</eq>:
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> отражение относительно линии, проходящей через начало координат под углом <eq>\alpha</eq>:
	    <eqn>\begin{pmatrix}
	      \cos 2\alpha & \sin 2\alpha & 0\\
	      \sin 2\alpha & -\cos 2\alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </p>


      <task>Напишите базовые преобразователи, используя тип для матриц <code>M a</code>, созданный на прошлом занятии:
	<pre><hs>rotateM :: Float -> M Float
tranlangateM :: Float -> Float -> M Float
scaleM :: Float -> Float -> M Float
reflectM :: Double -> M Float</hs></pre></task>
      
      <p>Применять афинные преобразования можно к разным объектам: точкам, примитивам и целым изображениям. Это наводит на мысль о классе типов <code>Affine</code>, который абстрагирует это свойство и определяет оператор афинных преобразований <code>affine</code>:
	<pre><hs>class Affine p where
  affine :: M Float -> p -> p </hs></pre></p>

      <task>Напишите экземпляры этого класса для типов <code>Pt</code>, <code>Primitive</code> и <code>Picture</code>. Используйте для этого обобщённый экземпляр для списка:
	<pre><hs>instance Affine a => Affine [a] where
  affine t ps = _</hs></pre></p>
      </task>

   
      <task>Основываясь на матрицах базовых преобразований, напишите следующие преобразователи афинных типов:
	<pre><hs>-- масштабирует координату x
scaleX :: Affine a => Float -> a -> a 
-- масштабирует координату y
scaleY :: Affine a => Float -> a -> a </def>
-- одинаково масштабирует обе координаты
scale :: Affine a => Float -> a -> a </def>
-- приводит изображение к указанным размерам 
rescaleTo :: (Boxed a, Affine a) => Float -> Float -> a -> a</def>
-- параллельный перенос изображения
shift :: Affine a => Float -> Float -> a -> a</def>
-- поворот на угол, задаваемый в градусах вокруг центра координат
rotate :: Affine a => Float -> a -> a</def>
-- поворот вокруг указанной точки
rotateAt :: Affine a => (Float, Float) -> Float -> a -> a</def>
-- отражение относительно линии,
-- проходящей через начало координат под указанным углом
reflect :: Affine a => Float -> a -> a</def>
-- отражение относительно линии,
-- проходящей через указанную точку под указанным углом
reflectAt :: Affine a => (Float, Float) -> Float -> a -> a</def></hs></pre>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><hs> let s = square (0,0) 50
 s &lt;&gt; rotate 45 s
 s &lt;&gt; shift 10 30 s
 s &lt;&gt; (scaleX 2 . scaleY 3) s
 s &lt;&gt; rotate 60 s
 s &lt;&gt; (shift 30 0 . rotate 60) s
 s &lt;&gt; (rotate 60 . shift 30 0) s
 s &lt;&gt; reflect 30 s
 s &lt;&gt; reflectAt (50,0) 30 s      </hs></pre></task>      

      <task>Добавьте к типу <code>Primitive</code> конструктор <code>Circle Pt Float</code> для окружности. Окружность, которую можно транcформировать произвольной матрицей (увеличивать, превращать в эллипс и т. д.) можно построить с помощью функции <code>polygon</code> с большим числом углов.</task>

      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз, традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат.  Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат. </task>
      
      <task>Набор преобразователей позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига даёт нам возможность не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании квадрата и прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, задающий абсолютные координаты левого нижнего угла изображения. С его помощью, например, можно было бы построить квадрат с вписанной в него окружностью и расположить его в координатах <eq>(100, 100)</eq> так:
	<pre><hs>(circle 25 &lt;&gt; square 50) `at` (100, 100)</hs></pre></task>
      
      <task>Объясните, каким образом вычисляются следующее выражение:
	<pre><hs>scale 2 <> scale 3 $ polygon 5 50
rotate 30 &lt;&gt; (`at` (40, 40)) $ square 10</hs></pre>
      </task>

      <task>Объясните, что делает функция <code>mrepeat</code>:
      <pre><hs>mrepeat n f = mconcat . take n . iterate f</hs></pre>
      </task>
      
      <task>С помощью функции <code>mrepeat</code> постройте картинку, задаваемую выражением:	
      	<pre><hs>mrepeat 48 (rotate 7.5) $ square 50 `at` (25, 25)</hs></pre>
      </task>

      <h2>Новые способы комбинирования изображений</h2>
      
      <task>Имея в своём распоряжении композицию изображений и операцию сдвига несложно определить ещё два полезных комбинатора, располагающих изображения рядом вертикально и горизонтально: <code>above</code> и <code>beside</code>. Напишите их определение так, чтобы при результаты были такими, как показано на рисунке:
	<pre><hs>circle 30 `beside` square 40</hs></pre>
	<p align='center'><svg width='108.0' height='68.0' fill='none' stroke='blue'><circle cx='34.0' cy='34.0' r='30.0'/><polyline points=' 64.0,64.0 104.0,64.0 104.0,24.0 64.0,24.0 64.0,64.0'/></svg></p>
	<pre><hs>circle 30 `above` square 40</hs></pre>
	<p align='center'><svg width='68.0' height='108.0' fill='none' stroke='blue'><circle cx='34.0' cy='34.0' r='30.0'/><polyline points=' 4.0,104.0 44.0,104.0 44.0,64.0 4.0,64.0 4.0,104.0'/></svg></p>
      </task>

      <task>Напишите две функции <code>row</code> и <code>column</code>, которые располагали бы список изображений в виде ряда или колонки. Например так:
	<pre><hs>row $ circle <$> [4,8,16,32,16,8,4]</hs></pre>
	<p align='center'><svg width='184.0' height='72.0' fill='none' stroke='blue'><circle cx='8.0' cy='64.0' r='4.0'/><circle cx='20.0' cy='60.0' r='8.0'/><circle cx='44.0' cy='52.0' r='16.0'/><circle cx='92.0' cy='36.0' r='32.0'/><circle cx='140.0' cy='52.0' r='16.0'/><circle cx='164.0' cy='60.0' r='8.0'/><circle cx='176.0' cy='64.0' r='4.0'/></svg></p>
      </task>

      <task>Напишите функцию <code>chart :: Picture -> [Int] -> Picture</code>, которая строила бы диаграммы для списков целочисленных значений, как показано на примере:
	<pre><hs>chart (square 10) [1,2,1,2,3,2,1,4,2,3,6,5,4,3,4,3,1,2,1]</hs></pre>
	<p align='center'>
<svg width='198.0' height='68.0' fill='none' stroke='blue'><polyline points=' 4,64 14,64 14,54 4,54 4,64'/><polyline points=' 14,54 24,54 24,44 14,44 14,54'/><polyline points=' 14,64 24,64 24,54 14,54 14,64'/><polyline points=' 24,64 34,64 34,54 24,54 24,64'/><polyline points=' 34,54 44,54 44,44 34,44 34,54'/><polyline points=' 34,64 44,64 44,54 34,54 34,64'/><polyline points=' 44,44 54,44 54,34 44,34 44,44'/><polyline points=' 44,54 54,54 54,44 44,44 44,54'/><polyline points=' 44,64 54,64 54,54 44,54 44,64'/><polyline points=' 54,54 64,54 64,44 54,44 54,54'/><polyline points=' 54,64 64,64 64,54 54,54 54,64'/><polyline points=' 64,64 74,64 74,54 64,54 64,64'/><polyline points=' 74,34 84,34 84,24 74,24 74,34'/><polyline points=' 74,44 84,44 84,34 74,34 74,44'/><polyline points=' 74,54 84,54 84,44 74,44 74,54'/><polyline points=' 74,64 84,64 84,54 74,54 74,64'/><polyline points=' 84,54 94,54 94,44 84,44 84,54'/><polyline points=' 84,64 94,64 94,54 84,54 84,64'/><polyline points=' 94,44 104,44 104,34 94,34 94,44'/><polyline points=' 94,54 104,54 104,44 94,44 94,54'/><polyline points=' 94,64 104,64 104,54 94,54 94,64'/><polyline points=' 104,14 114,14 114,4 104,4 104,14'/><polyline points=' 104,24 114,24 114,14 104,14 104,24'/><polyline points=' 104,34 114,34 114,24 104,24 104,34'/><polyline points=' 104,44 114,44 114,34 104,34 104,44'/><polyline points=' 104,54 114,54 114,44 104,44 104,54'/><polyline points=' 104,64 114,64 114,54 104,54 104,64'/><polyline points=' 114,24 124,24 124,14 114,14 114,24'/><polyline points=' 114,34 124,34 124,24 114,24 114,34'/><polyline points=' 114,44 124,44 124,34 114,34 114,44'/><polyline points=' 114,54 124,54 124,44 114,44 114,54'/><polyline points=' 114,64 124,64 124,54 114,54 114,64'/><polyline points=' 124,34 134,34 134,24 124,24 124,34'/><polyline points=' 124,44 134,44 134,34 124,34 124,44'/><polyline points=' 124,54 134,54 134,44 124,44 124,54'/><polyline points=' 124,64 134,64 134,54 124,54 124,64'/><polyline points=' 134,44 144,44 144,34 134,34 134,44'/><polyline points=' 134,54 144,54 144,44 134,44 134,54'/><polyline points=' 134,64 144,64 144,54 134,54 134,64'/><polyline points=' 144,34 154,34 154,24 144,24 144,34'/><polyline points=' 144,44 154,44 154,34 144,34 144,44'/><polyline points=' 144,54 154,54 154,44 144,44 144,54'/><polyline points=' 144,64 154,64 154,54 144,54 144,64'/><polyline points=' 154,44 164,44 164,34 154,34 154,44'/><polyline points=' 154,54 164,54 164,44 154,44 154,54'/><polyline points=' 154,64 164,64 164,54 154,54 154,64'/><polyline points=' 164,64 174,64 174,54 164,54 164,64'/><polyline points=' 174,54 184,54 184,44 174,44 174,54'/><polyline points=' 174,64 184,64 184,54 174,54 174,64'/><polyline points=' 184,64 194,64 194,54 184,54 184,64'/></svg></p>
      </task>

      <task>Напишите функцию <code>barChart :: [Double] -> Picture</code>, которая строила бы столбчатую диаграмму для числовых списков, используя ширину столбца 1:
	<pre><hs>rescaleTo 200 100 $ barChart [1,2,3,2,3,4,5,4,3,2]</hs></pre>
	<p align='center'><svg fill='none' stroke='blue' width='204' height='104' ><polyline points=' 4.0,104.0 24.0,104.0 24.0,84.0 4.0,84.0 4.0,104.0'/><polyline points=' 24.0,104.0 44.0,104.0 44.0,64.0 24.0,64.0 24.0,104.0'/><polyline points=' 44.0,104.0 64.0,104.0 64.0,44.0 44.0,44.0 44.0,104.0'/><polyline points=' 64.0,104.0 84.0,104.0 84.0,64.0 64.0,64.0 64.0,104.0'/><polyline points=' 84.0,104.0 104.0,104.0 104.0,44.0 84.0,44.0 84.0,104.0'/><polyline points=' 104.0,104.0 124.0,104.0 124.0,24.0 104.0,24.0 104.0,104.0'/><polyline points=' 124.0,104.0 144.0,104.0 144.0,4.0 124.0,4.0 124.0,104.0'/><polyline points=' 144.0,104.0 164.0,104.0 164.0,24.0 144.0,24.0 144.0,104.0'/><polyline points=' 164.0,104.0 184.0,104.0 184.0,44.0 164.0,44.0 164.0,104.0'/><polyline points=' 184.0,104.0 204.0,104.0 204.0,64.0 184.0,64.0 184.0,104.0'/></svg></p>
      </task>
     
      <h2>Стилевые атрибуты</h2>

<p>Добавим нашему языку красок! Изменение атрибутов примитивов и изображений можно тоже рассмативать, как преобразование <code>Picture -> Picture</code>. Значит, их можно смешивать с другими преобразованиями такого типа с помощью композиции:
	<pre><hs>(rotate 45 . color "black" . fill "red" $ square 50) <>
(opacity 0.5 . fill "blue" $ circle 30) <>
(color "orange" . lineWidth 5 $ line [(-40,40),(40,-40)])</hs></pre></p>
      <p align='center'><svg width='88.0' height='118.71068' fill='none' stroke='blue'><g  stroke="black" fill="red"><polyline points=' 44,74.71 79.35,39.35 44,4 8.64,39.35 44,74.71'/></g><g  stroke-opacity=0.5 fill-opacity=0.5 fill="blue"><circle cx='44' cy='74.71' r='30'/></g><g  stroke="orange" stroke-width=5.0><polyline points=' 4,34.71 84,114.71'/></g></svg></p>
      
<p> Для стилей имеет смысл определить специальный тип:
  <pre><hs>data Attribute = LineColor String
               | Fill String
               | LineWidth Float
               | Opacity Float deriving (Show, Eq)</hs></pre></p>

      
     <p>В формате SVG для атрибутов принято единообразное обозначение: <tt>attribute='value'</tt>. Перечисленным в типе <code>Attribute</code> конструкторам соответствуют следующие параметры элементов SVG:
	  <table>
	    <tr><td style='width:7em'><code>LineColor</code></td><td><sl>stroke</sl></td></tr>
	    <tr><td style='width:7em'><code>Fill</code></td><td><sl>fill</sl></td></tr>
	    <tr><td style='width:7em'><code>LineWidth</code></td><td><sl>stroke-width</sl></td></tr>
	    <tr><td style='width:7em'><code>Opacity</code></td><td><sl>stroke-opacity</sl> и <sl>fill-opacity</sl></td></tr>
	  </table>
      </p>

<p>Определим экземпляр класса SVG для типа <code>Attribute</code>.
  <pre><hs>instance SVG Attribute where
  toSVG attr = case attr of
    LineColor c -> printf "stroke='%s' " c
    Fill c -> printf "fill='%s' " c
    LineWidth w -> printf "stroke-width='%f' " w
    Opacity o -> printf "fill-opacity='%f' stroke-opacity='%f' " o o</hs></pre></p>
     
     <p> Имеет смысл присваивать стиль не каждому примитиву, а целым группам. Это соотвествует духу формата SVG, в котором существует элемент <code>g</code>, группирующий другие элементы. Группа, для которой установлены атрибуты, декларируется следующим образом:
	  <pre>&lt;g stroke="red" fill="blue"&gt;...&lt;/g&gt;</pre></p>
	
     <task> Добавьте в тип <code>Primitive</code> конструктор для группы примитивов <code>Group&nbsp;[Attribute]&nbsp;[Primitive]</code> и расширьте все определения функций над примитивами.</p>
      </task>

      <task>С помощью вспомогательной функции 
	<pre><hs><d>setAttr :: (t -> Attribute) -> t -> Picture -> Picture</d>
setAttr attr c p = case p of
  Picture (b, [Group a p]) -> Picture (b, [Group (a <> [attr c]) p])
  p -> primitive $ Group [attr c] (contents p)</hs></pre>
	введите преобразователи стиля
	<pre><hs>lineColor :: String -> Picture -> Picture</def> -- цвет линии
fill :: String -> Picture -> Picture</def> -- цвет заливки
color :: String -> Picture -> Picture </def> -- одинаковый цвет линии и заливки
lineWidth :: Float -> Picture -> Picture</def> -- толщина линии
opacity :: Float -> Picture -> Picture</def> -- прозрачность фигуры</hs></pre>
      </task>

      <task> Проверьте корректность работы стилей на примере:
	<pre><hs>opacity 0.6 $ (fill "navy" $ barChart [1,2,4,8,9,3,1]) <>
(fill "orange" $ barChart [12,8,3,2,1,4,8])</hs></pre>
	
      	<p align='center'><svg width='208' height='158' fill='none' stroke='blue'><g  fill="navy" stroke-opacity=0.6 fill-opacity=0.6><polyline points=' 4,154 32.57,154 32.57,141.5 4,141.5 4,154'/><polyline points=' 32.57,154 61.14,154 61.14,129 32.57,129 32.57,154'/><polyline points=' 61.14,154 89.71,154 89.71,104 61.14,104 61.14,154'/><polyline points=' 89.71,154 118.28,154 118.28,54 89.71,54 89.71,154'/><polyline points=' 118.28,154 146.85,154 146.85,41.5 118.28,41.5 118.28,154'/><polyline points=' 146.85,154 175.42,154 175.42,116.5 146.85,116.5 146.85,154'/><polyline points=' 175.42,154 204,154 204,141.5 175.42,141.5 175.42,154'/></g><g  fill="orange" stroke-opacity=0.6 fill-opacity=0.6><polyline points=' 4,154 32.57,154 32.57,4 4,4 4,154'/><polyline points=' 32.57,154 61.14,154 61.14,54 32.57,54 32.57,154'/><polyline points=' 61.14,154 89.71,154 89.71,116.5 61.14,116.5 61.14,154'/><polyline points=' 89.71,154 118.28,154 118.28,129 89.71,129 89.71,154'/><polyline points=' 118.28,154 146.85,154 146.85,141.5 118.28,141.5 118.28,154'/><polyline points=' 146.85,154 175.42,154 175.42,104 146.85,104 146.85,154'/><polyline points=' 175.42,154 204,154 204,54 175.42,54 175.42,154'/></g></svg></p>
      </task>
     
      <p>Построенный нами встроенный язык построения изображений имеет несколько замечательных свойств:
	<ul>
	  <li> он декларативен, но, в то же время, позволяет производить сколь угодно сложные вычисления для построения изображений;
	  <li> он легко расширяем: можно вводить новые конструкторы примитивов и новые примитивы и их комбинаторы.
	</ul>
      </p>

      <h2>Примеры использования</h2>

      <p>Построение линейчатой диаграммы по таблице данных</p>
      <pre><hs>lineChart = line . trim . zip [0..]
  where trim l = (0,0) : l ++ [(fst (last l),0)]</hs></pre>
      
 <p align='center'><svg width='208.0' height='158.0' fill='none' stroke='blue'><g  fill="goldenrod"><polyline points=' 4,154 4,97.75 44,116.5 84,41.5 124,79 164,4 204,79 204,154'/></g></svg><br/>
   <code>fill "goldenrod" $ lineChart [3,2,6,4,8,4]</code></p>
 
      <p>Так можно раскрасить несколько изображений, чередуя цвета:</p>
	<pre><hs>colorizeWith colors ps = zipWith color (cycle colors) ps</hs></pre>

      <p align='center'><svg width='176.0' height='50.0' fill='none' stroke='none'><g  fill="green"><circle cx='7' cy='43' r='3'/></g><g  fill="gray"><circle cx='16' cy='40' r='6'/></g><g  fill="green"><circle cx='31' cy='37' r='9'/></g><g  fill="gray"><circle cx='52' cy='34' r='12'/></g><g  fill="green"><circle cx='79' cy='31' r='15'/></g><g  fill="gray"><circle cx='112' cy='28' r='18'/></g><g  fill="green"><circle cx='151' cy='25' r='21'/></g></svg></br>
  <code>row . colorizeWith ["green","gray"] $ circle <$> [3,6..20]</code>
      </p>
      
      <p>Пусть нам дана таблица данных:
	<pre><hs>table = [[1,3,5,7,5,7,3,5]
        ,[6,4,2,6,4,7,8,3]
        ,[1,2,3,2,3,4,2,1]] :: [[Float]]
</hs></pre>
	Можно построить несколько диаграмм по ряду таблиц значений несколькими способами:</p>
      
      <pre><hs>manyCharts colors tbl = col charts
  where charts = colorizeWith colors $ lineChart <$> tbl</hs></pre>
	<p align='center'><img src="img/manyCharts.png" alt="" width='40%'/><br/>
	  <code>manyCharts ["red","green","orange"] table</code></p>  

<pre><hs>overlayCharts colors tbl = opacity 0.5 $ mconcat charts
  where charts = colorizeWith colors $ lineChart <$> tbl</hs></pre>
	<p align='center'><img src="img/overlayCharts.png" alt="" width='40%'/><br/>
	  <code>overlayCharts ["red","green","orange"] table</code></p>  
  
<pre><hs>stackCharts colors tbl = row charts
  where
    charts = stack <$> transpose (reverse tbl)
    stack lst = col $ colorizeWith colors $
                rectangle 1 <$> lst </hs></pre>
	<p align='center'><img src="img/stackCharts.png" alt="" width='40%'/><br/>
	  <code>stackCharts ["red","green","orange"] table</code></p>  
      
      <task>Объясните, как вычисляются и строятся следующие изображения:
      <pre><hs>sierp n = rotate (-135) $ mrepeat n tri $ circle 1
  where tri t = t `above` (t `beside` t)</hs></pre>
	<p align='center'><img src="img/triangle.png" alt="" width='40%'/><br/>
	  <code>rescaleTo 200 200 sierp</code></p>  

      <pre><hs>tree = mrepeat 7 (mconcat model) stem
  where
    stem = line [(0,0), (0,1)]
    model = [ shift 0 1 . scale 0.6 . rotate (-30)
            , shift 0 1 . scale 0.7 . rotate 5
            , shift 0 1 . scale 0.5 . rotate 45 ]</hs></pre>
	<p align='center'><img src="img/tree.png" alt="" width='40%'/><br/>
	  <code>scale 200 $ color "darkgreen" tree</code></p>  

      <pre><hs>pentaflake = (!! 5) $ iterate model $ polygon 5 1
  where
    model = foldMap copy [0,72..288]
    copy a = scale (1/(1+x)) . rotate a . shift 0 x
    x = 2*cos(pi/5)</hs></pre>
      
    <p align='center'><img src="img/pentaflake.png" alt="" width='40%'/><br/><code>scale 200 pentaflake</code></p>  
</task>
      
      <task>Напишите функцию <code>plot</code>
	<pre><hs>plot :: (Float -> Float) -> (Float, Float) -> Picture</hs></pre>
	которая строит график произвольной числовой функции в указанных пределах по оси <eq>x</eq>. Пример использования:
	<pre><hs>rescaleTo 400 300 . lineColor "blue" $ plot sinc (-15,15)</hs></pre>

	<p align='center'><svg width='408.0' height='308.0' fill='none' stroke='blue'><g  stroke="black"><polyline points=' 4,250.46 404,250.46'/><polyline points=' 204.00,304 204.00,4'/></g><g  stroke-width=2.0><polyline points=' 4,239.77 6,237.90 8,236.28 10,234.94 12,233.93 14,233.27 16,232.99 18,233.10 20,233.60 22,234.50 24,235.78 26,237.43 28,239.40 30,241.67 32,244.20 34,246.93 36,249.80 38,252.75 40,255.73 42,258.66 44,261.48 46,264.11 48,266.51 50,268.60 52,270.33 54,271.66 56,272.54 58,272.94 60,272.84 62,272.23 64,271.11 66,269.48 68,267.37 70,264.81 72,261.85 74,258.53 76,254.93 77.99,251.11 79.99,247.16 81.99,243.15 83.99,239.17 85.99,235.32 87.99,231.68 89.99,228.34 91.99,225.38 93.99,222.89 95.99,220.95 97.99,219.60 99.99,218.90 101.99,218.91 103.99,219.63 105.99,221.09 107.99,223.29 109.99,226.20 111.99,229.79 113.99,234.02 115.99,238.82 117.99,244.11 119.99,249.80 121.99,255.78 123.99,261.93 125.99,268.14 127.99,274.27 130,280.17 132,285.73 134,290.78 136,295.20 138,298.85 140,301.61 142,303.36 144,303.99 146,303.43 148,301.60 150,298.44 152,293.92 154,288.02 156,280.75 158,272.14 160,262.24 162,251.12 164,238.87 166,225.60 168,211.45 170,196.56 172,181.09 174,165.23 176,149.15 178,133.05 180,117.12 182,101.56 184,86.56 186,72.33 188,59.03 190,46.85 192,35.95 194,26.46 196,18.52 198,12.23 200,7.68 202,4.92 204,4 206,4.92 208,7.67 210,12.23 212,18.52 214,26.46 216,35.94 218,46.85 220,59.03 222,72.32 224,86.56 226,101.55 228,117.11 230,133.04 232,149.14 234,165.22 236,181.09 238,196.55 240,211.44 242,225.59 244,238.86 246,251.11 248,262.23 250,272.14 252,280.75 254,288.02 256,293.92 258,298.44 260,301.60 262,303.43 264,304 266,303.36 268,301.61 270,298.85 272,295.20 274,290.78 276,285.73 278,280.18 280,274.27 282,268.14 284,261.94 286,255.78 288,249.80 290,244.11 292,238.82 294,234.03 296,229.80 298,226.20 300,223.29 302,221.09 304,219.63 306,218.91 308,218.90 310,219.60 312,220.94 314,222.89 316,225.38 318,228.33 320,231.67 322,235.31 324,239.17 326,243.15 328,247.16 330,251.11 332,254.93 334,258.53 336,261.85 338,264.81 340,267.37 342,269.48 344,271.10 346,272.23 348,272.84 350,272.94 352,272.54 354,271.66 356,270.33 358,268.60 360,266.51 362,264.11 364,261.48 366,258.66 368,255.73 370,252.76 372,249.80 374,246.93 376,244.20 378,241.68 380,239.40 382,237.43 384,235.78 386,234.50 388,233.60 390,233.10 392,232.99 394,233.27 396,233.93 398,234.94 400,236.28 402,237.90 404,239.77'/></g></svg></p>
	Удостоверьтесь в том, что графики можно комбинировать, например, так:
	<pre><hs>(color "red" $ plot sinc (-15) 15) <>
  lineWidth 0.5 ((color "blue" $ plot sin (-15) 15) <>
                 (color "green" $ plot (1/) 0.3 15))</hs></pre>      </task>

      <p align='center'><svg width='408.0' height='308.0' fill='none' stroke='blue'><g  stroke-opacity=0.7 fill-opacity=0.7><g  stroke="blue"><g  stroke="black"><polyline points=' 4,191.54 403.99,191.54'/><polyline points=' 203.99,304 203.99,79.09'/></g><g  stroke-width=2.0><polyline points=' 4,264.72 5.99,276.67 7.99,286.71 9.99,294.62 11.99,300.21 13.99,303.36 15.99,304 17.99,302.11 19.99,297.74 21.99,290.98 23.99,281.99 25.99,270.97 27.99,258.17 29.99,243.87 31.99,228.39 33.99,212.09 35.99,195.33 37.99,178.48 39.99,161.92 41.99,146.03 43.99,131.16 45.99,117.65 47.99,105.80 49.99,95.87 51.99,88.09 53.99,82.64 55.99,79.63 57.99,79.13 59.99,81.16 61.99,85.67 63.99,92.55 65.99,101.66 67.99,112.79 69.99,125.68 71.99,140.06 73.99,155.59 75.99,171.93 77.99,188.70 79.99,205.55 81.99,222.07 83.99,237.92 85.99,252.72 87.99,266.15 89.99,277.90 91.99,287.71 93.99,295.36 95.99,300.68 97.99,303.55 99.99,303.91 101.99,301.74 103.99,297.10 105.99,290.08 107.99,280.86 109.99,269.62 111.99,256.64 113.99,242.19 115.99,226.60 117.99,210.23 119.99,193.44 121.99,176.60 123.99,160.10 125.99,144.31 127.99,129.58 129.99,116.24 131.99,104.59 133.99,94.89 135.99,87.36 137.99,82.18 139.99,79.45 141.99,79.23 143.99,81.54 145.99,86.32 147.99,93.46 149.99,102.81 151.99,114.15 153.99,127.22 155.99,141.74 157.99,157.38 159.99,173.79 161.99,190.59 163.99,207.42 165.99,223.89 167.99,239.63 169.99,254.30 171.99,267.55 173.99,279.10 175.99,288.68 177.99,296.08 179.99,301.13 181.99,303.72 183.99,303.79 185.99,301.34 187.99,296.43 189.99,289.16 191.99,279.69 193.99,268.25 195.99,255.09 197.99,240.49 199.99,224.80 201.99,208.36 203.99,191.55 205.99,174.73 207.99,158.29 209.99,142.60 211.99,128.01 213.99,114.84 215.99,103.40 217.99,93.94 219.99,86.66 221.99,81.75 223.99,79.30 225.99,79.37 227.99,81.96 229.99,87.01 231.99,94.40 233.99,103.98 235.99,115.53 237.99,128.78 239.99,143.45 241.99,159.19 243.99,175.66 245.99,192.48 247.99,209.29 249.99,225.70 251.99,241.34 253.99,255.86 255.99,268.93 257.99,280.27 259.99,289.62 261.99,296.76 263.99,301.54 265.99,303.85 267.99,303.64 269.99,300.91 271.99,295.73 273.99,288.20 275.99,278.51 277.99,266.86 279.99,253.52 281.99,238.78 283.99,222.99 285.99,206.49 287.99,189.66 289.99,172.87 291.99,156.49 293.99,140.91 295.99,126.46 297.99,113.47 299.99,102.24 301.99,93.01 303.99,85.99 305.99,81.35 307.99,79.18 309.99,79.53 311.99,82.40 313.99,87.72 315.99,95.37 317.99,105.18 319.99,116.94 321.99,130.36 323.99,145.16 325.99,161.00 327.99,177.53 329.99,194.37 331.99,211.15 333.99,227.49 335.99,243.02 337.99,257.40 339.99,270.29 341.99,281.42 343.99,290.53 345.99,297.42 347.99,301.93 349.99,303.96 351.99,303.46 353.99,300.45 355.99,295.00 357.99,287.22 359.99,277.29 361.99,265.44 363.99,251.93 365.99,237.06 367.99,221.17 369.99,204.62 371.99,187.77 373.99,171.00 375.99,154.70 377.99,139.23 379.99,124.92 381.99,112.12 383.99,101.10 385.99,92.11 387.99,85.35 389.99,80.98 391.99,79.09 393.99,79.73 395.99,82.88 397.99,88.46 399.99,96.37 401.99,106.41 403.99,118.36'/></g></g><g  stroke="green"><g  stroke="black"><polyline points=' 211.99,191.54 404,191.54'/><polyline points=' 203.99,184.04 203.99,4'/></g><g  stroke-width=2.0><polyline points=' 211.99,4 212.95,24.09 213.91,40.29 214.87,53.64 215.83,64.82 216.79,74.33 217.75,82.50 218.71,89.62 219.67,95.86 220.63,101.38 221.59,106.29 222.55,110.70 223.51,114.68 224.47,118.28 225.43,121.56 226.39,124.56 227.35,127.31 228.31,129.85 229.27,132.19 230.23,134.36 231.19,136.38 232.15,138.26 233.11,140.02 234.07,141.66 235.03,143.21 235.99,144.66 236.95,146.02 237.91,147.31 238.87,148.53 239.83,149.68 240.79,150.77 241.75,151.81 242.71,152.79 243.67,153.73 244.63,154.62 245.59,155.48 246.55,156.29 247.51,157.07 248.47,157.81 249.43,158.52 250.39,159.21 251.35,159.86 252.31,160.49 253.27,161.10 254.23,161.68 255.19,162.24 256.15,162.78 257.11,163.30 258.07,163.80 259.03,164.28 259.99,164.75 260.95,165.20 261.91,165.64 262.87,166.06 263.83,166.47 264.79,166.87 265.75,167.25 266.71,167.62 267.67,167.98 268.63,168.33 269.59,168.67 270.55,169.00 271.51,169.32 272.47,169.63 273.43,169.94 274.39,170.23 275.35,170.52 276.31,170.80 277.27,171.07 278.23,171.33 279.19,171.59 280.15,171.84 281.11,172.09 282.07,172.33 283.03,172.56 283.99,172.79 284.95,173.01 285.91,173.23 286.87,173.44 287.83,173.65 288.79,173.85 289.75,174.05 290.71,174.24 291.67,174.43 292.63,174.62 293.59,174.80 294.55,174.98 295.51,175.15 296.47,175.32 297.43,175.49 298.39,175.65 299.35,175.81 300.31,175.97 301.27,176.12 302.23,176.27 303.19,176.42 304.15,176.56 305.11,176.71 306.07,176.85 307.03,176.98 307.99,177.12 308.95,177.25 309.91,177.38 310.87,177.51 311.83,177.63 312.79,177.75 313.75,177.87 314.71,177.99 315.67,178.11 316.63,178.22 317.59,178.34 318.55,178.45 319.51,178.56 320.47,178.66 321.43,178.77 322.39,178.87 323.35,178.97 324.31,179.07 325.27,179.17 326.23,179.27 327.19,179.37 328.15,179.46 329.11,179.55 330.07,179.64 331.03,179.73 331.99,179.82 332.95,179.91 333.91,180.00 334.87,180.08 335.83,180.16 336.79,180.25 337.75,180.33 338.71,180.41 339.67,180.49 340.63,180.56 341.59,180.64 342.55,180.72 343.51,180.79 344.47,180.86 345.43,180.94 346.39,181.01 347.35,181.08 348.31,181.15 349.27,181.22 350.23,181.28 351.19,181.35 352.15,181.42 353.11,181.48 354.07,181.55 355.03,181.61 355.99,181.67 356.95,181.73 357.91,181.80 358.87,181.86 359.83,181.92 360.79,181.97 361.75,182.03 362.71,182.09 363.67,182.15 364.63,182.20 365.59,182.26 366.55,182.31 367.51,182.37 368.47,182.42 369.43,182.47 370.39,182.53 371.35,182.58 372.31,182.63 373.27,182.68 374.23,182.73 375.19,182.78 376.15,182.83 377.11,182.88 378.07,182.92 379.03,182.97 379.99,183.02 380.95,183.06 381.91,183.11 382.87,183.16 383.83,183.20 384.79,183.24 385.75,183.29 386.71,183.33 387.67,183.38 388.63,183.42 389.59,183.46 390.55,183.50 391.51,183.54 392.47,183.58 393.43,183.62 394.39,183.66 395.35,183.70 396.31,183.74 397.27,183.78 398.23,183.82 399.19,183.86 400.15,183.89 401.12,183.93 402.07,183.97 403.03,184.01 404,184.04'/></g></g><g  stroke="red"><g  stroke="black"><polyline points=' 4,191.54 403.99,191.54'/><polyline points=' 203.99,215.99 203.99,79.01'/></g><g  stroke-width=2.0><polyline points=' 4,186.67 5.99,185.81 7.99,185.07 9.99,184.46 11.99,184.00 13.99,183.70 15.99,183.57 17.99,183.62 19.99,183.85 21.99,184.26 23.99,184.84 25.99,185.59 27.99,186.50 29.99,187.53 31.99,188.69 33.99,189.93 35.99,191.24 37.99,192.59 39.99,193.95 41.99,195.29 43.99,196.58 45.99,197.78 47.99,198.87 49.99,199.83 51.99,200.62 53.99,201.22 55.99,201.63 57.99,201.81 59.99,201.76 61.99,201.49 63.99,200.97 65.99,200.23 67.99,199.26 69.99,198.10 71.99,196.74 73.99,195.23 75.99,193.59 77.99,191.84 79.99,190.04 81.99,188.21 83.99,186.39 85.99,184.63 87.99,182.97 89.99,181.44 91.99,180.10 93.99,178.96 95.99,178.07 97.99,177.45 99.99,177.14 101.99,177.14 103.99,177.47 105.99,178.14 107.99,179.14 109.99,180.47 111.99,182.11 113.99,184.04 115.99,186.23 117.99,188.65 119.99,191.24 121.99,193.97 123.99,196.78 125.99,199.62 127.99,202.41 129.99,205.11 131.99,207.65 133.99,209.95 135.99,211.97 137.99,213.64 139.99,214.90 141.99,215.70 143.99,215.99 145.99,215.73 147.99,214.90 149.99,213.45 151.99,211.39 153.99,208.70 155.99,205.38 157.99,201.45 159.99,196.92 161.99,191.84 163.99,186.25 165.99,180.19 167.99,173.73 169.99,166.93 171.99,159.87 173.99,152.63 175.99,145.29 177.99,137.94 179.99,130.66 181.99,123.56 183.99,116.71 185.99,110.21 187.99,104.14 189.99,98.58 191.99,93.60 193.99,89.27 195.99,85.65 197.99,82.77 199.99,80.70 201.99,79.44 203.99,79.01 205.99,79.44 207.99,80.69 209.99,82.77 211.99,85.64 213.99,89.27 215.99,93.60 217.99,98.58 219.99,104.14 221.99,110.21 223.99,116.71 225.99,123.56 227.99,130.66 229.99,137.93 231.99,145.29 233.99,152.63 235.99,159.87 237.99,166.93 239.99,173.73 241.99,180.19 243.99,186.25 245.99,191.84 247.99,196.92 249.99,201.44 251.99,205.37 253.99,208.69 255.99,211.39 257.99,213.45 259.99,214.90 261.99,215.73 263.99,215.99 265.99,215.70 267.99,214.90 269.99,213.64 271.99,211.97 273.99,209.95 275.99,207.65 277.99,205.11 279.99,202.42 281.99,199.62 283.99,196.78 285.99,193.97 287.99,191.24 289.99,188.65 291.99,186.23 293.99,184.04 295.99,182.11 297.99,180.47 299.99,179.14 301.99,178.14 303.99,177.47 305.99,177.14 307.99,177.14 309.99,177.45 311.99,178.07 313.99,178.96 315.99,180.09 317.99,181.44 319.99,182.97 321.99,184.63 323.99,186.39 325.99,188.21 327.99,190.04 329.99,191.84 331.99,193.59 333.99,195.23 335.99,196.74 337.99,198.10 339.99,199.26 341.99,200.23 343.99,200.97 345.99,201.48 347.99,201.76 349.99,201.81 351.99,201.63 353.99,201.22 355.99,200.62 357.99,199.83 359.99,198.87 361.99,197.78 363.99,196.58 365.99,195.29 367.99,193.95 369.99,192.59 371.99,191.24 373.99,189.93 375.99,188.69 377.99,187.53 379.99,186.50 381.99,185.59 383.99,184.84 385.99,184.26 387.99,183.85 389.99,183.62 391.99,183.57 393.99,183.70 395.99,184.00 397.99,184.46 399.99,185.07 401.99,185.81 403.99,186.66'/></g></g></g></svg></p>

     </div>

   <p id="footer"></p>
  <script src="lib/postprocessing.js"></script>
 </body>
</html>

