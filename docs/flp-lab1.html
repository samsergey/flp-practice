<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Введение</h2>

      <p>Когда-то, не очень давно, работа программиста называлась «кодированием», а программа — «машинным кодом». В самих этих названиях есть что-то от шпионских игр и шифровки. Программисты переводили метод решения прикладных задач на язык алгоритмов, понятный человеку, а алгоритмы — в последовательность инструкций, понятных машине. То есть, программа воспринималась, как текст, предназначенный для машины, а не для человека. Для того, чтобы человек мог разобраться в этих инструкциях, для их отладки или модификации, разрабатывались те или иные парадигмы программирования — стилистические и методологические концепции, позволяющие приблизить процесс написания и чтения программы к человеческому восприятию и к предметной области решаемых программистом задач.</p>
      
      <p>Разделяют две противоположные парадигмы программирования: императивную и декларативную. Само слово «программа» подразумевает некоторую последовательность действий, предписанную для выполнения задачи. В этом и проявляется императивный подход. В нём программой является последовательность инструкций, а вычислительным процессом — последовательность состояний вычислительной среды. При декларативном подходе программа превращается в совокупность набора определений, описывающих условие решаемой задачи, и набора соотношений, показывающих, в чём состоит её решение.</p>

      <p> Функциональное программирование (ФП) — это одна из парадигм декларативного программирования. В ней описание процесса решения задачи сводится к определению набора функций, а постановку задачи определяют аргументы, передаваемые этим функциям.</p>

      <p>В математике функция — это отображение из области определения в область значений. Когда мы говорим о функции <eq>f(x)</eq>, мы одновременно подразумеваем и процедуру отображения и результат этого отображения: в определённом смысле, мы в праве смешивать
	  эти два понятия. Такой подход к функциям оказался пригодным и очень продуктивным для программирования. Когда мы представляем программу, как набор функций, мы можем воспринимать их, в зависимости от необходимости, как процессы или как результаты, то есть, как данные.</p>
	  
<p> Перечислим основные принципы ФП:
<ul>
  <li> Использование функций, как объектов первого класса, то есть
функции можно использовать как данные и передавать их в качестве аргументов другим функциям и возвращать в качестве
результатов.
<li> Из предыдущего вытекает возможность писать и использовать
функции высших порядков и функционалы — функции, аргументами и значениями которых являются другие функции.
<li> Использование чистых функций — функций не имеющих
побочных эффектов, зависящих только от своих аргументов
и возвращающих только свой результат.
<li> Применение рекурсии, как основного способа описания циклических процессов.
<li> Интенсивные и ленивые вычисления, различающиеся порядком, в котором обрабатываются аргументы функций.
<li> Программирование не опирается на хранение состояния вычислительной среды. Вместо этого вычисляются результаты
чистых функций от исходных данных и результатов других
  функций.
</ul>
</p>

<p>Самое же главное — разработанная в математике строгая теория функций применима и к функциональным программам. Из перечисленных нами особенностей вытекают следующие достоинства ФП:
<ul>
  <li> Возможность строгого доказательства корректности программы и, как следствие, повышение надёжности кода.
<li> Возможность существенной оптимизации программы при компиляции.
<li> Высокая степень абстракции и связанные с этим удобочитаемость, расширяемость и переносимость программ.
<li>  Использование чистых функций существенно повышает модульность программ и упрощает организацию параллельных вычислений.
</ul></p>

<p> Освоение функциональной парадигмы
  прививает определённый стиль программирования, имеющий универсальные достоинства — писать «функционально» можно практически на любом высокоуровневом языке программирования. При этом программы становится легче читать, отлаживать и расширять. Меняется и подход к формулировке задач: она становится более строгой, и предметно-ориентированной.</p>
      <p>Кроме того, большинство современных промышленных языков программирования имеет функциональный инструментарий, и квалифицированный специалист должен уметь использовать его в полной мере.</p>
      <p> Наконец, немаловажным оказывается и субъективное восприятие той или иной парадигмы. При императивном подходе программист является «диктатором» — машина, получая от него список непреложных указаний, находится в подчинённом положении. Процесс декларативного программирования можно воспринимать, как обучение машины человеком, как передачу знаний и умений, зачастую, превращающееся в совместное с машиной исследование предметной
области. Именно функциональные языки программирования используются для разработки искусственного интеллекта, экспертных	систем, систем обработки символьных и вербальных данных.</p>
      
<!--      <h2>Использование <sl>Emacs</sl></h2>
      <task>Откройте редактор <sl>Emacs</sl> и создайте новый файл, нажав последовательно сочетания клавиш: <keystroke>Ctrl</keystroke>+<keystroke>x</keystroke> <keystroke>Ctrl</keystroke>+<keystroke>f</keystroke> (далее будем писать <keystroke>C-x C-f</keystroke>). В строке минибуфера введите путь и имя создаваемого файла, например, <tt>D:/tmp/FLPLabs/Lab1.hs</tt>. Редактор перейдёт в режим работы с программами, написанными на <lang>Haskell</lang>: <tt>haskell-mode</tt>.</task>

      <task>Введите простейшую программу:</task>

      <pre><hs>-- это первая программа на <lang>Haskell</lang>
main = putStrLn "Hello world!"</hs></pre>

      <task>Нажмите <keystroke>C-c C-l</keystroke> или <keystroke>F5</keystroke>. Эта команда запустит интерпретатор <sl>GHCi</sl>, загрузит в него написанный вами модуль и создаст новый буфер для работы с интерпретатором. Переключаться между буферами можно сочетанием клавиш <keystroke>C-x o</keystroke>.</task>

      <task>В строке ввода команды интерпретатора введите
	<pre><ghci><l></l> main</ghci></pre>
	Это выполнит вашу программу.</task>

      <task>Переключитесь в буфер с кодом программы. Измените что-либо в программе и сохраните изменения, нажав <keystroke>C-x C-s</keystroke>. После этого выйдите из <sl>Emacs</sl> с помощью сочетания <keystroke>C-x C-c</keystroke>.</task>

      <task>Снова откройте редактор <sl>Emacs</sl> и нажмите <keystroke>C-x C-r</keystroke>. Появится новый буфер со списком недавно открывавшихся файлов. Выбрать конкретный файл можно с помощью мыши, но проще воспользоваться номером файла, нажав клавишу с соответствующей цифрой.</task>

      <task>Просмотрите <a href ='emacs-ref.html' target='_blank'>краткую справку по <sl>Emacs</sl></a>, и поупражняйтесь в использовании сочетаний клавиш.</task> -->
      
      <h2>Использование <sl>GHCi</sl></h2>
      <h3>Простейшие вычисления</h3>
      <p>Cм. <a href ='haskell-ref.html#Выражения' target='_blank'>Выражения в <lang>Haskell</lang></a></p>
      <task>Выполните в <sl>GHCi</sl></task>
    <pre><hs> 2 + 3
 7 < 9.5
 10^2
 ((1 + 2) * 3) + 100
 "Hello!"
 "Hello" ++ " world!"</hs></pre>

    <h3>Вычисление и создание функций</h3>

      <p>Синтаксис языка <lang>Haskell</lang> полностью подчинён функциональной парадигме. Мы постоянно будем создавать и вызывать функции, поэтому вызов функции с заданными аргументами записывается чрезвычайно лаконично — без обязательных скобок и без запятых, разделяющих аргументы.</p>
    
    <task>Выполните в <sl>GHCi</sl></task>
    <pre><hs> sin 5
 length "Hello!"
 sin 2 + cos 6
 mod 47 12
 47 `mod` 12
 print (3 + 6)
 print $ 3 + 6
 exp (sin (sqrt 3))
 exp $ sin $ sqrt 3
 (exp . sin . sqrt) 3</hs></pre>

    <h2>Анонимные функции</h2>
      <p> Что не даёт программисту возможности обращаться с функциями, как с объектами первого класса в таких языках, как <lang>C</lang> или <lang>Pascal</lang>? В них мы можем присвоить некой переменной указатель
  на существующую функцию или связать эту переменную с объектом процедурного типа. Но пока мы не создадим функцию, то есть не опишем последовательность действий, которую она должна произвести и, самое главное, не дадим ей уникального имени, связывать переменную нам не с чем.</p>

<p>Для того, чтобы функции можно было создавать в процессе выполнения программы и возвращать в качестве результата, необходимо уметь описывать, что должна делать функция со своими
аргументами, не прибегая к именованию. В математическом понимании, функция — это отображение, то есть «правило», по которому каждому элементу одного множества — области определения —
  ставится в соответствие некоторый элемент другого множества — области значений. Например, функция, возводящая вещественный числовой аргумент в квадрат, каждому вещественному числу <eq>x</eq> ставит в соответствие число <eq>x\cdot x</eq>. Это правило можно записать, вообще
не давая никакого имени этой функции, например, так, как это принято в математике:
  <eqn>x \mapsto x\cdot x.</eqn>
  Таким образом, для полноценного функционального программирования, нужно уметь отделить абстрактную функцию-правило от конкретной именованной функции, существующей в памяти машины. Эту задачу выполняют анонимные функции или λ-функции.</p>
    
      <p>Создание λ-функций в <lang>Haskell</lang> не менее лаконично, чем её вызов. Cм. <a href ='haskell-ref.html#Анонимные функции' target='_blank'>Анонимные функции</a></p>
      <task>Выполните в <sl>GHCi</sl></task>

    <pre><hs> (\x -> x*x) 4
 (\x y -> x*x `mod` y) 4 3</hs></pre>

    <h3>Создание и обработка списков</h3>
      <p>Cм. <a href ='haskell-ref.html#Списки и функции для работы со списками' target='_blank'>Списки в <lang>Haskell</lang></a></p>
      <task>Выполните в <sl>GHCi</sl></task>
      <pre><hs> [1,3,5,7]
 [1..5]
 [1,3..10]
 sin <$> [1..5]
 (\x -> x*x-2*x) <$> [1,3..10]
 filter (\x -> x `mod` 3 == 0) [1..20]
 sum [1..100000]</hs></pre>

    <h2>Определение функций</h2>

    <p>Для удобства работы с этим курсом мы будем объединять написанные нами определения в модули (пакеты). Каждый модуль — это отдельный файл с именем, таким же как и у модуля. Например, модуль с функциями, определёнными на этом уроке может называться <tt>Lab1</tt>. Для его объявления надо в самом начале файла <tt>Lab1.hs</tt> с кодом написать такой заголовок:
      <pre><hs>module Lab1 where</hs></pre>
      Для использования этих функций в другом файле, который находится в той же папке что и <tt>Lab1.hs</tt>, нужно в заголовке нового файла написать команду импорта:
      <pre><hs>import Lab1</hs></pre>
      См. <a href ='haskell-ref.html#Модули' target='_blank'>Модули</a>.
    
    <task>Напишите функцию <code>circArea</code>, вычисляющую площадь круга, с указанным радиусом.
      <details><summary>Вариант решения</summary>
	<pre><hs>circArea r = pi * r**2</hs></pre>
    </details></task>

    <task>Напишите функцию <code>mean</code>, вычисляющую среднее арифметическое двух чисел.
      <details><summary>Вариант решения</summary>
	<pre><hs>mean a b = (a + b)/2</hs></pre>
    </details></task>

    <task>Напишите определение для функции
      <eqn>\mathrm{sinc}(x) = \frac{\sin(x)}{x}.</eqn>
      Так, чтобы правильно обрабатывался случай <eq>x = 0</eq>. См. <a href ='haskell-ref.html#Определение с образцом' target='_blank'>Определение с образцом</a>.</task>

    <task><a name="FizzBuzz"></a>Решите классическую задачу FizzBuzz: напишите программу, которая выводит на экран числа от 1 до 100, при этом вместо чисел кратных 3, программа должна выводить слово <tt>"Fizz"</tt>, вместо чисел кратных 5 — слово <tt>"Buzz"</tt>, если число кратно и 3 и 5, то программа должна выводить слово <tt>"FizzBuzz"</tt>, и, наконец, если ни одно из этих условий не вполнится, то должно быть выведено само число.
      
<details><summary>Вариант решения</summary>
	
      <ul>
	<li>Определяется чистая функция (например <code>fizzbuzz</code>), которая преобразует числа в строки, согласно условиям задачи (см. <a href ='haskell-ref.html#Определение с охраной' target='_blank'>Определение с охраной</a>;</li>
	<pre><hs>fizzbuzz n | n `mod` 3 == 0 = "Fizz"
           | n `mod` 5 == 0 = "Buzz"
           ...</hs></pre>
	<li>Функция <code>fizzbuzz</code> отлаживается и тестируется в интерпретаторе;</li>
	<pre><ghci><l></l> fizzbuzz 9
<o>"Fizz"</o>
<l></l> fizzbuzz 25
<o>"Buzz"</o>
<l></l> fizzbuzz 45
<o>"FizzBuzz"</o>
<l></l> fizzbuzz 44
<o>"44"</o></ghci></pre>
	<li>Функция <code>fizzbuzz</code> применяется к элементам списка чисел <code>[1..100]</code>, в результате получается список строк.</li>
	<pre><ghci><l></l> fizzbuzz <$> [1..100]</ghci></pre>
      </ul>
</details>
    </task>
    
<task>Напишите определение для функции <code>diff f x</code>, которая вычисляет производную функции <code>f</code> в точке <code>x</code>, используя приближение:
      <eqn>f^\prime(x) = \frac{f(x+dx)-f(x-dx)}{2\,dx},\quad dx = 10^{-8}</eqn>
      Вычислите таблицу производной для функций <eq>x^2</eq> и <eq>\mathrm{sinc}\,(x)</eq> на отрезке <eq>[0,5]</eq>. </task>

<hr/>

<p>Одной из важных задач прикладной математики является задача численного интегрирования. Существует простой и эффективный метод приближённого вычисления интегралов: метод гауссовых квадратур третьего порядка, он дает точные значения интеграла для полиномов до пятой степени:
<eqn>
\int_a^b f(x) dx \approx \frac{b-a}{18}\left[5\,g\left(-\sqrt{0.6}\right)+8\,g(0)+5\,g\left(\sqrt{0.6}\right)\right],
</eqn>
<eqn>
  g(x)=f\left(\frac{a+b}2+\frac{b-a}2x\right).  
</eqn>
</p>


<task>Напишите функцию <a name="gauss"><code>gauss f a b</code></a>, которая вычисляла бы интеграл от функции <code>f</code> в интервале от <code>a</code> до <code>b</code>, используя этот метод (cм. <a href ="haskell-ref.html#Дополнительные определения" target="_blank">Дополнительные определения</a>). Проверьте правильность работы функции <code>gauss</code> на следующих примерах:
  <eqn>\int_1^4 x^2\,dx,\quad \int_0^3 (x^5-x)\,dx,\quad \int_0^2 \sin x\,dx, \quad \int_0^\pi\,\mathrm{sinc}(x)dx.</eqn></task>


    <task>Используя функции <code>gauss</code> и <code>diff</code> Проинтегрируйте производную от какой-либо функции и убедитесь в том, что работает правило Ньютона-Лейбница: <eqn>\int_a^b f^\prime(x)\,dx=f(b)-f(a).</eqn></task>

      
    </p>
    
    </div>
    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>

