<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <h2>Знакомство с типами</h2>
    
    <div class='tasks'>
      
      <p>До сих пор мы не указывали типы у аргументов функций и возвращаемых ими значений. Но Haskell — статически типизированный язык, а это значит, что все выражения в программе имеют определённый тип, который известен на этапе компиляции программы. Мы могли позволить себе не указывать типы, поскольку они выводятся компилятором автоматически и это одно из следствий и преимуществ чистоты языка.</p> 
       
      <task> Выясните и объясните тип следующих выражений в интерпретаторе с помощью команды <code>:t</code>      </task>
	<pre><hs>:t 'a'
:t ['a','b','c']
:t "Hello"
:t 56
:t [2, 45, 6, 7]
:t [1 .. 5]
:t ('a',4)
:t 2 < 3
:t (< 3)
:t (==)
:t (+)
:t (+ 2)
:t sin
:t id
:t ($)
:t (.)
:t integrate
:t (\x -> x)
:t (\x y -> x)
:t (\x y -> x + y)</hs></pre>	

      <p>Cм. <a href ='haskell-ref.html#Типы данных и функций' target='_blank'>Типы данных и функций</a>.</p>
      
      <task>Посмотрите информацию о типах с помощью команды <code>:i</code>      </task>
	<pre><hs> :i Char
 :i String
 :i Bool
 :i Int
 :i []</hs></pre>

      <p>Cм. <a href ='haskell-ref.html#Классы типов' target='_blank'>Классы типов</a>.</p>
      <task>Посмотрите информацию о классах типов с помощью команды <code>:i</code></task>
	<pre><hs> :i Show
 :i Eq
 :i Ord
 :i Num
 :i Floating</hs></pre>
         
      <p>Несмотря на то, что компилятор хорошо справляется с выводом типов, указывать явно тип определяемой в программе функции полезно. Это, во-первых, хорошая документация к функции. Во вторых, при работе с полиморфными функциями и типами, иногда компилятору требуются некоторые подсказки.</p>
  
      <div class="disclaimer">Основные принципы проектирования функциональных программ:
	<ul>
	  <li> Каждая функция должна делать только одно дело, но делать его хорошо.
	  <li> Полиморфные функции лучше специальных.
	  <li> Тотальные функции лучше функций, вызывающих исключения.
	  <li> Структура типов должна отражать логику и универсальные свойства моделируемых объектов, а не моделировать сами объекты.
	  <li> "Не готовьте еду при клиенте". Клиент — это внешний мир, с которым мы общяемся с помощью операций ввода-вывода или связываясь по протоколам. Чистые функции полностью готовят решение внутри себя, а потом предлагают его внешнему миру. 
	</ul>
	</div>
      
      <p>
	Общий подход к решению реальных (и учебных) задач, предлагаемый функциональным программированием состоит в следующем: <ul>
	  <li> разбиваем задачу на отдельные очень небольшие, логически замкнутые и чистые подзадачи, определяя метод их комбинирования;
	  <li> определяем, вычисляем или выясняем тип функций, представляющих решение этих подзадач;
	  <li> пишем прототипы функций и тестируем их в REPL;
	  <li> комбинируем подзадачи для решения общей задачи;
	  <li> на последнем этапе создаём связь с внешним миром — ввод/вывод.
	</ul>
      </p>
      <h2>Описание электрических цепей</h2>

      <p>На этом занятии мы научимся использовать типы для описания сложных данных и создадим небольшой встроенный предметно-ориентированный язык (EDSL), для описания и моделирования достаточно широкого класса электрических цепей.</p>

      <p>Определим тип для представления произвольной двухполюсной электрической цепи, которая может состоять из сопротивлений (с&nbsp;номиналами типа <code>Double</code>) и допускает последовательное или параллельное соединение элементов цепи.</p>

      <pre><hs>data Circuit = R Double
             | Par Circuit Circuit
             | Seq Circuit Circuit
  deriving Show</hs></pre>

      <p>Например:</p>

      <pre><hs> -- сопротивление номиналом 20 Ом
 R 20
 -- последовательное соединение двух сопротивлений
 R 100 `Seq` R 10
 -- параллельное соединение двух сопротивлений
 R 100 `Par` R 10</hs></pre>      

      <task>Опишите с помощью этих конструкторов типов цепь, показанную на рисунке:<p align='center'><img src="img/circ1.png" alt="" width='40%'/><br/>Цепь 1.</p></task>

      <p>При рассчёте сопротивления цепей используются следующие формулы: при последовательном подключении элементов складываются значения сопротивлений,  а при параллельном подключении складываются проводимости:<eqn>R_\text{seq} = R_1 + R_2,\quad\frac{1}{R_\text{par}} = \frac{1}{R_1} + \frac{1}{R_2}.</eqn></p>
      <task> Напишите функцию <code>resistance</code>, которая вычисляла бы суммарное сопротивление произвольной двухполюсной цепи.
	<pre><hs>resistance :: Circuit -> Double</hs></pre>
      <details><summary>Вариант решения</summary>
	<pre><hs><d>resistance :: Circuit -> Double</d>
resistance c = case c of
  R r -> r
  Par c1 c2 -> 1/(1/resistance c1 + 1/resistance c2)
  Seq c1 c2 -> resistance c1 + resistance c2</hs></pre></details>
      Рассчитайте с помощью функции <code>resistance</code> сопротивление цепи 1.
      </task>

      <task>Пусть в указанной выше схеме, сопротивление номиналом 11 является переменным. Параметризуйте схему, превратив её в функцию от величины этого споротивления. Определите номинал  этого элемента, при котором сопротивление всей цепи будет равно 5.</task>

      <task>Добавьте в тип <code>Circuit</code> элемент <code>Key</code>, соответствующий ключу. При этом замкнутому состоянию ключа пусть соответствует нулевое, а разомкнутому — бесконечное сопротивление (его можно получить с&nbsp;помощью выражения <code>1/0</code>). Поместите вместо элементов с номиналами 11 и 7 ключи, и вычислите сопротивление цепи, при различных сочетаниях их состояний.</task>

      <task>Определите функцию <code>isConnected</code>, которая бы возвращала ответ на вопрос: замкнута цепь или нет.<pre><hs>isConnected :: Circuit -> Bool</hs></pre>  Проверьте работу этой функции при различных сочетаниях состояний ключей.</task>

      <h2>Тип для сопротивления</h2>
      
      <p>Использование бесконечного значения для представления разомкнутой цепи чревато неприятностями, оно не очень красиво и не позволит работать с произвольными (невещественными) числами. Правильным и идиоматичным функциональным путём будет определить отдельный тип, описывающий состояние цепи в электротехнических терминах.</p>

      <task>Определите тип <code>Resistance</code>, который может представлять разомкнутую цепь <code>Break</code>, цепь, замкнутую накоротко <code>Short</code> и цепь, обладающую конечным сопротивлением <code>Value Double</code>.</task>
 
      <task>Для типа <code>Resistance</code> определите операции параллельного <code>(&lt;||&gt;)</code> и последовательного <code>(&lt;&&&gt;)</code> соединения. <pre><hs>(&lt;||&gt;),(&lt;&&&gt;) :: Resistance -> Resistance -> Resistance</hs></pre> Переопределите функцию <code>resistance</code> так, чтобы она возвращала тип <code>Resistance</code>. Напишите короткое определение функции <code>isConnected</code>, использующее результат функции <code>resistance</code>.</task>


      <p>При расчёте электрических цепей переменного тока роль сопротивления играет импеданс, который выражается комплексным числом. Для цепей переменного тока следует добавить реактивные элементы: ёмкости и индуктивности. Импеданс ёмкости <eq>C</eq>, индуктивности <eq>L</eq> и сопротивления <eq>R</eq> зависит от частоты переменного тока <eq>\omega</eq> и вычисляется по формулам: <eqn>Z_C = 1/(i \omega C),\quad Z_L = i\omega L,\quad Z_R = R.</eqn> Импедансы складываются при параллельном и последовательном соединении элементов, по тем же правилам, что и активные сопротивления. </p>

      <task>Параметризуйте тип <code>Resistance</code> так, чтобы кроме типа <code>Double</code> он мог содержать в себе произвольные типы. Добавьте в тип <code>Circuit</code> представление для ёмкости и индуктивности — типы <code>C Double</code> и <code>L&nbsp;Double</code>. Опишите с помощью этого типа цепь 2, показанную на рисунке:<p align='center'><img src="img/circ2.jpg" alt="" width='40%'/><br/>Цепь 2.</p></task>

      <task>Дополните определение функции <code>resistance</code> так, чтобы она могла обрабатывать ёмкости и индуктивности. Для постоянного тока конденсаторы соответствуют разрыву цепи, а катушки индуктивности — короткому замыканию. Вычислите активное сопротивление цепи 2.</task>

      <p>Подключим к программе модуль <code>Data.Complex</code>, добавив в самом начале программы строчку: <pre><hs>import Data.Complex</hs></pre> Комплексное число конструируется с помощью оператора <code>:+</code> таким образом:
      <pre><hs>2 :+ 3  -- 2 + 3i
0 :+ 1  -- i</hs></pre>
      Комплексные числа с нулевой мнимой частью обозначаются простыми числовыми литералами.</p>

      
      <task>Дайте определение функции <code>impedance</code>, имеющей тип<pre><hs>impedance :: Circuit -> Double -> Resistance (Complex Double)</hs></pre> и вычислите импеданс для цепи 2. В полученном комплексном числе действительная часть должна быть равна активному сопротивлению цепи, а мнимая — реактивному (волновому).</task>

      <h2>Алгебра Де Моргана</h2>
      
      <p>Мы построили тип, описывающий <em>внутреннюю структуру</em> результата, в нашем случае, сопротивления. Это не просто число, оно может принимать различные по смыслу значения, которые по-разному комбинируются друг с другом.</p>
      <p> Если внимательно посмотреть на определения операторов <code>(&lt;||&gt;)</code> и <code>(&lt;&&&gt;)</code>, то можно заметить их сходство с логическими операторами над булевыми значениями. Если исключить из рассмотрения величины <code>Value</code>, то получатся точные определения логических операций И и ИЛИ, где роль <code>True</code> и <code>False</code> играют <code>Short</code> и <code>Break</code>, соответственно. Такое совпадение структур позволяет использовать то, что мы знаем о логике. В частности, закон де&nbsp;Моргана.</p>
      <eqn>\neg (A \vee B) = \neg A \wedge \neg B</eqn>
      
      <p>Осталось определить понятие отрицания для сопротивления. Это проводимость, — величина, обратная сопротивлению. Ведь при параллельном соединении складываются именно проводимости, значит наша догадка верна!</p>

      <p>То, что такие различные вещи, как логика и сопротивления образуют одинаковую алгебру, может показаться неожиданным, но это очень характерно для математики. Этим можно воспользоваться, определив свой собственный класс типов для всех объектов, для которых работает наша алгебра.</p>
      <pre><hs>class DeMorgan a where
  {-# MINIMAL inv, (zero| one), ((&&) | (||)) #-}
  inv :: a -> a

  zero :: a
  zero = inv one

  one :: a
  one = inv zero

  (&&) :: a -> a -> a
  a && b = inv (inv a || inv b)

  (||) :: a -> a -> a
  a || b = inv (inv a && inv b)</hs></pre>
      <p>В этом определении для класса приводятся не только типы элементов и операций, необходимых для алгебры, но и способ их определения по умолчанию. Это позволяет ограничиться определением только минимального набора при объявлении экземпляра класса <code>DeMorgan</code>. Вот как это делается для типа <code>Resisitance</code></p>
      <pre><hs>instance Fractional a => DeMorgan (Resistance a) where
  zero = Break

  inv Short = Break
  inv Break = Short
  inv (Value r) = Value (1/r)
  
  Break && _ = Break
  Short && r = r
  Value a && Value b = Value $ a + b
  a && b = b && a</hs></pre>

      <p>Здесь мы явно определили только необходимый минимум, остальные операции и значения определяются автоматически. Легко определить экземпляр этого класса для типа <code>Bool</code>, но из соображений эффективности стоит дать явные определения всем элементам класса::</p>
      <pre><hs>instance DeMorgan Bool where
  zero = False
  one = True
  inv = not
  True && x = x
  False && _ = False
  True || _ = True
  False || x = x</hs></pre>

      <p>Для того, чтобы переопределить операторы <code>(&&)</code> и <code>(||)</code> нужно в самом начале модуля добавить строчку импорта:</p>
      <pre><hs>import Prelude hiding ((&&), (||))</hs></pre>
      
      <hr/>
      <p>Нечёткая логика — это расширение булевой алгебры на вещественные величины на отрезке <eq>[0,1]</eq>. Она позволяет рассуждать не об истинности или ложности утверждения, а о вероятности его истинности или ложности. Существует два классических подхода к определению нечёткой логики. Один называется логикой Задэ (Zadeh), в которой операции И соответствет функция <code>min</code>, операции ИЛИ — <code>max</code>, а отрицание вычисляется как функция <eq>x \mapsto 1 - x</eq>. </p>

      <task>Определите экземпляр класса <code>DeMorgan</code> для типа <code>Zadeh</code>, содержащий вещественные числа:
	<pre><hs>newtype Zadeh = Zadeh Double deriving Show</hs></pre>      <details><summary>Вариант решения</summary><pre><hs>instance DeMorgan Zadeh where
  zero = Zadeh 0
  inv (Zadeh x) = Zadeh $ 1 - x
  Zadeh v1 && Zadeh v2 = Zadeh $ min v1 v2</hs></pre></details></task>


      
      <p>Другой вариант ближе к вероятностному подходу. В нём операция отрицания та же, что и в логике Задэ, а вероятность того, что произойдут два события равна произведению их вероятностей. </p>
<task>Определите тип <code>Fuzzy</code> для этого варианта нечеткой логики и объявите его экземпляром класса <code>DeMorgan</code>. Пользуясь правилом Де Моргана выясните как должна вычисляться вероятность того, что что произойдёт одно или другое событие.</task>

      <task>Для обоих вариантов вычислите следующие выражения:
	<pre><hs> 0.5 && 0.5
 0.5 || 0.5
 0.25 && 1
 0.25 || 1
 0.25 || 0.75 && 0.3
 0.3 && (0.2 || 0.5) || 0.8 && (0.2 || 0.5 || 0.1)</hs></pre>
      </task>

      <task>Убедитесь в том, что в обоих вариантах нечёткой логики значения <code>zero</code> и <code>one</code> образуют обычную булеву алгебру.</task>
      
      <task>Определите операцию исключающее ИЛИ (<code>xor</code>) и импликацию ЕСЛИ – ТО (<code>==></code>) для всех экземпляров класса <code>DeMorgan</code>. Проверьте, что они работают корректно для нечёткой логики.</task>
      
      <p>Алгебру Де Моргана, образуют темпы выполнения задач системой исполнителей. Школьные задачи про бассейны с трубами или про рабочих с канавами решаются в алгебре, образуемой значениями типа изоморфного типу <code>Resistance</code>. Например, такая задача: "Один рабочий способен выкопать канаву за 3 часа, второй — за 5 часов. За какое время будет выкопана та же канава обоими рабочими одновременно? А сколько времени им потребуется, если сначала половину канавы выкопает один рабочий, а потом вторую половину — другой?", решается следующими вычислениями:
	<pre><ghci><l></l> Value 3 || Value 5
<o>Value 1.875</o>
<l></l> Value (3/2) && Value (5/2)
<o>Value 4.0</o></ghci></pre></p>

      <task>Решите следующую задачу. Работа состоит из двух последовательных этапов. В бригаде три человека, и каждый из них может выполнять все части работы. Основываясь на среднем времени, которое требуется каждому из рабочих на выполнение каждого из этапов, определите оптимальное распределение задач: какой-то этап можно распределить между двумя работниками, какой-то, возможно, оставить одному. Производительность рабочих указана в таблице:
	<pre>	         рабочие
	     | A  | B  | C |
	  -------------------
этапы	   I | 56 | 48 | 52
работы	  II | 12 | 17 | 18 </pre>
      </task>

      <details><summary>Вариант решения</summary>
	<pre><hs>-- информация о призводительности работников
a 1 = Value 56
a 2 = Value 12
b 1 = Value 48
b 2 = Value 17
c 1 = Value 52
c 2 = Value 18

-- первый этап выполняется параллельно работниками A и B
-- второй только работником С
-- (a 1 || b 1) && c 2 </hs></pre></details>
      
      <p>Это очень простые задачи, но для большого числа этапов работ и исполнителей, ещё и с дополнительными ограничениями, найти оптимальную схему уже становится непросто. Мы рассмотрим способы их решения, когда обратимся к методам логического программирования.</p>
      
      <h2>Метод бисекции</h2>

      <task>В цепях переменного тока реактивное сопротивление может быть положительным или отрицательным, этот знак определяет сдвиг сигнала по фазе. Однако особый интерес представляет частота, при которой реактивное сопротивление обращается в ноль. Она соответствует резонансу — совпадению частоты сигнала с собственной частотой цепи. Определите резонансную частоту цепи 2, как частоту, при которой мнимая часть импеданса меняет знак.</task>
      
      <p>Поиск резонанса, как и решение произвольного алгебраического уравнения, можно и нужно автоматизировать. Для этого стоит воспользоваться универсальным и надёжным методом деления отрезка пополам, или методом бисекции. Он состоит в следующем: 
	  <ul>
	  <li> задан отрезок <eq>(a,b)</eq>;</li>
	  <li> задано условие <eq>p</eq>, которое в некоторой точке на отрезке меняет значение (например, меняется знак числовой функции); 
	  <li> если <eq>p(a) = p(b)</eq>, считаем, что искомой точки на отрезке нет;
	  <li> если отрезок достаточно мал, решением является его средняя точка;
	  <li> в противном случае решение находится либо в правой, либо в левой половине отрезка.
	  </ul></p>
      
      <task>Напишите функцию <code>bisection p a b</code>, которая методом деления отрезка пополам, находит точку на отрезке <code>(a,b)</code>, такую, что условие <code>p</code> в ней изменяется. <pre><hs>bisection :: Eq a
          => (Double -> a) -- тестовая функция
          -> (Double, Double) -- начальный интервал
          -> Maybe Double </hs></pre> При этом, если на указанном отрезке искомой точки не обнаруживается, функция должна возвращать значение <code>Nothing</code> (посмотрите определение типа <code>Maybe</code> с помощью команды интерпретатора <code>:i</code>). Относительная точность <eq>\varepsilon</eq>, с которой работает функция, должна составлять <eq>10^{-11}.</eq></task>

      <details><summary>Схема решения</summary>
	<pre><hs>bisection p (a, b)
  -- тестовая функция p не меняется на границах интервала
  | ... = Nothing
  -- достигнута абсолютная или относительная погрешность
  | ... = Just c
  -- шаг бисекции
  | otherwise = case bisection p (a, c) of
                  Nothing -> bisection p (c, b)
                  Just c -> Just c
  where c = mean a b</hs></pre></details>
      
      <task>Проверьте правильность работы функции на следующих примерах:
	<pre><hs> bisection (\x -> x < 2) (1, 3)
 bisection (\x -> x < 2) (0, 1)
 bisection (\x -> x < 2000) (0, 1000000)
 bisection (\x -> x < 2e6) (0, 1e9)
 bisection (\x -> x^2 < 2) (1, 2)
 bisection (\x -> (x-2)*(x-5) < 0) (1, 3)
 bisection (\x -> (x-2)*(x-5) < 0) (1, 13)
 bisection (\x -> cos x > 1 - 1/x) (0, 2)
 bisection (\x -> 1/x > 0) (-1, 2)
 bisection (\x -> isNaN (sqrt (3 - x^2))) (0, 2) </hs></pre>
      </task>

      <task>Добавьте в самое начало файла строчку (директиву компилятору)
	<pre><hs>{-# LANGUAGE DeriveFunctor #-}</hs></pre> и припишите к описанию типа <code>Resistance</code> указания для вывода экземпляров класса <code>Eq</code> и <code>Functor</code>: <pre><hs> deriving (Show, Eq, Functor)</hs></pre> О функторах ми поговорим несколько позже, но уже сейчас будет понятно, как мы расширили функциональность типа <code>Resistance</code> — теперь для него определен оператор <code><$></code>, позволяющий изменять значение внутри типа:
	<pre><ghci><l></l> (2 *) <$> Value 5
<o>Value 10</o>
<l></l> (2 *) <$> Break
<o>Break</o></ghci></pre></task>
      
      <task>Напишите функцию <code>resonance</code>, отыскивающую для цепи резонансную частоту в указанных пределах.<pre><hs>resonance :: Circuit -> (Double, Double) -> Maybe Double</hs></pre></task>
      
      <task>Найдите значение ёмкости в цепи 2, при которой резонансная частота цепи составит 0.5 МГц.</task>

<!--      <h3>Для тех кому не хватило</h3>
<p><a href ='deMorgan.html' target='_blank'>Ещё об алгебрах де Моргана.</a</p> -->

      
    </div>

    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
</html>
