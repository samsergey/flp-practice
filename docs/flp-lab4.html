<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="css/TPLBook.css">
    <link rel="stylesheet" href="css/idea.css">
    <link rel="stylesheet" href="lib/katex/katex.min.css">    

    <script src="lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();
      moduleName = null;
    </script>
    <script src="lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Свёртка списков</h2>
	
      <task>Выясните и объясните тип функций <code>foldr</code>, <code>scanr</code>, <code>foldl</code>, <code>scanl</code>. Вычислите несколько примеров в интерпретаторе:</task>
      <pre><hs> foldr (+) 0 [1..5]
 foldr (+) 10 [1..5]
 foldr (-) 0 [1..5]
 foldr (-) 10 [1..5]
 foldl (-) 0 [1..5]
 foldl (-) 10 [1..5]
 scanr (+) 0 [1..5]
 scanl (-) 0 [1..5]</hs></pre>

      <p> <img src="img/Right-fold-transformation.png" width='65%'/>
	<img src="img/Left-fold-transformation.png" width='65%'/></p>
      <task> На рисунках показан принцип работы правой и левой свёрток. Соотнесите эти схемы с типами функций <code>foldr</code> и <code>foldl</code>, а также с такими примерами:
	<pre><hs> foldl (printf "f(%v,%v)") "0" [1..5]
 foldr (printf "f(%v,%v)") "0" [1..5]
 scanl (printf "f(%v,%v)") "0" [1..5]
 scanf (printf "f(%v,%v)") "0" [1..5]</hs></pre>
	Функция форматированного вывода определена в модуле <code>Text.Printf</code>.
      </task>
      
      <task>Мы повсеместно используем позиционную систему записи чисел, в которой число определяется последовательностью цифр. Так в десятичной системе последовательность <eq>(23605)_{10}</eq> обозначает число <eqn>2\cdot10^4+3\cdot10^3+6\cdot10^2+0\cdot10^1+5.</eqn> По существу, цифры в числе — это коэффициенты полинома, который мы вычисляем в точке, соответствующей основанию: <eqn>2\cdot x^4+3\cdot x^3+6\cdot x^2+0\cdot x^1+5 = 23605\quad \text{for} \quad x = 10.</eqn>
	Для вычисления полиномов существует эффективный способ, который при том же количестве сложений и умножений, совсем не использует операцию возведения в степень, он называется схемой Горнера. Вот как по этой схеме вычисляется наш полином: <eqn>(((2\cdot x + 3)\cdot x + 6)\cdot x + 0)\cdot x + 5 = 23605\quad \text{for} \quad x = 10.</eqn> Обратите внимание на то, что вычисления представляют собой свёртку списка цифр с помощью функции <eq>r\ d \mapsto r\cdot10+d</eq>. Напишите, используя свёртку, функцию <code>fromBase</code>, транслирующую список цифр в заданной системе счисления в целое число:

	<pre><hs> fromBase 10 [1,2,3]   ==>  123
 fromBase 2 [1,1,0,1]  ==>  13 </hs></pre>
  Убедитесь в том, что эта функция является обратной функции <a href="flp-lab3.html#toBase"><code>toBase</code></a> из предыдущего занятия.
      </task>
  
      <task> Мы уже вычисляли приближение числа <eq>e</eq> по формуле:
	<eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
Вычислите приближение числа <eq>e</eq> более эффективным способом. Для этого сгенерируйте последовательность значений факториалов натуральных чисел с помощью функции <code>scanl</code>.</task>

      <task>В последовательности целых чисел найдите за один проход минимальное число и количество его повторений. Используйте следующий шаблон: <pre><hs><d>minCount :: Ord a => [a] -> (a, Int)</d>
minCount [] = error "List is empty"
minCount (x:xs) = foldl count _ xs
  where
    count (r, c) x | x == r = ...
                   | x &lt; r = ...
                   | otherwise = ...</hs></pre></task>

<!--      <task>Напишите генератор <a href="flp-lab3.html#Floyd">треугольника Флойда</a>, используя инструментарий для работы со списками.
  <details><summary>Вариант решения</summary>
    <pre><hs>floyd = zipWith (\s i -> [s .. s+i])
        (tail (scanl (+) 1 [0..]))
        [0..]</hs></pre>
  </details>
</task> -->

	<h2>Вычислительная мощность свёртки</h2>

      <p>Свёртка (катаморфизм) — это абстракция последовательной обработки индуктивных данных. Это означает, что любую задачу, сводимую к обработке списка элемент за элементом, можно решить при помощи свёртки.</p>

      <task>Напишите свою реализацию функций <code>map</code>, <code>(++)</code>, <code>reverse</code> и <code>filter</code>, используя явную рекурсию и вычислительные схемы в качестве подсказок:</task>

      <pre class="animate" id="mapA"></pre>
      <pre class="animate" id="appendA"></pre>
      <pre class="animate" id="reverseA"></pre>
      <pre class="animate" id="filterA"></pre>

      <task>Напишите свою рекурсивную реализацию функций <code>foldr</code> и <code>scanr</code>, <code>foldl</code>  и <code>scanl</code>. </task>

      <pre class="animate" id="foldrA"></pre>
      <pre class="animate" id="foldlA"></pre>
	    
      <task>Реализуйте только при помощи свёртки (правой, либо левой) все эти функции: <code>map</code>, <code>filter</code>, <code>reverse</code>, <code>(++)</code>, <code>any</code> и <code>all</code>, <code>maximum</code> и <code>minimum</code>, <code>length</code>, <code>scanr</code> и <code>scanl</code>. Для этого нужно подобрать подходящую сворачивающую функцию <tt>f</tt> и начальное значение <tt>x0</tt>.</task>

      
    <h2>Автоматное программирование</h2>

      <p>Очень широкий класс задач программирования и автоматизации самых разнообразных процессов решается с помощью автоматного подхода. <strong>Автоматом</strong> называют вычислитель, имеющий внутреннее состояние. Такой вычислитель принимает поток сигналов, событий или символов, который он последовательно обрабатывает, меняя своё состояние.  Вот некоторые области применения автоматного подхода:
	<ul>
	  <li>вендинговые аппараты (например, кофе-машины);
	  <li>организация работы сфетофоров;
	  <li>логические блоки в видеоиграх и в АСУ;
	  <li>поиск подстрок в тексте, распознавание регулярных выражений;
	  <li>лексическиц анализ
	  <li>организация работы контроллеров центрального процессора;
	  <li>анализ протоколов передачи данных (TCP/IP и т. д.);
	  <li>интерпретация стеково-ориентированных языков программирования.	    
	</ul></p>
      
      <p>Автомат полностью определяется набором допустимых состояний, набором допустимых входных сигналов (этот набор называют алфавитом), функцией перехода, начальным состоянием, а также состояниями аварийной остановки и успешного завершения работы. Самая главная часть автомата — функция перехода. Она задаёт переход из одного состояния в другое в зависимости от пришедшего сигнала или события и, возможно, выполняет какие-то действия.  Давайте определим тип для произвольного автомата:
	<pre><hs>data Automat s i =
  Automat { alpha :: Alphabeth i -- допустимые символы
          , delta :: s -> i -> s -- функция перехода
          , start :: s -- начальное состояние
          , stop :: [s] -- останавливающие состояния
          , final :: [s] -- конечные состояния
          }</hs></pre>

При этом множество допустимых входных символов автомата можно задать тремя способами:
<pre><hs>data Alphabeth i = Set [i]          -- конечный набор
                 | Only (i -> Bool) -- предикат
                 | Any              -- любые символы	</hs></pre>
	Определение этих типов может выглядеть длинновато и казаться сложным, но на самом деле эта запись точно описывает необходимые для автомата элементы. Здесь параметры типа <code>s</code> и <code>i</code> задают типы, соответственно, для возможных состояний автомата и входных данных.</p>

      <p>Самый простой вычислитель — <strong>конечный автомат</strong>, который можно реализовать как программным способом, так и аппаратно. Набор его возможных состояний конечен и известен на этапе разработки. Преимущества конечных автоматов состоят в исключительной надёжности и минимальности необходимых для работы вычислительных мощностей. Их редко приходится писать вручную, чаще всего они играют роль внутреннего представления прекомпилированных алгоритмов и программ.</p>

      <p>Определим в качестве примера конечный автомат, который вычисляет остаток от деления на 3 числа, записанного в двоичной форме. Он принимает набор символов из множества <eq>\{0,1\}</eq> и имеет три состояния начальное — 0 и два конечных — 1 и 2. Схема автомата, представленная на рисунке, отражает его функцию перехода.</p>
      <p><img src="img/automata3tuple.jpg" alt="" width='75%' align='center'/></p>
      <p>Работа автомата состоит в переборе элементов входного потока данных и последовательной смене состояния.</p>
      <pre class="animate" id='mod3'></pre>
      <p>Этот вычислительный процесс соответствует свёртке потока сигналов с помощью функции перехода автомата.</p>

      <p>Вот как можно определить его с помощью нашего типа:
	<pre><hs><d>mod3 :: Automat Int Int </d>
mod3 = Automat (Set [0,1]) f 0 [] [0,1,2]
  where f 0 0 = 0
        f 0 1 = 1
        f 1 0 = 2
        f 1 1 = 0
        f 2 0 = 1
        f 2 1 = 2</hs></pre></p>
      

      <task>Допишите определение функции <code>scanA</code>, которая будет запускать автомат для произвольного потока данных, возвращая поток этих же данных, сопровождаемых состояниями автомата:
	  <pre><hs><d>scanA :: (Eq s, Eq i) => Automat s i -> [i] -> [(s, i)]</d>
scanA m xs = takeWhile (not . halt) $ zip states inputs
  where
    -- поток допустимых символов
    inputs = case alpha m of
       Any    -> xs
       Set as -> filter (`elem` as) xs
       Only p -> filter p xs
    -- поток состояний автомата
    states = ...
    -- условие остановки работы
    halt = ... </hs></pre>

	  <pre><ghci><l></l> scanA mod3 [1,1,0,1,0,1]
<o>[(1,1),(0,1),(0,0),(1,1),(2,0),(2,1)]</o></ghci></pre>
Проверьте правильность работы автомата <code>mod3</code> на последовательности натуральных чисел от 0 до 10.

      </task>

      <task>Имея универсальный исполнитель <code>scanA</code> несложно написать два специальных исполнителя для работы с конечными автоматами: <code>runA</code>, возвращающий только последнее состояние машины и <code>testA</code>, который возвращает значение типа <code>Bool</code>, и позволяет использовать автоматы как распознаватели последовательностей (строк).<pre><hs>runA :: (Eq s, Eq i) => Automat s i -> [i] -> s
testA :: (Eq s, Eq i) => Automat s i -> [i] -> Bool</hs></pre></task>

      <task> Напишите функцию <code>printA</code> для вывода последовательности шагов работы автомата.
	<pre><ghci><l></l> printA mod3 [1,0,1,0,1]
<o>1    1</o>
<o>2    0</o>
<o>2    1</o>
<o>1    0</o>
<o>0    1</o></ghci></pre>

	Вывести строку можно с помощью функции <code>putStrLn</code>, а применить её к элементам списка функцией <code>mapM_</code>. </task>

      <task>Опишите и проверьте правильность работы конечных автоматов, принимающих последовательность символов <tt>{'a','b'}</tt> и распознающих строки, которые
	<ul>
	  <li>соответствуют регулярному выражению <tt>"ab+a"</tt> (<t>"aba"</t>, <t>"abba"</t>,<t>"abbbba"</t> и т. п.);</li>
	  <li>содержат подстроку <tt>"abba"</tt> в любой позици;</li>
	  <li>соответствуют регулярному выражению <tt>"(aba)+"</tt> (<t>"aba"</t>, <t>"abaaba"</t>,<t>"abaabaaba"</t> и т. п.);</li>
	  <li>оканчиваются на <tt>"aaa"</tt>;</li>
	  <li>начинаются на <tt>"bbb"</tt>;</li>
 	  <li>начинаются и оканчиваются одинаковым символом;</li>
	  <li>содержат чётное число символов <tt>'a'</tt>.</li>
	</ul>
      </task>
      
      <h2>Автомат со стековой памятью</h2>
     
      <p>Конечные автоматы имеют существенное ограничение — число их состояний конечно и должно быть известно на этапе проектирования. Это сильно снижает их вычислительную мощность. Если заменить набор конечных состояний на изменяемый стек, то можно получить более мощный вычислитель: <strong>автомат со стековой памятью</strong>. Такой автомат уже способен производить вычисления конечных арифметических выражений произвольной сложности, разбирать и транслировать широкий класс искусственных языков, которые называются контекстно-свободными.</p>
     
      <p> Классический пример задачи, которую может решить стековый автомат, но не сможет конечный автомат — это распознавание сбалансированного скобочного выражения. К сбалансированным выражениям относятся, например такие: <tt>(), (()), ()(), (()((())()))</tt> и т. п., а вот несколько примеров несбалансированных выражений: <tt>)(, (, (()(()(</tt>. </p>

      <p>Автомат, распознающий их может быть определён нами так:</p>
      <pre><hs>brackets = Automat (Set "()") f [] [] [[]]
  where f ('(' : s) ')' = s
        f s x = x:s</hs></pre>

      <task>Дополните автомат <code>brackets</code> так, чтобы он был способен распознавать правильные скобочные выражения, содержащие три различных вида скобок <tt>(), [], {}</tt>.</task>

      <task>Перепишите автомат <code>brackets</code> так, чтобы в скобочных выражениях могли, кроме скобок, встречаться любые символы, как в примерах:
	<pre>"(defun (abs x) (if (< x 0) (- x) x))"
"[(2+33)/(4-6*(12-7))]^4"
"[(1, 2), (3, 4), (2, 5)]"</pre></task>

      <h2>Стековый калькулятор</h2>      
      <p><img class='logo' src='img/rpn.jpg' width=30%/>Со времени появления калькуляторов HewlettPackard и MK-36 прошло более сорока лет. Они отличались от обыкновенных, во-первых, тем, что были стековыми, а во-вторых — программируемыми. И это не случайно. Стековые вычисления очень хорошо подходят для написания несложных программ для примитивного вычислителя. Принцип вычислений, который они реализовали остался актуален и используется тогда, когда есть необходимость производить вычисления на очень ограниченных вычислительных мощностях. В наше время стековые языки программирования нашли применение в виртуальных машинах: это языки для <sl>JVM</sl> для платформы <sl>Java</sl> и вычислителя <sl>CLR</sl> для <sl>.Net</sl>, для управления роботами: язык <sl>FORTH</sl>, и, наконец, язык программирования для управления принтерами <sl>PostScript</sl>. Всё это необычные, предельно простые языки с примитивной грамматикой, программы на которых с непривычки непросто писать, но необычайно просто выполнять.</p>

      <p>Мы реализуем в форме стекового автомата простейший калькулятор, позволяющий вычислять арифметические выражения произвольной сложности. Программы представляют собой выражения, записанные в обратной польской нотации. <strong>Обратной польской нотацией</strong> (ОПН) называется постфиксный способ записи арифметических и логических выражений, в котором оператор следует за операндами. Он совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН — плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)\quad</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек и чрезывычайно легко реализуется в форме стековой машины с такой функцтей перехода:<ul>
	  <li>Если на вход подан операнд (число), он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	</ul>

      <pre>
   команда | стек  | результат
   --------|-------|-----------
   число n |     s |       n:s
   --------|-------|-----------
   "+"     | x:y:s | (x + y):s
   --------|-------|-----------
   "*"     | x:y:s | (x * y):s
   --------|-------|-----------
   "-"     | x:y:s | (y - x):s
   --------|-------|-----------
   "/"     | x:y:s | (y / x):s</pre>


      <task>Реализуйте стековый калькулятор в виде автомата. Он должен быть способен вычислять выражения, представленные в форме строк с командами, разделёнными запятыми: <tt>"12 37 +"</tt>, <tt>"4 15 + 83 *"</tt>. В качестве лексического анализатора, разбивающего строку-программу на отдельные команды, можно использовать функцию <code>words</code> из стандартной библиотеки.</task>

      <task>Представьте в обратной польской записи и вычислите с помощью калькулятора выражения: <pre> 2 + 5*6 - 9
 (2 + 5)*6 - 9
 2 + 5*(6 - 9)
 (2 + 5)*(6 - 9)
 31 - 15 - 6
 31 - (15 - 9)
 (43 - 3*5)/2 + 5</pre></task>


      <p>Вместо непосредственного вычисления выражения, стековый автомат способен перевести его в иную форму, например, в префиксную скобочную нотацию, которую используют такие языки, как <sl>Lisp</sl>, <sl>Scheme</sl>, <sl>Closure</sl> и т. п.<pre> 2 + 5*6 - 9       ==> (- (+ 2 (* 5 6) 9))
 (2 + 5)*6 - 9     ==> (- (* (+ 2 5) 6) 9)
 2 + 5*(6 - 9)     ==> (+ 2 (* 5 (- 6 9)))
 (2 + 5)*(6 - 9)   ==> (* (+ 2 5) (- 6 9))
 31 - 15 - 6       ==> (- 31 (- 15 6))
 (31 - 15) - 9)    ==> (- (- 31 15) 9)
 (43 - 3*5)/2 + 5  ==> (+ (/ (- 43 (* 3 5)) 2) 5)</pre></p>

      <task>Напишите автомат, переводящий произвольное арифметическое выражение, записанное в ОПН, в префиксную скобочную нотацию и протестируйте его на приведённых выше примерах.
	<details><summary>Вариант решения</summary>
	  <pre><hs>rpnToLisp = Automat Any f [] [] []
  where
    f (x:y:s) o | isOperator o = printf "(%s %s %s)" o y x : s
    f s n = n : s</hs></pre>
      </details></task>
      
      <!--

      <h3>Лексический анализ</h3>
      
      <p>В результате лексического, анализа из исходной строки должна быть сформирована последовательность распознанных токенов. Например, строка <tt>"123*64 + 12/(18 - 4)"</tt> может быть преобразована в такую последовательность пар <pre>(N, "123") (O, "*") (N, "64") (O, "+") (N, "12") (O, "/") (P, "(")
 (N, "18") (O, "-") (N, "4") (P, ")")</pre> Здесь символы <code>N</code>, <code>O</code> и <code>P</code> помечают числа, операторы и скобки, соответственно. С этой работой может справиться конечный автомат, работащий по такой схеме:</p>
      <br/><img src="lexer.svg"></img><br/>
      Он будет останавливаться после успешного распознавания очередного токена в начале строки.
      <task>Реализуйте автомат <code>lexer</code>, и проверьте правильность его работы на простых примерах.</task>

      <p>Для разбора всего выражения можно многократно применять наш автомат, вычленяя токены один за другим. В этом нам поможет вспомогательная функция <code>prefixA</code>, которая запускает автомат и возвращает разобранную часть строки вместе с неразобранной частью.</p>

	<pre><hs>prefixA m xs = case scanA m xs of
  [] -> Nothing
  r -> Just ((fst <$> r, snd (last r)), drop (length r) xs)</hs></pre>

      <p>Вот пример её работы: <pre><hs>prefixA lexer "123+56"  ==>  Just (("123",N),"+56")</hs></pre> Для того, чтобы породить поток результатов разбора  </p>

      <p>У операции свёртки есть дуальная операция -- анаморфизм или развёртка <code>unfoldr</code>. Это абстракция порождения индуктивных данных. Посмотрим на типы этих двух функций:
	<pre><hs>foldr :: (a -> b -> b) -> b -> ([a] -> b)
unfoldr :: (b -> Maybe (a, b)) -> (b -> [a])</hs></pre>
	Развёртка определяется порождающей функцией <code>b -> Maybe (a, b)</code> и начальным значением 

      </p>
      
      <task>Вот как с помощью развёртки можно определить простой итератор </task>

      
      <p>Мы вернёмся к задаче разбора и трансляции арифметических выражения в разделе этого курса, посвящённом комбинаторным методам трансляции. Там эта же задача будет решена более изящным и универсальным образом.</p>


 -->
<!--
 <hr/>
<h3>Дополнение для тех, кому не хватило</h3>
 
  <task>Добавьте в язык калькулятора следующие команды управления стеком:
    <pre><hs> -- повторение верхнего элемента
1 2 3 4 d      ⟹  4 4 3 2 1
-- вращение двух верхних элементов
1 2 3 4 s      ⟹  3 4 2 1
-- копирование указанного элемента стека
1 2 3 4 1 i    ⟹  4 4 3 2 1  -- копирование последнего элемента
1 2 3 4 2 i    ⟹  3 4 3 2 1  -- копирование предпоследнего элемента
1 2 3 4 3 i    ⟹  2 4 3 2 1  -- копирование третьего сверху элемента
-- копирование нескольких верхних элементов стека
1 2 3 4 1 c    ⟹  4 4 3 2 1     -- копирование одного элемента
1 2 3 4 2 c    ⟹  4 3 4 3 2 1   -- копирование двух элементов
1 2 3 4 3 c    ⟹  4 3 2 4 3 2 1 -- копирование трёх элементов
-- вращение нескольких верхних элементов стека
1 2 3 4 2 1 r  ⟹  4 3 2 1 -- вращение двух элементов на один шаг
1 2 3 4 3 1 r  ⟹  3 2 4 1 -- вращение трех элементов на один шаг
1 2 3 4 3 2 r  ⟹  2 4 3 1 -- вращение трех элементов на два шага</hs></pre>

    Вам может понадобиться функция <code>splitAt</code>, входящая в стандартную библиотеку. 

  </task>
 
 <task>Напишите последовательность команд для калькулятора, вычисляющую для двух верхних чисел на стеке сумму их квадратов.</task>
  <pre><hs> norm = "..."
 calculator norm [3,4] ⟹ [25]</hs></pre>

 <task>Напишите последовательность команд для калькулятора, вычисляющую по схеме Горнера значение полинома второй степени <eq>a x^2 + b x + c</eq> в указанной точке <eq>x</eq>. Коэффициенты полинома и значение <eq>x</eq> находятся на стеке перед вычислением.</task>
  <pre><hs> poly2 = "..."
 calculator poly2 [2,1,0,1]  ⟹ [5]
 calculator poly2 [10,2,4,1] ⟹ [241]  </hs></pre>
 
 <task>Напишите программу для калькулятора, вычисляющую для трёх верхних чисел на стеке <code>[c, b, a]</code> корни квадратного уравнения <eqn>a x^2 + b x + c = 0.</eqn></task>
  <pre><hs> roots = "..."
 calculator roots [1,-2,1] ⟹ [1,1]
 calculator roots [-6,1,1] ⟹ [2,-3]
 calculator roots [1,0,1]  ⟹ [NaN,NaN] </hs></pre>

 <task>Созданный нами язык является конкатенативным. Это значит, что конкатенация двух программ является их композицией. Объединив программы <code>roots</code> и <code>poly2</code> проверьте, что они работают корректно, подставляя найденные корни полинома в полином.</task>

 <task>Чего не хватает языку управления калькулятором для полноты по Тьюрингу? Можно ли реализовать с помощью свёртки Тьюртнг-полный язык?</task>

-->
	
      <!-- <p> -->
      <!-- 	Следующие два задания являются факультативными. Выберите одно из них, которое вам кажется более интересным или понятным. -->
      <!-- </p> -->
      
      <!-- 	<task>Для работы с очень большими числами применяется разложение числа по большому основанию. Так, скажем, число <code>1234567</code> по основанию <code>1000</code> можно представить в виде списка <code>[1, 234, 567]</code>. Напишите функцию, умножающую "длинное число" в системе счисления с основанием, например, <eq>10^{9}</eq> (это число разрядов в типе <code>Int</code>, занимающем два байта), представляемое списком 9-значных "цифр" на число типа <code>Int</code>: -->
      <!-- 	  <pre><hs><def>multLong :: Int -> [Int] -> [Int]</def></hs></pre> -->
      <!-- 	Посчитайте с его помощью факториал 100 или 1000.</task> 
	
	<task>Составьте программу поиска всех решений ребуса <eqn>\mathrm{VOLVO} + \mathrm{FIAT} = \mathrm{MOTOR}.</eqn> Разным буквам соответствуют разные цифры, одинаковым — одинаковые. Старшая цифра каждого числа отличается от нуля (см.&nbsp;<a href ='haskell-ref.html#Генераторы списков' target='_blank'>Генераторы списков</a>).
	  <p>Программа в интерпретаторе будет работать довольно медленно. Для решения реальных задач программу следует скомпилировать с включённым флагом оптимизации. Для этого можно включить командную строку в редакторе <sl>Emacs</sl> с помощью команды<br/> <keystroke>M-x</keystroke> <tt>eshell</tt>. Далее выполняем компиляцию с оптимизирующим флагом <tt>-O3</tt>:
	  <pre>&gt; ghc.exe -O3 test.hs
[1 of 1] Compiling Main             ( test.hs, test.o )
Linking test ...
&gt; test.exe</pre>
	  </p>
	</task>-->


    </div>

    <p id="footer"></p>
    <script src="lib/postprocessing.js"></script>
  </body>
  <script>
    var mapLines=`map f [a, b, c, d]
map f [a, b, c, d] = map f (<r>a : [b, c, d]</r>)
map f [a, b, c, d] = <rs>f a :</rs> map f [b, c, d]
map f [a, b, c, d] = <rs>f a :</rs> map f (<r>b : [c, d]</r>)
map f [a, b, c, d] = <rs>f a : f b :</rs> map f [c, d]
map f [a, b, c, d] = <rs>f a : f b :</rs> map f (<r>c : [d]</r>)
map f [a, b, c, d] = <rs>f a : f b : f c :</rs> map f [d]
map f [a, b, c, d] = <rs>f a : f b : f c :</rs> map f (<r>d : []</r>)
map f [a, b, c, d] = <rs>f a : f b : f c : f d :</rs> map f <r>[]</r>
map f [a, b, c, d] = <rs>f a : f b : f c : f d : []</rs>
map f [a, b, c, d] = <rs>[f a, f b, f c, f d]</rs>`

    animateText('mapA', mapLines, 800)

    var appendLines=`[a, b, c, d] ++ [e, f]
[a, b, c, d] ++ [e, f] = (<r>a : [b, c, d]</r>) ++ [e, f]
[a, b, c, d] ++ [e, f] = <rs>a :</rs> ([b, c, d] ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a :</rs> ((<r>b : [c, d]</r>) ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a : b :</rs> ([c, d] ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a : b :</rs> ((<r>c : [d]</r>) ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a : b : c :</rs> ([d] ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a : b : c :</rs> ((<r>d : []</r>) ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a : b : c : d :</rs> (<r>[]</r> ++ [e, f])
[a, b, c, d] ++ [e, f] = <rs>a : b : c : d :</rs> [e, f]
[a, b, c, d] ++ [e, f] = <rs>[a, b, c, d, e, f]</rs>
[a, b, c, d] ++ [e, f] = <rs>[a, b, c, d, e, f]</rs>`

    animateText('appendA', appendLines, 800)

    var reverseLines=`reverse [a, b, c, d]
reverse [a, b, c, d] = go <rs>[]</rs> [a, b, c, d]
reverse [a, b, c, d] = go <rs>[]</rs> (<r>a : [b, c, d]</r>)
reverse [a, b, c, d] = go <rs>(a : [])</rs> [b, c, d]
reverse [a, b, c, d] = go <rs>(a : [])</rs> (<r>b : [c, d]</r>)
reverse [a, b, c, d] = go <rs>(b : a : [])</rs> [c, d]
reverse [a, b, c, d] = go <rs>(b : a : [])</rs> (<r>c : [d]</r>)
reverse [a, b, c, d] = go <rs>(c : b : a : [])</rs> [d]
reverse [a, b, c, d] = go <rs>(c : b : a : [])</rs> (<r>d : []</r>)
reverse [a, b, c, d] = go <rs>(d : c : b : a : [])</rs> []
reverse [a, b, c, d] = go <rs>[d, c, b, a]</rs> <r>[]</r>
reverse [a, b, c, d] = <rs>[d, c, b, a]</rs>
reverse [a, b, c, d] = <rs>[d, c, b, a]</rs>`

    animateText('reverseA', reverseLines, 800)

    var filterLines=`filter odd [1,2,5,4,7]
filter odd [1,2,5,4,7] = filter odd (<r>1 : [2,5,4,7]</r>)
filter odd [1,2,5,4,7] = <rs>1 :</rs> filter odd [2,5,4,7]
filter odd [1,2,5,4,7] = <rs>1 :</rs> filter odd (<r>2 : [5,4,7]</r>)
filter odd [1,2,5,4,7] = <rs>1 :</rs> filter odd [5,4,7]
filter odd [1,2,5,4,7] = <rs>1 :</rs> filter odd (<r>5 : [4,7]</r>)
filter odd [1,2,5,4,7] = <rs>1 : 5 :</rs> filter odd [4,7]
filter odd [1,2,5,4,7] = <rs>1 : 5 :</rs> filter odd (<r>4 : [7]</r>)
filter odd [1,2,5,4,7] = <rs>1 : 5 :</rs> filter odd [7]
filter odd [1,2,5,4,7] = <rs>1 : 5 :</rs> filter odd (<r>7 : []</r>)
filter odd [1,2,5,4,7] = <rs>1 : 5 : 7 :</rs> filter odd []
filter odd [1,2,5,4,7] = <rs>1 : 5 : 7 : []</rs>
filter odd [1,2,5,4,7] = <rs>[1, 5, 7]</rs>
filter odd [1,2,5,4,7] = <rs>[1, 5, 7]</rs>`

    animateText('filterA', filterLines, 800)


    
    var foldrLines=`foldr f x0 [a, b, c, d]
foldr f x0 [a, b, c, d] = foldr f x0 (a : [b, c, d])
foldr f x0 [a, b, c, d] = <rs>f a</rs> (foldr f x0 [b, c, d])
foldr f x0 [a, b, c, d] = <rs>f a</rs> (foldr f x0 (b : [c, d]))
foldr f x0 [a, b, c, d] = <rs>f a (f b</rs> (foldr f x0 [c, d]))
foldr f x0 [a, b, c, d] = <rs>f a (f b</rs> (foldr f x0 (c : [d])))
foldr f x0 [a, b, c, d] = <rs>f a (f b (f c</rs> (foldr f x0 [d])))
foldr f x0 [a, b, c, d] = <rs>f a (f b (f c</rs> (foldr f x0 (d : []))))
foldr f x0 [a, b, c, d] = <rs>f a (f b (f c (f d</rs> (foldr f x0 []))))
foldr f x0 [a, b, c, d] = <rs>f a (f b (f c (f d x0)))</rs>
foldr f x0 [a, b, c, d] = <rs>f a (f b (f c (f d x0)))</rs>`

    animateText('foldrA', foldrLines, 800)

    var foldlLines=`foldl f x0 [a, b, c, d]
foldl f x0 [a, b, c, d] = foldl f <rs>x0</rs> (a : [b, c, d])
foldl f x0 [a, b, c, d] = foldl f <rs>(f x0 a)</rs> [b, c, d]
foldl f x0 [a, b, c, d] = foldl f <rs>(f x0 a)</rs> (b : [c, d])
foldl f x0 [a, b, c, d] = foldl f <rs>(f (f x0 a) b)</rs> [c, d]
foldl f x0 [a, b, c, d] = foldl f <rs>(f (f x0 a) b)</rs> (c : [d])
foldl f x0 [a, b, c, d] = foldl f <rs>(f (f (f x0 a) b) c)</rs> [d]
foldl f x0 [a, b, c, d] = foldl f <rs>(f (f (f x0 a) b) c)</rs> (d : [])
foldl f x0 [a, b, c, d] = foldl f <rs>(f (f (f (f x0 a) b) c) d)</rs> []
foldl f x0 [a, b, c, d] = <rs>f (f (f (f x0 a) b) c) d</rs>
foldl f x0 [a, b, c, d] = <rs>f (f (f (f x0 a) b) c) d</rs>`

    animateText('foldlA', foldlLines, 800)

    
    var mod3Lines=`состояние → [<r>0</r>] 1 1 0 1 0 1 ← данные
состояние → [<r>0</r> 1] 1 0 1 0 1 ← данные
состояние → [<r>1</r>] 1 0 1 0 1   ← данные
состояние → [<r>1</r> 1] 0 1 0 1   ← данные
состояние → [<r>0</r>] 0 1 0 1     ← данные
состояние → [<r>0</r> 0] 1 0 1     ← данные
состояние → [<r>0</r>] 1 0 1       ← данные
состояние → [<r>0</r> 1] 0 1       ← данные
состояние → [<r>1</r>] 0 1         ← данные
состояние → [<r>1</r> 0] 1         ← данные
состояние → [<r>2</r>] 1           ← данные
состояние → [<r>2</r> 1]           ← данные
состояние → [<r>2</r>]             ← данные`
    
    animateText('mod3', mod3Lines, 800)
  </script>
</html>
