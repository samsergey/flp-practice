<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <h2>Альтернативное выполнение трансляторов</h2>

      <p> В формальных грамматиках есть цепочки элементов грамматики и альтернативы. Цепочки мы строить умеем с помощью комбинатора <code>>></code>. Приступим к альтернативам. Если входная строчка не соответствует одному транслятору, то может быть она подойдёт другому?</p>

      <pre><hs>t1 <|> t2 = Parser $ \r -> case run t1 r of
  Fail _ -> run t2 r
  Ok x r' -> Ok x r'</hs></pre>

      <p> Теперь у нас появился выбор!!</p>
      <pre><ghci><l></l> run (term 'a' <|> term 'b') "abab"
<o>Ok 'a' "bab"</o>
<l></l> run (term 'a' <|> term 'b') "bbab"
<o>Ok 'b' "bab"</o>  </ghci></pre>

      <p> Наличие свободного выбора и умение им пользоваться&nbsp;— это поистине великая вещь! Теперь мы можем определить транслятор для любой контекстно-свободной грамматики, ведь они описываются правилами такого рода:</p>
    <eqn>
A \rightarrow \alpha ~|~ \beta ~|~ \gamma ~|~ ...
    </eqn>
      <p>где <eq>\alpha, \beta, \gamma...</eq>&nbsp;— цепочки элементов грамматики: терминалов и нетерминалов. Цепочки мы создавать умеем и альтернативы определять можем, а сами правила соответствуют определениям функций. То есть, определяя функцию, мы определяем нетерминальный символ, и задание анализатора для КС-грамматики&nbsp;— это последовательность определений функций-нетерминалов через комбинации цепочек и альтернатив.</p>

    <p> Сделаем маленькое дополнение. В стандартной математической записи приоритет у операции последовательности в цепочке выше, чем у оператора альтернативы. В языке Haskell тоже можно определять приоритет инфиксных операторов. Сделаем приоритет операции <code>>></code> выше чем у операции <code><|></code>.</p>
    <pre><hs>infixl 0 <|>
infixl 1 >></hs></pre>

      <p>Заодно, мы объявили, что эти операции левоассоциативны. Это значит, что <pre><code>  a >> b >> c = (a >> b) >> c
a <|> b <|> c = (a <|> b) <|> c</code></pre></p>

      <p>Построенная нами система трансляции называется <em>"трансляцией методом рекурсивного спуска"</em>. Она начинает разбор с самого общего нетерминала и далее, вызывая функции-нетерминалы, которые используются в правых частях определений, спускается вниз по синтаксическому дереву.</p>

      <p> У этого метода есть серьёзное ограничение на допустимые грамматики&nbsp;— они не должны быть <em>лево-рекурсивными</em>.</p>

      <details><summary>Подробнее о L-грамматиках</summary>

	<p>Лево-рекурсивной (или L-грамматикой) называется грамматика, которая содержит правила вида:</p>

	<eqns>A \rightarrow A \alpha ~|~ \alpha'</eqns>

	<p> Метод рекурсивного спуска, встретив левую рекурсию, "проваливается" в бесконечный цикл. Это существенное ограничение, но любое лево-рекурсивное правило можно преобразовать в эквивалентное не лево-рекурсивное:</p>

	<eqns>A \rightarrow \alpha' A'\\
	  A' \rightarrow  \alpha A' ~|~ \varepsilon
	</eqns>

<p>Например, грамматика для левоассоциативного вычитания лево-рекурсивна (что естественно):
	<eqns>E \rightarrow E - T | T</eqns>
	но её можно преобразовать, исключив левую рекурсию:
	<eqns>E \rightarrow T E'\\
	  E' \rightarrow  - T E' ~|~ \varepsilon
	</eqns>

	<p>Это можно сделать автоматически, но обычно об этом заботится тот, кто пишет грамматику для конкретного анализатора.</p>

      </details>

      <p>Давайте же определим анализатор для какой-нибудь простой нерегулярной грамматики! Например, для такой, которая порождает цепочки вида <eq>(ab)^nba^n</eq>:</p>

    <eqns>
      A \rightarrow \text{'a'}~\text{'b'}~A~\text{'a'} ~|~ \text{'b'} 
    </eqns>
    <pre><hs>_A = term 'a' >> term 'b' >> _A >> term 'a' 
     <|> term 'b'</hs></pre>

    <pre><hs>runTestsFor p tst = runTests tst'
  where tst' = map (\(i,o) -> (p,i,o)) tst

testA = runTestsFor _A
    [ ("abba", Ok 'a' "")
    , ("ababbaa", Ok 'a' "")
    , ("abababbaaa", Ok 'a' "")
    , ("aba", Fail "aba")
    , ("ababa", Fail "ababa")] </hs></pre>

    
    <pre><ghci><l></l> testA</ghci></pre>

    
    <p>Что же, похоже анализатор работает и его определение в программе замечательно соответствует описанию грамматики.</p>

    
    <p>Как насчёт более сложной грамматики для арифметических выражений с целыми числами, правоассоциативной операцией сложения и скобками?</p>

    <eqns>
      E \rightarrow T ~\text{'+'}~ E ~|~ T\\
      T  \rightarrow \text{'('}~E~\text{')'} ~|~ N\\
      N \rightarrow d ~(N ~|~ \varepsilon)
    </eqns>

    <p>    Первым делом, возникает потребность в пустом символе <eq>\varepsilon</eq>. Определим его так:</p>

    <pre><hs>epsilon = Parser $ Ok ()</hs></pre>

    <p>Теперь можно определять грамматику:</p>

   <pre><hs>_E = _T >> term '+' >> _E <|> _T
_T = term '(' >> _E >> term ')' <|> _N
_N = digit >> (_N <|> epsilon)</hs></pre>

    <p>Выглядит неплохо. Но не компилируется!</p>

    <pre><ghci><err>parserM.hs:83:37-38: Couldn't match type ‘()’ with ‘Char’ …
    Expected type: Parser Char Char
      Actual type: Parser Char ()
    In the second argument of ‘(<|>)’, namely ‘_N’
    In the expression: term '(' >> _E >> term ')' <|> _N
Compilation failed.</err></ghci></pre>

    <details><summary>Учите английский!!</summary>
    <pre><ghci><err>parserM.hs:83:37-38: Не смог сопоставить тип ‘()’ с ‘Char’ …
     Ожидаемый тип: Parser Char Char
    Полученный тип: Parser Char ()
    Во втором аргументе ‘(<|>)’, а именно ‘_N’
    В выражении: term '(' >> _E >> term ')' <|> _N
Компиляция не удалась.</err></ghci></pre></details>
    
    <p>Компилятор даёт исчерпывающее объяснение, что именно ему не понравилось. Вот бы все компиляторы так внятно изъяснялись! То есть, транслятор <code>term</code> возвращает тип <code>Char</code>, а анализатор <code>_N</code>&nbsp;— <code>()</code>, и их нельзя комбинировать оператором <code><|></code>. Вот его тип:</p>

    <pre><ghci><l></l> :t (<|>)
<o>(<|>) :: Parser i a -> Parser i a -> Parser i a</o></ghci></pre>

    <p>Значит, надо привести типы комбинируемых выражений к одному. Проще всего это сделать так:</p>

   <pre><hs>_T = term '(' >> _E >> term ')' >> epsilon <|> _N</hs></pre>

      <p> Добавление пустого элемента ничего не изменяет в цепочке. А оператор <code>>></code> вернёт тип своего второго операнда: <code>()</code>. Для анализаторов это очень частый случай, значит можно ввести для этого специальный комбинатор. Назовём его <code>?></code>:
 <pre><hs><def>(?>) :: Parser i a -> Parser i b -> Parser i ()</def>
p1 ?> p2 = p1 >> epsilon >> p2 >> epsilon</hs></pre>
и перепишем код для анализаторов арифметических выражений:
   <pre><hs>_E = _T ?> term '+' ?> _E <|> _T
_T = term '(' ?> _E ?> term ')' <|> _N
_N = digit ?> (_N <|> epsilon)</hs></pre>
</p>
      Теперь всё компилируется и можно проверять работу анализатора:</p>
    <pre><hs>testG1 = runTestsFor _E
  [ ("12",            Ok () "" )
  , ("(1+2)+3",       Ok () "" )
  , ("1+(2+3)",       Ok () "" )
  , ("1+2+3",         Ok () "" )
  , ("((123+4))",     Ok () "" )
  , ("(13+4)+6345",   Ok () "" )
  , ("(13+4)+(6+32)", Ok () "" ) ]</hs></pre>

    <pre><ghci><l></l> testsG1</ghci></pre>

    <hr/><task> Напишите анализатор <code>maybe p</code>, позволяющий выразить мысль, что элемент <code>p</code> может встретиться, а может и не встретиться.</task>
    
    <hr/><task> Напишите анализатор <code>bracket</code>, распознающий правильные скобочные выражения с круглыми и квадратными скобками. </task>
    
    <hr/><task> Определите анализатор строк, представляющих простой e-mail адрес.</task><hr>

    <p>Прежде чем двигаться дальше, окинем общим взглядом, то что уже нами написано:</p>

      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok a i | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: [i] -> Result [i] a }</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic>  maybe</p>

<part>комбинаторы</part>
<p><basic><|>  >>  ?></basic></p>

<part>элементарные трансляторы</part>
<p><basic>epsilon</basic></p>

<part>трансляторы для коллекций</part>
<p><basic>end  next  check</basic>  term</p>

<part>трансляторы для строк</part>
<p>digit</p>
</sinopsys>
</details>

          <h2>От анализа к трансляции</h2>

      <p>Наконец, пора заняться серьёзным делом&nbsp;— трансляцией. Читаемые символы хочется как-то понимать, как-то обрабатывать. А для этого их нужно каким-то образом передавать по цепочке трансляторов.</p>

      <p> Давайте рассуждать, глядя на определение комбинатора <code>>></code>. 
    
	<pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Ok _ r' -> run t2 r'
  Fail r' -> Fail r'</hs></pre>

	Его тип: </p>

      <pre><hs><def>(>>) :: Parser i a -> Parser i b -> Parser i b</def></hs></pre>
      
      <p> Транслятор <code>t2</code> для своей работы не требует значения, возвращаемого транслятором <code>t1</code>. А если бы требовал, то как бы он смог его получить? Самое естественное для функционального языка решение&nbsp;— передать это значение, как аргумент функции, которая принимая и используя его, возвращает новый транслятор. Назовём эту функцию <code>f :: a -> Parser i b</code>.
	
      <p>Получается, нам нужен комбинатор, соединяющий в цепочку транслятор <code>Parser i a</code> и эту функцию. Назовём его <code>>>=</code>.
	<pre><hs>t1 >>= f = Parser $ \r -> case run t1 r of
  Ok x r' -> run (f x) r'
  Fail r' -> Fail r'</hs></pre>

	Тип этого комбинатора:
	<pre><hs><def>(>>=) :: Parser i a -> (a -> Parser i b) -> Parser i b</def></hs></pre>
      </p>
         
      <p>Ну, что же, попробуем написать транслятор, определяющий два <em>одинаковых</em> символа подряд, причём неважно каких. Раньше это нам было сделать невозможно:</p>

      <pre><hs>double = next >>= (\x -> term x)</hs></pre>
    
      <pre><ghci><l></l> run double "aab"
<o>Ok 'a' "b"</o>
<l></l> run double "aba"
<o>Fail "ba"</o> </ghci></pre>

      <p> Можно записать и короче:</p>

      <pre><hs>double = next >>= term</hs></pre>
      
      <p>Осталась одна важная деталь: как можно вернуть в качестве результата разбора какую-нибудь комбинацию из предыдущих результатов?</p>

      <p>Для этого определим функцию <code>pure</code>:</p>

      <pre><hs>pure x = Parser $ Ok x</hs></pre>

      <p>Теперь, например, можно прочитать цифру и тут же превратить её в однозначное число с помощью вспомогательной функции <code>digitToInt</code>:</p>

      <pre><hs>num1 = digit >>= (\x -> pure (digitToInt x))
digitToInt x = read [x] :: Int</hs></pre>

      <p>Или ещё проще:</p>

      <pre><hs>num1 = digit >>= (pure . digitToInt)</hs></pre>

      <p>А так&nbsp;— определить выражение для инфиксного сложения двух однозначных чисел:</p>

      <pre><hs>add = num1 >>= (\x -> term '+' >> num1 >>= (\y -> pure (x+y)))</hs></pre>

      <pre><ghci><l></l> run num1 "2"
<o>Ok 2 ""</o>
<l></l> run add "3+2"
<o>Ok 5 ""</o>
</ghci></pre>

      <p>Работает!! Но. Если вам кажется, что этот кошмар из значков и скобок&nbsp;— это абсолютно неудачный способ записывать трансляторы, то я вас поздравляю: вам так не кажется! Потерпите ещё совсем немного, скоро всё станет существенно лучше.</p>

      <h2>Мы придумали монаду!</h2>

      <p>Надеюсь вы уже узнали основные признаки монады в том, какие операции определены для трансляторов. Мы определили связывание <code>(>>=)</code>, функцию <code>pure</code>, а также альтернативное выполнение <code>(<|>)</code>. Незнакомым оказался оператор <code>(>>)</code>, но посмотрем внимательно на его определение можно догадаться, что он определяется через оператор <code>(>>=)</code>:<pre><hs>x >> f = x >>= (\_ -> f)</hs></pre> а значит, определён для всех монад.
      </p>
      
      <p>Итак, наш тип <code>Parser</code> является монадой, а значит и аппликативным функтором. Кроме того он ещё и альтернативен. Объявим эти свойства явно. Первым делом, уберём первую строчку программы, скрывающую операторы <code>>></code>, <code>>>=</code> и функцию <code>pure</code>, добавим модуль для работы с монадами и аппликкативными функторами
	<pre><hs>import Control.Monad
import Control.Applicative</hs></pre>
	сотрём (или закомментируем) наше определение оператора <code>>></code>,  а затем объявим наш тип <code>Parser i</code> монадой по всем правилам.</p>

      <pre><hs>instance Monad (Parser i) where
  t >>= f = Parser $ \r -> case run t r of
    Ok x r' -> run (f x) r'
    Fail r' -> Fail r'

instance Functor (Parser i) where
  fmap f p = p >>= (pure . f)

instance Applicative (Parser i) where
  pure = Parser . Ok
  f <*> x = f >>= (<$> x)</hs></pre>

      <p>Реализация экземпляра класса <code>Alternative</code> состоит в определении оператора <code><|></code> и единичного элемента <code>empty</code>, образующих моноид:</p>
      <pre>empty <|> x =  x <|> empty = x</pre>

      <p>Роль этого элемента в нашем случае играет функция, возвращающая <code>Fail</code>. Таким образом, получаем определение для экземпляра класса <code>Alternative</code>:</p>

      <pre><hs>instance Alternative (Parser i) where
  empty = Parser Fail
  t1 <|> t2 = Parser $ \r -> case run t1 r of
    Fail _ -> run t2 r
    Ok x r' -> Ok x r'</hs></pre>


      <task>Перепишите  определение функции <code>num1</code> с использование функториальных свойств трансляторов</task>
      
      <p> Теперь мы можем производить различные действия над результатами трансляции, действуя при этом на сам транслятор. Вот что имеется в виду. </p>

      <pre><ghci><l></l> run ((2*) <$> num1) "5"
<o>Ok 10 ""</o>
<l></l> run ((+) <$> num1 <*> num1) "57"
<o>Ok 12 ""</o>
<l></l> run ((+) <$> num1 <*> (term '+' >> num1)) "5+7"
<o>Ok 12 ""</o>
</ghci></pre>

      <task>Для функторов, кроме функции <code>fmap</code> определн оператор <code><$</code>, который выражается следующим образом:<pre>x <$ y = const x <$> y</pre>. Перепишите определение оператора <code>?></code>, используя оператор <code><$</code>.</task>
      
<p>После того, как мы объявили трансляторы аппликативными функторами, нам стала доступна функция <code>sequence</code>, превращающая список трансляторов в один транслятор, возвращающий список результатов:

      <pre><ghci><l></l> run (sequence [digit, digit, digit]) "1234"
<o>Ok "123" "4"</o></ghci></pre>

      Вот&nbsp;— изящное определение для повторения <code>n</code> раз транслятора <code>p</code>:
      <pre><hs>repeatP n p = sequence $ replicate n p</hs></pre>

      Для этой задачи есть функция <code>replicateM</code>, определённая для любых монад:

      <pre><ghci><l></l> run (replicateM 3 digit) "1234"
<o>Ok "123" "4"</o></ghci></pre>

      Очень полезна функция <code>mapM</code> -- монадический аналог функции отображения <code>map</code>. Посмотрим, что она может нам предложить:

      <pre><ghci><l></l> run (mapM term "cat") "catalog"
<o>Ok "cat" "alog"</o></ghci></pre>

      Из списка символов, <code>mapM term</code> произвела последовательность трансляторов <code>term</code> для этих символов, причём, получившийся транслятор возвращает список результатов этой последовательности. Теперь мы можем определить функцию, распознающую указанную строку:

      <pre><hs>string :: Eq a => [a] -> Parser a [a]
string = mapM term </hs></pre>

      <pre><ghci><l></l> run (string "cat") "catalog"
Ok "cat" "alog"</ghci></pre>

<p>После определения комбинатора <code><*></code>, в нашем распоряжении автоматически появилась ещё пара полезных комбинаторов:
    <ul>
      <li> <code>*></code>&nbsp;— игнорирует значение первого аргумента эквивалентен оператору <code>>></code>
      <li> <code><*</code>&nbsp;— игнорирует значение второго аргумента
    </ul>
    Они бывают нужны когда требуется выполнить транслятор в цепочке, но его результат передаваться дальше не будет. Например, пусть нужно чтобы за целым числом следовал пробел. Простая последовательность не годится. мы потеряем прочитанное число:</p>

<pre><ghci><l></l> run (num1 >> term ' ') "1 4"
<o>Ok ' ' "4"</o></ghci></pre>

     <pre><ghci><l></l> run (num1 <* term ' ') "1 4"
<o>Ok 1 "4"</o></ghci></pre>

 <p>А вот&nbsp;— вычитание двух чисел, разделённых знаком <code>'-'</code></p>
				   
     <pre><ghci><l></l> run ((-) <$> num1 <*> (term '-' *> num1)) "5-2"
<o>Ok 3 ""</o></ghci></pre>
</p>
      
      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok a i | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: [i] -> Result [i] a }<br/>
  (Functor, Applicative, Alternative, Monad)</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic> <der><$> <$</der></p>

<part>комбинаторы</part>
<p><basic><|>  >>=</basic>  <der>>> (*>)  ?></der><br/>
<der><*>  <*  <**></der></p>

<part>элементарные трансляторы</part>
<p><basic>pure</basic> epsilon</p>
	      
<part>трансляторы для коллекций</part>
<p><basic>end next  check</basic>  term<br/>
<der>sequence replicateM mapM</der> </p>

<part>трансляторы для строк</part>
<p>digit space string</p>
</sinopsys>
</details>

<h2>Делай раз! Делай два!</h2>

      <p>Монадам полагается ещё одна привилегия: специальный синтаксис для последовательности действий.</p>

      <p> Выражение <pre><hs> expr1 >> expr2</hs></pre> можно записать так:
	<pre><hs>do expr1
   expr2</hs></pre>
	Выражение <pre><hs> expr1 >>= (\x -> expr2)</hs></pre> так:
	<pre><hs>do x &lt;- expr1
   expr2</hs></pre>
	При этом в блоке <code>do</code> может быть сколько угодно выражений, связанных с символами или нет.

<p>Кроме того, у функции <code>pure</code> есть псевдоним <code>return</code>.</p>
	
<p> Давайте-ка перепишем определения для функций <code>num1</code>, и <code>add</code>  в новом виде:

  <pre><hs>num1 = do
  x <- digit
  return (readInt x)

add = do
  x <- num1
  term '+'
  y <- num1
  return (x+y)   </hs></pre>    

				   
    <p>Правда, стало похоже на императивную программу? Что-то вроде С#:</p>

    <pre><cs>int num() {
  var x = digit();
  return (Int.Parse(x.toString()));
}
	
int add() {
  var x = num();
  term('+');
  var y = num();
  return (x+y);
}</cs></pre>

      <p>В этом нет ничего удивительного. Монады нужны в очень многих приложениях, но на первый план они выступают в задачах, в которых речь идёт о последовательных вычислениях и трансляция&nbsp;— это типичный пример. Действительно, входная цепочка обрабатывается последовательно: сначала один символ, потом второй и т.д. В императивных программах это естественным образом кодируется последовательностью команд. Роль операторов <code>>>=</code> и <code>>></code> в C# играет "точка с запятой" , которой в функциональном программировании нет. Но её можно придумать и реализовать самим такой, какой нам надо. А это и есть&nbsp;— свобода.</p>

<details><summary>Подробности</summary>
  <p>Неужели стоило городить все эти абстракции: монады, аппликативные функторы и комбинаторы для того чтобы переизобрести императивное программирование!? Почему бы сразу не писать всё на C#?</p>
  
  <p> Существенная разница состоит в том, что Haskell позволил нам построить императивное программирование <em>с нужными нам свойствами</em>. Что происходит между командами с программе на C#? Ничего. В нашей программе между строк происходит проверка того, чем завершилось выполнение предыдущей команды, и если разбор оказался неудачным вся цепочка будет прекращена, а информация о неразобранной строке передана альтернативной ветке. В программе на C# для прекращения выполнения пришлось бы пользоваться механизмом исключений, а вместо изящного оператора <code><|></code> выстраивать нагромождение из конструкций <code>try-catch</code>. Сравним цепочку альтернатив:</p>

  <pre><hs> x <- term 'a' <|> term 'b' <|> term 'c'</hs></pre>

  <p>с её реализацией с помощью исключений:</p>

  <pre><cs>var x;
try
{
  x = term('a');
}
catch ()
{
  try
  {
    x = term ('b');
  }
  catch ()
  {
    x = term ('c');
  }
}</cs></pre>

  <p>Ещё хуже дело будет обстоять, если альтернативы будут включать в себя последовательности команд, сокращающие входную строку при разборе L(k)-грамматики. В этом случае при неудачном разборе нужно будет как-то вернуть читаемую строку к первоначальному состоянию перед передачей её в альтернативную ветку, а это ещё больше запутает и загромоздит код программы. Наш оператор <code><|></code> устроен так, что каждой ветке предлагается для разбора одна и та же строка (посмотрите на его определение) и этим все сложности снимаются. Мы сразу получаем LL(k)-транслятор. </p>

  
  <p>Монады и функциональный подход позволяют сколь угодно тонко настраивать контроль над вычислениями и вычислительным потоком, оставляя видимость простого последовательного выполнения команд.</p>

</details>


      
      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

