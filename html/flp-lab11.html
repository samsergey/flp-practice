<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->


 <h2>Арифметические выражения в обратной польской нотации</h2>

       <p>Обратной польской нотацией (ОПН) называется способ записи арифметических и логических выражений, который совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН -- плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr><hr/>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек. Приведём алгоритм вычисления для стековой машины:<ul>
	  <li>Обработка входного символа
	  <li>Если на вход подан операнд, он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	  <li>Если входной набор символов обработан не полностью, перейти к шагу 1.
	</ul>
	После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.</p>
      
      <p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

      <p>Начнём с описания интерпретации отдельных команд:</p>

      <pre>
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s</pre>

<p>Как видно, мы оперируем стеком, содержащим числа и строковыми командами, которые управляют состоянием стека. Определим для них типы:</p>

<pre><hs>type Command = String
type Stack = [Double]
</hs></pre>

<p>Таблицу команд легко описать как определение функции <code>interprete</code>:</p>

<pre><hs><def>interprete :: Stack -> Command -> Stack</def>
interprete (x:y:s) "+" = (x+y):s
interprete (x:y:s) "*" = (x*y):s
interprete (x:y:s) "-" = (y-x):s
interprete (x:y:s) "/" = (y/x):s
interprete s n = (read n):s
</hs></pre>

<p>С её помощью выражение <code>"2 3 +"</code> можно вычислить так:</p>

<pre>interprete (interprete (interprete [] "2") "3") "+"</pre>

<p>Это же левая свёртка! Замечательно. Значит, наш калькулятор можно описать в виде свёртки:</p>

<pre><hs><def>calculate :: String -> Stack</def>
calculate = foldl interprete [] . words</hs></pre>

<p>Функция <code>words</code> разделяет строку на лексемы (числа и операторы), а свёртка осуществляет вычисления. </p>

<task>Убедитесь в том, что калькулятор правильно производит вычисления для корректных выражений.</task>

<p>Техника трансляции позволит нам ещё более гибко работать со стеком, анализируя находящиеся на стеке элементы в соответствии с требованиями операций.

 <h2>Арифметические выражения в традиционной нотации</h2>

<p>Пора написать классический транслятор, который используется, как пробный камень во всех статьях по лексическому анализу и компиляции: транслятор произвольных арифметических выражений с учётом приоритетов, ассоциативности и скобок.</p>

<p> Грамматика арифметических выражений с левоассоциативными операциями такова:
  <eqns> E \rightarrow E ~(\text{'+'}~|~ \text{'}-\text{'})~T ~|~ T\\
    T \rightarrow T ~(\text{'*'}~|~\text{'/'})~ P ~|~ P\\
    P \rightarrow \text{'('}~ E ~\text{')'} ~|~ N
  </eqns>
  где <eq>N</eq>&nbsp;— целое число.
</p>

 <p>Можно честно перевести её к виду, исключающему левую рекурсию, но мы воспользуемся надёжным инструментом: вычислением цепочек <code>chainl</code>. Наделим термы <code>'+'</code>, <code>'-'</code> и т.д. функциональными свойствами:</p>
  
<pre><hs>add = (+) <$ term '+'
sub = (-) <$ term '-'
mul = (*) <$ term '*'
frac = div <$ term '/' </hs></pre>

<p>Имея такую свёртку легко напишем транслятор арифметических выражений, производящий вычисления в ходе трансляции:</p>

<pre><hs>expr = _E
  where _E  = foldP _T (add <|> sub)
        _T  = foldP _P (mul <|> frac)
        _P = between '(' ')' _E <|> integer

	add = (+) <$ term '+'
        sub = (-) <$ term '-'
        mul = (*) <$ term '*'
        frac = div <$ term '/'</hs></pre>

Проверяем:

<pre><hs>testExpr = runTestsFor expr
  [ ("23",                    Ok "" 23)
  , ("23+5",                  Ok "" 28)
  , ("23+5-13",               Ok "" 15)
  , ("23-5-13",               Ok "" 5)
  , ("23-(5-13)",             Ok "" 31)
  , ("2*3+4*5",               Ok "" 26)
  , ("2*(3+4)*5",             Ok "" 70)
  , ("32/2/2/2",              Ok "" 4)
  , ("32/(2/(2/2))",          Ok "" 16)
  , ("((((5))))",             Ok "" 5)
  , ("(2*(8-7/2)+5*8)/(2+3)", Ok "" 10)]</hs></pre>

Замечательно!

<hr><task>
  Перепишите определения <code>add</code>, <code>sub</code>, <code>mul</code>, <code>frac</code> так, чтобы транслятор <code>expr</code> переводил арифметические выражения в постфиксную форму, как в языках Fort или PostScript:

<pre><code>"23"         ==>  "23"
"23+5"       ==>  "23 5 +"
"23+5-13"    ==>  "23 5 + 13 -"
"23-5-13"    ==>  "23 5 - 13 -"
"23-(5-13)"  ==>  "23 5 13 - -"
"2*3+4*5"    ==>  "2 3 * 4 5 * +"
"2*(3+4)*5"  ==>  "2 3 4 + * 5 *"
"((((5))))"  ==>  "5"
"(2*(8-7/2)+5*8)/(2+3)"  ==>
       "2 8 7 2 / - * 5 8 * + 2 3 + /"</code></pre>
  
</task>

<hr><task>  Напишите транслятор арифметических выражений в префиксную скобочную форму, как в языке Lisp:

<pre><code>"23"         ==>  "23"
"23+5"       ==>  "(+ 23 5)"
"23+5-13"    ==>  "(- (+ 23 5) 13)"
"23-5-13"    ==>  "(- (- 23 5) 13)"
"23-(5-13)"  ==>  "(- 23 (- 5 13))"
"2*3+4*5"    ==>  "(+ (* 2 3) (* 4 5))"
"2*(3+4)*5"  ==>  "(* (* 2 (+ 3 4)) 5)"
"(2*(8-7/2)+5*8)/(2+3)"  ==>
    "(/ (+ (* 2 (- 8 (/ 7 2))) (* 5 8)) (+ 2 3))"</code></pre>
</task>

<hr><task> Добавьте в грамматику и в трансляторы унарный минус, так чтобы правильно интерпретировались такие выражения:

  <pre><code>-5
-(-5)
-3*3
3*(-3)
2+(-3)
2-(-3) </code></pre>
</task>

<hr><task> Напишите транслятор арифметических выражений в абстрактное синтаксическое дерево.</task>

<hr><task> Напишите вычислитель выражений в префиксной скобочной форме и транслятор из в префиксной скобочной формы в постфиксную.</task>

<hr><task>Напишите анализатор для условного оператора в языке C#.</task><hr/>

      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

