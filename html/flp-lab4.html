<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Свёртка списков</h2>
	
	<task>Выясните и объясните тип функций <code>foldr</code>, <code>scanr</code>, <code>foldl</code>, <code>scanl</code>. Вычислите несколько примеров в интерпретаторе:</task>
	  <pre><ghci>foldr (+) 0 [1,2,3]
foldr (+) 10 [1,2,3]
foldr (-) 0 [1,2,3]
foldr (-) 10 [1,2,3]
foldl (-) 0 [1,2,3]
foldl (-) 10 [1,2,3]
scanr (+) 0 [1,2,3]
scanl (-) 0 [1,2,3]</ghci></pre>

 
	  <task>Мы повсеместно используем позиционную систему записи чисел, в которой число определяется последовательностью цифр. Так в десятичной системе последовательность <eq>23605_{10}</eq> обозначает число <eqn>2\cdot10^4+3\cdot10^3+6\cdot10^2+0\cdot10^1+5.</eqn> По существу, цифры в числе -- это коэффициенты полинома, который мы вычисляем в точке, соответствующей основанию.

	    Для вычисления полиномов существует эффективный способ, который при том же количестве сложений и умножений, совсем не использует операцию возведения в степень, он называется схемой Горнера. Вот как по этой схеме вычисляется число <eq>23605_{10}</eq> :<eqn>(((2\cdot10 + 3)\cdot10+6)\cdot10+0)\cdot10+5.</eqn> Обратите внимание на то, что вычисления представляют собой свёртку списка цифр с помощью функции <eq>r\ d \mapsto r\cdot1+d</eq>. Напишите, используя свёртку, функцию <code>fromBase</code>, транслирующую список цифр в заданной системе счисления в целое число:

	    <pre><hs> fromBase 10 [1,2,3]  ==>  123 -- это целое число
 fromBase 2 [1,1,0,1]  ==>  13 </hs></pre>
  Убедитесь в том, что эта функция является обратной функции <a href="flp-lab3.html#toBase"><code>toBase</code></a> из предыдущего занятия.
</task>

 
	<task> Мы уже вычисляли приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
Вычислите приближение числа <eq>e</eq> более эффективным способом. Для этого сгенерируйте последовательность значений факториалов натуральных чисел с помощью функции <code>scanl</code>.</task>

<!--
	<task>Пользуясь функцией <code>elem</code>, напишите определения для функций <code>intersect l1 l2</code> и <code>complement l1 l2</code>, реализующих пересечение и дополнение множеств, представленных списками.</task>

	<task>Добавление элемента в множество, представленное списком можно определить следующим образом:
	  <pre><hs><def>insert :: Eq t => t -> [t] -> [t]</def>
insert y [] = [y]
insert y (x:xs) | x == y = x : xs
                | otherwise = x : insert y xs</hs></pre>
	  Объясните своими словами, как работает это определение. Пользуясь этой функцией и свёрткой напишите функцию <code>union l1 l2</code>, реализующую объединение множеств.</task>

	<task>Измените определение функции <code>insert</code>, так чтобы списки, представляющие множества были упорядочены. Даёт ли это какие-либо преимущества? Что нужно сделать для того, чтобы воспользоваться этим преимуществом в работе функций <code>intersect</code> и <code>complement</code>?</task> -->

	<task>В последовательности целых чисел найдите за один проход минимальное число и количество его повторений. Используйте следующий шаблон: <pre><hs><def>minCount :: Ord a => [a] -> (a, Int)</def>
minCount [] = error "List is empty"
minCount (x:xs) = foldl count _ xs
  where
    count (r, c) x | x == r = _
                   | x &lt; r = _
                   | otherwise = _</hs></pre></task>
	
	<h2>Вычислительная мощность свёртки</h2>

    <p>Свёртка (катаморфизм) — это абстракция последовательной обработки индуктивных данных. Это означает, что любую задачу, сводимую к обработке списка элемент за элементом можно решить при помощи свёртки.</p>

    <task>Напишите свою реализацию функции <code>length</code>, <code>map</code> и <code>filter</code>.</task>

    <task>Напишите свою реализацию функций <code>foldr</code> и <code>foldl</code>. </task>
    
    <task>Реализуйте только при помощи свёртки следующие функции: <code>map</code>, <code>filter</code>, <code>reverse</code>, <code>any</code>, <code>all</code>, <code>length</code>.</task>

    <h2>Конечные автоматы</h2>
      <p>Конечный атомат (<b>D</b>eterministic <b>F</b>inite <b>A</b>utomaton, DFA) -- это один из простейших вычислителей, который можно реализовать как программным способом, так и аппаратно. Данными для конечного автомата является поток сигналов (событий, символов), который он последовательно обрабатывает. Сам автомат определяется конечным набором состояний и функцией перехода, задающей переход из одного состояния в другое в зависимости от пришедшего сигнала или события. Перечислим некоторые области применения конечных автоматов:
	<ul>
	  <li>вендинговые аппараты (например, кофе-машины);
	  <li>организация работы сфетофоров;
	  <li>логические блоки в видеоиграх и в АСУ;
	  <li>поиск строк в тексте и распознавание регулярных выражений;
	  <li>организация работы контроллеров центрального процессора;
	  <li>анализ протоколов передачи данных (TCP/IP и т.д.).
	</ul>
	Преимущества конечных автоматов состоят в исключительной надёжности и минимальности необходимых для работы вычислительных мощностей.</p>

      <p>Напишем свой исполнитель конечных автоматов. Любой конечный автомат определяется набором допустимых состояний, набором допустимых входных сигналов (этот набор иногда называют алфавитом), функцией перехода и начальным состоянием. Давайте определим тип для произвольного конечного автомата:
	<pre><hs>data DFA s i o = DFA [i] (s -> i -> s) s (s -> o) </hs></pre>
	Определение типа выглядит длинновато и кажется сложным, но на самом деле эта запись точно описывает необходимые для конечного автомата элементы. Здесь параметр типа <code>s</code> определяет тип для возможных состояний автомата, а <code>i</code> и <code>o</code> задают типы входных и выходных данных соответственно. При этом сам конечный автомат, как полагается, содержит набор допустимых входных символов (первое поле), функцию перехода (второе поле), начальное состояние (третье поле) и функцию вывода результата из конечного состояния автомата (четвёртое поле). Последняя функция не является обязательной частью автомата, но пона позволяет по-разному интерпретировать результат его работы.</p>
      
      <p>Определим в качестве примера конечный автомат, который вычисляет остаток от деления на 3 числа, записанного в двоичной форме. Его схема представлена на рисунке.</p>
      <p><img src="img/automata3tuple.jpg" alt="" width='90%'/></p>

      <p>Этот автомат принимает поток нулей и единиц, соответствующих двоичному представлению числа, прочитывая их слева направо, и на каждом шаге переходит в одно из трёх состояний, соответствующих остатку от деления числа на 3. Вот как можно определить этот конечный автомат:

      <pre><hs>mod3 = DFA [0,1] f 0 id
  where f 0 0 = 0
        f 0 1 = 1
        f 1 0 = 2
        f 1 1 = 0
        f 2 0 = 1
        f 2 1 = 2</hs></pre>

      Так как конечное состояние автомата равно остатку от деления, в качестве функции выода результата мы используем тождестенную функцию <code>id</code>.</p>
      
      <task>Работа автомата состоит в переборе элементов входного потока данных и последовательной смене состояния. Этот вычислительный процесс соответствует свёртке потока с помощью функции перехода конечного автомата. Напишите функцию <code>runDFA</code>, которая будет запускать конечный автомат для произвольного потока данных. Тип этой функции может быть таким:
	<pre><hs>runDFA :: Eq i => DFA s i o -> [i] -> o</hs></pre>
	Эта функция должна отфильтровывать допустимые входные символы, сворачивать поток входных символов функцией перехода и, наконец, преобразовывать конечное состояние автомата в результат его работы.
	Проверьте правильность работы автомата <code>mod3</code> на последовательности натуральных чисел от 0 до 10.
      </task>

      <task>Опишите конечные автоматы, принимающие последовательность символов <tt>{'a','b'}</tt> и распознающие строки, которые
	<ul>
	  <li>содержат подстроку <tt>"abba"</tt>;</li>
	  <li>оканчиваются на <tt>"aaa"</tt>;</li>
	  <li>начинаются на <tt>"bbb"</tt>;</li>
 	  <li>начинаются и оканчиваются одинаковым символом;</li>
	  <li>содержат чётное число символов <tt>'a'</tt>.</li>
	</ul>
      </task>
      
      <h2>Автомат с магазинной памятью</h2>
      
      <p>Конечные автоматы имеют существенное ограничение -- число их состояний конечно и должно быть известно на этапе пректирования автомата. Это сильно снижает их вычислительную мощность. Если заменить набор конечных состояний на изменяемый стек, то можно получить более мощный вычислитель: автомат с магазанной памятью (<b>D</b>eterministic <b>S</b>tack <b>A</b>utomaton, DSA). Он уже способен производить вычисления конечных арифметических выражений произвольной сложности, разбирать и транслировать широкий класс искусственных языков, которые называются контекстно-свободными.</p>

      <p>Тип для произвольного автомата с магазинной памятью будет не сильно отличаться от типа для конечного автомата. Разница между ними состоит в том, чем является состояние автоматов: вместо одного состояния автомат с магазинной памятью оперирует стеком (списком) состояний.</p>
      <pre><hs>data DSA s i o = DSA [i] ([s] -> i -> [s]) [s] ([s] -> o) </hs></pre>
      
      <p> Классический пример задачи, которую может решить автомат с магазинной памятью, но не сможет конечный автомат -- это распознавание сбалансированного скобочного выражения. К сбалансированным выражениям относятся, например такие: <tt>(), (()), ()(), (()((())()))</tt> и т.п., а вот несколько примеров несбалансированных выражений: <tt>)(, (, (()(()(</tt>. </p>

      <p>Автомат, распознающий их может быть определён нами так:</p>
	<pre><hs>brackets = DSA "()" f null
  where f ('(' : s) ')' = s
        f s x = x:s</hs></pre>

	<task> Напишите функцию <code>runDSA</code>, которая будет запускать конечный автомат с магазинной памятью для произвольного потока данных. Проверьте с её помощью правильность работы автомата <code>brackets</code>.</task>

	<task>Дополните автомат <code>brackets</code> так, чтобы он был способен распознавать правильные скобочные выражения, содержащие три различных вида скобок <tt>(), [], {}</tt>.</task>

	<task>Часто невоможно перечислить допустимые символы, поскольку они образуют бесконечные множества (например, все строки, содержащие цифры). Измените определение функции <code>runDSA</code>) таким образом, чтобы пустой список допустимых символов в автомате означал произвольные входные символы. После чего перепишите автомат <code>brackets</code> так, чтобы в скобочных выражениях могли, кроме скобок, встречаться любые символы, как в примерах:
	  <pre><hs>"(defun (abs x) (if (< x 0) (- x) x)))"
"[(2+33)/(4-6*(12-7))]^4"
"[(1, 2), (3, 4), (2, 5)]"</hs></pre></task>

      <h2>Стековый калькулятор</h2>      
      <p><img class='logo' src='img/rpn.jpg' width=30%/>Со времени появления калькуляторов HewlettPackard и MK-36 прошло более сорока лет. Они отличались от обыкновенных, во-первых, тем, что были стековыми, а во-вторых -- программируемыми. И это не случайно. Стековые вычисления очень хорошо подходят для написания несложных программ для примитивного вычислителя. Принцип вычислений, который они реализовали остался актуален и используется тогда, когда есть необходимость производить вычисления на очень ограниченных вычислительных мощностях. В наше время стековые языки программирования нашли применение в виртуальных машинах: это языки для JVM для платформы Java и вычислителя CLR для .Net, для управления роботами: язык FORTH, и, наконец, язык программирования для управления принтерами PostScript. Всё это необычные, предельно простые языки с примитивной грамматикой, программы на которых с непривычки непросто писать, но необычайно просто выполнять.</p>

      <p>Мы реализуем в форме автомана с магазинной памятью простейший стековый калькулятор, не обладающий полнотой по Тьюрингу, но позволяющий вычислять арифметические выражения произвольной сложности. Программы представляют собой выражения, записанные в обратной польской нотации. <i>Обратной польской нотацией</i> (ОПН) называется способ записи арифметических и логических выражений, который совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН -- плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек. Приведём алгоритм вычисления для стековой машины:<ul>
	  <li>Обработка входного символа
	  <li>Если на вход подан операнд, он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	  <li>Если входной набор символов обработан не полностью, перейти к шагу 1.
	</ul>
	После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.</p>
      
      <p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

      <p>Начнём с описания интерпретации отдельных команд:</p>

      <pre>
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s</pre>


 <task>С помощью автомата с магазинной памятью реализуйте стековый калькулятор, способный вычислять выражения, представленные в форме строк с командами, разделёнными запятыми: "2 3 +", "4 5 + 3 *". В качестве лексического анализатора, разбивающего строку-программу на отдельные команды, можно использовать стандартную функцию <code>words</code>.</task>

 <task>Представьте в обратной польской записи и вычислите с помощью калькулятора выражения: <eq>2+5\cdot6-9, (2+5)\cdot(6-9), 31-15-6,</eq> <eq>31-(15-9), (43-3*5)/2+5</eq></task>

 <task>Поменяйте в функции <code>runDSA</code> функцию свёртки <code>foldl</code> на <code>scanl</code> и реализуйте лог выполнения программы. Вывести лог на печать можно с помощью функции <code>mapM_ print</code>. </task>

 <!--
 <hr/>
<h3>Дополнение для тех, кому не хватило</h3>
 
  <task>Добавьте в язык калькулятора следующие команды управления стеком:
    <pre><hs> -- повторение верхнего элемента
1 2 3 4 d      ⟹  4 4 3 2 1
-- вращение двух верхних элементов
1 2 3 4 s      ⟹  3 4 2 1
-- копирование указанного элемента стека
1 2 3 4 1 i    ⟹  4 4 3 2 1  -- копирование последнего элемента
1 2 3 4 2 i    ⟹  3 4 3 2 1  -- копирование предпоследнего элемента
1 2 3 4 3 i    ⟹  2 4 3 2 1  -- копирование третьего сверху элемента
-- копирование нескольких верхних элементов стека
1 2 3 4 1 c    ⟹  4 4 3 2 1     -- копирование одного элемента
1 2 3 4 2 c    ⟹  4 3 4 3 2 1   -- копирование двух элементов
1 2 3 4 3 c    ⟹  4 3 2 4 3 2 1 -- копирование трёх элементов
-- вращение нескольких верхних элементов стека
1 2 3 4 2 1 r  ⟹  4 3 2 1 -- вращение двух элементов на один шаг
1 2 3 4 3 1 r  ⟹  3 2 4 1 -- вращение трех элементов на один шаг
1 2 3 4 3 2 r  ⟹  2 4 3 1 -- вращение трех элементов на два шага</hs></pre>

    Вам может понадобиться функция <code>splitAt</code>, входящая в стандартную библиотеку. 

  </task>
 
 <task>Напишите последовательность команд для калькулятора, вычисляющую для двух верхних чисел на стеке сумму их квадратов.</task>
  <pre><hs> norm = "..."
 calculator norm [3,4] ⟹ [25]</hs></pre>

 <task>Напишите последовательность команд для калькулятора, вычисляющую по схеме Горнера значение полинома второй степени <eq>a x^2 + b x + c</eq> в указанной точке <eq>x</eq>. Коэффициенты полинома и значение <eq>x</eq> находятся на стеке перед вычислением.</task>
  <pre><hs> poly2 = "..."
 calculator poly2 [2,1,0,1]  ⟹ [5]
 calculator poly2 [10,2,4,1] ⟹ [241]  </hs></pre>
 
 <task>Напишите программу для калькулятора, вычисляющую для трёх верхних чисел на стеке <code>[c, b, a]</code> корни квадратного уравнения <eqn>a x^2 + b x + c = 0.</eqn></task>
  <pre><hs> roots = "..."
 calculator roots [1,-2,1] ⟹ [1,1]
 calculator roots [-6,1,1] ⟹ [2,-3]
 calculator roots [1,0,1]  ⟹ [NaN,NaN] </hs></pre>

 <task>Созданный нами язык является конкатенативным. Это значит, что конкатенация двух программ является их композицией. Объединив программы <code>roots</code> и <code>poly2</code> проверьте, что они работают корректно, подставляя найденные корни полинома в полином.</task>

 <task>Чего не хватает языку управления калькулятором для полноты по Тьюрингу? Можно ли реализовать с помощью свёртки Тьюртнг-полный язык?</task>

-->
	
      <!-- <p> -->
      <!-- 	Следующие два задания являются факультативными. Выберите одно из них, которое вам кажется более интересным или понятным. -->
      <!-- </p> -->
      
      <!-- 	<task>Для работы с очень большими числами применяется разложение числа по большому основанию. Так, скажем, число <code>1234567</code> по основанию <code>1000</code> можно представить в виде списка <code>[1, 234, 567]</code>. Напишите функцию, умножающую "длинное число" в системе счисления с основанием, например, <eq>10^{9}</eq> (это число разрядов в типе <code>Int</code>, занимающем два байта), представляемое списком 9-значных "цифр" на число типа <code>Int</code>: -->
      <!-- 	  <pre><hs><def>multLong :: Int -> [Int] -> [Int]</def></hs></pre> -->
      <!-- 	Посчитайте с его помощью факториал 100 или 1000.</task> 
	
	<task>Составьте программу поиска всех решений ребуса <eqn>\mathrm{VOLVO} + \mathrm{FIAT} = \mathrm{MOTOR}.</eqn> Разным буквам соответствуют разные цифры, одинаковым — одинаковые. Старшая цифра каждого числа отличается от нуля (см.&nbsp;<a href ='haskell-ref.html#Генераторы списков' target='_blank'>Генераторы списков</a>).
	  <p>Программа в интерпретаторе будет работать довольно медленно. Для решения реальных задач программу следует скомпилировать с включённым флагом оптимизации. Для этого можно включить командную строку в редакторе <sl>Emacs</sl> с помощью команды<br/> <keystroke>M-x</keystroke> <tt>eshell</tt>. Далее выполняем компиляцию с оптимизирующим флагом <tt>-O3</tt>:
	  <pre>&gt; ghc.exe -O3 test.hs
[1 of 1] Compiling Main             ( test.hs, test.o )
Linking test ...
&gt; test.exe</pre>
	  </p>
	</task>-->


    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
