<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Свёртка списков</h2>
	
	<task>Выясните и объясните тип функций <code>foldr</code>, <code>scanr</code>, <code>foldl</code>, <code>scanl</code>. Вычислите несколько примеров в интерпретаторе:</task>
	  <pre><ghci>foldr (+) 0 [1,2,3]
foldr (+) 10 [1,2,3]
foldr (-) 0 [1,2,3]
foldr (-) 10 [1,2,3]
foldl (-) 0 [1,2,3]
foldl (-) 10 [1,2,3]
scanr (+) 0 [1,2,3]
scanl (-) 0 [1,2,3]</ghci></pre>

 
	  <task>Мы повсеместно используем позиционную систему записи чисел, в которой число определяется последовательностью цифр. Так в десятичной системе последовательность <eq>23605_{10}</eq> обозначает число <eqn>2\cdot10^4+3\cdot10^3+6\cdot10^2+0\cdot10^1+5.</eqn> По существу, цифры в числе -- это коэффициенты полинома, который мы вычисляем в точке, соответствующей основанию.

	    Для вычисления полиномов существует эффективный способ, который при том же количестве сложений и умножений, совсем не использует операцию возведения в степень, он называется схемой Горнера. Вот как по этой схеме вычисляется число <eq>23605_{10}</eq> :<eqn>(((2\cdot10 + 3)\cdot10+6)\cdot10+0)\cdot10+5.</eqn> Обратите внимание на то, что вычисления представляют собой свёртку списка цифр с помощью функции <eq>r\ d \mapsto r\cdot1+d</eq>. Напишите, используя свёртку, функцию <code>fromBase</code>, транслирующую список цифр в заданной системе счисления в целое число:

	    <pre><hs> fromBase 10 [1,2,3]  ==>  123 -- это целое число
 fromBase 2 [1,1,0,1]  ==>  13 </hs></pre>
  Убедитесь в том, что эта функция является обратной функции <a href="flp-lab3.html#toBase"><code>toBase</code></a> из предыдущего занятия.
</task>

 
	<task> Мы уже вычисляли приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
Вычислите приближение числа <eq>e</eq> более эффективным способом. Для этого сгенерируйте последовательность значений факториалов натуральных чисел с помощью функции <code>scanl</code>.</task>

<!--
	<task>Пользуясь функцией <code>elem</code>, напишите определения для функций <code>intersect l1 l2</code> и <code>complement l1 l2</code>, реализующих пересечение и дополнение множеств, представленных списками.</task>

	<task>Добавление элемента в множество, представленное списком можно определить следующим образом:
	  <pre><hs><def>insert :: Eq t => t -> [t] -> [t]</def>
insert y [] = [y]
insert y (x:xs) | x == y = x : xs
                | otherwise = x : insert y xs</hs></pre>
	  Объясните своими словами, как работает это определение. Пользуясь этой функцией и свёрткой напишите функцию <code>union l1 l2</code>, реализующую объединение множеств.</task>

	<task>Измените определение функции <code>insert</code>, так чтобы списки, представляющие множества были упорядочены. Даёт ли это какие-либо преимущества? Что нужно сделать для того, чтобы воспользоваться этим преимуществом в работе функций <code>intersect</code> и <code>complement</code>?</task> -->

	<task>В последовательности целых чисел найдите за один проход минимальное число и количество его повторений. Используйте следующий шаблон: <pre><hs><def>minCount :: Ord a => [a] -> (a, Int)</def>
minCount [] = error "List is empty"
minCount (x:xs) = foldl count _ xs
  where
    count (r, c) x | x == r = _
                   | x &lt; r = _
                   | otherwise = _</hs></pre></task>
	
	<h2>Вычислительная мощность свёртки</h2>

    <p>Свёртка (катаморфизм) — это абстракция последовательной обработки индуктивных данных. Это означает, что любую задачу, сводимую к обработке списка элемент за элементом можно решить при помощи свёртки.</p>

    <task>Напишите свою реализацию функции <code>length</code>, <code>map</code> и <code>filter</code>.</task>

    <task>Напишите свою реализацию функций <code>foldr</code> и <code>foldl</code>. </task>
    
    <task>Реализуйте только при помощи свёртки следующие функции: <code>map</code>, <code>filter</code>, <code>reverse</code>, <code>any</code>, <code>all</code>, <code>length</code>.</task>

    <h2>Автоматное программирование</h2>

      <p>Очень широкий класс задач программирования и автоматизации самых разнообразных процессов решается с помощью автоматного подхода. Автоматом называют объект, имеющий внутреннее состояние, который принимает поток сигналов, событий или символов, который он последовательно обрабатывает. Автомат определяется функцией перехода, задающей переход из одного состояния в другое в зависимости от пришедшего сигнала или события и, возможно, выполняющей какие-то действия. Вот некоторые области применения автоматного подхода:
	<ul>
	  <li>вендинговые аппараты (например, кофе-машины);
	  <li>организация работы сфетофоров;
	  <li>логические блоки в видеоиграх и в АСУ;
	  <li>поиск подстрок в тексте, распознавание регулярных выражений;
	  <li>лексическиц анализ
	  <li>организация работы контроллеров центрального процессора;
	  <li>анализ протоколов передачи данных (TCP/IP и т.д.);
	  <li>интерпретация стеково-ориентированных языков программирования.	    
	</ul></p>
      
      <p>Самый простой вычислитель -- конечный атомат, который можно реализовать как программным способом, так и аппаратно. Набор его возможных состояний конечен и известен на этапе его разработки. Преимущества конечных автоматов состоят в исключительной надёжности и минимальности необходимых для работы вычислительных мощностей. Их редко приходится писать вручную, чаще всего они играют роль внутреннего представления прекомпилированных алгоритмов и программ.</p>

      <p>Автомат полностью определяется набором допустимых состояний, набором допустимых входных сигналов (этот набор иногда называют алфавитом), функцией перехода, начальным состоянием, а также состояниями аварийной остановки и успешного завершения работы. Давайте определим тип для произвольного автомата:
	<pre><hs>data Automat s i =
  Automat { alphabet :: [i] -- допустимые символы
          , delta :: s -> i -> s -- функция перехода
          , start :: s -- начальное состояние
          , stop :: [s] -- останавливающие состояния
          , final :: [s] -- конечные состояния
          }</hs></pre>
	Определение типа выглядит длинновато и кажется сложным, но на самом деле эта запись точно описывает необходимые для конечного автомата элементы. Здесь параметры типа <code>s</code> и <code>i</code> задают типы для возможных состояний автомата и входных данных соответственно.</p>
      
      <p>Определим в качестве примера конечный автомат, который вычисляет остаток от деления на 3 числа, записанного в двоичной форме. Его схема представлена на рисунке.</p>
      <p><img src="img/automata3tuple.jpg" alt="" width='75%' align='center'/></p>

      <p>Этот автомат принимает поток нулей и единиц, соответствующих двоичному представлению числа, прочитывая их слева направо, и на каждом шаге переходит в одно из трёх состояний, соответствующих остатку от деления числа на 3. Вот как можно определить этот конечный автомат:
      <pre><hs>mod3 :: Automat Int Int 
mod3 = Automat [0,1] f 0 [] [0,1,2]
  where f 0 0 = 0
        f 0 1 = 1
        f 1 0 = 2
        f 1 1 = 0
        f 2 0 = 1
        f 2 1 = 2</hs></pre></p>
      
      <task>Работа автомата состоит в переборе элементов входного потока данных и последовательной смене состояния. Этот вычислительный процесс соответствует свёртке потока с помощью функции перехода автомата. Допишите определение функции <code>scanFSM</code>, которая будет запускать автомат для произвольного потока данных, возвращая поток этих же данных, сопровождаемsх состояними автомата:
	<pre><hs>scanA :: (Eq s, Eq i)
        => Automat s i -> [i] -> [(i, s)]
scanA fsm xs = takeWhile (not . halt) 
                 $ zip inputs states
  where
    inputs = _ -- поток допустимых символов
    states = _ -- поток состояний автомата
    halt = _ -- условие остановки работы</hs></pre>

	Проверьте правильность работы автомата <code>mod3</code> на последовательности натуральных чисел от 0 до 10.
      </task>

      <task>Имея универсальный исполнитель <code>scanA</code> несложно написать два специальных сполнителя для работы с конечными автоматами: <code>runA</code>, возвращающий только последнее состояние машины и <code>testA</code>, который возвращает значение типа <code>Bool</code>, и позволяет использовать автоматы как распознаватели последовательностей (строк).<pre><hs>runA :: (Eq s, Eq i) => Automat s i -> [i] -> s
testA :: (Eq s, Eq i) => Automat s i -> [i] -> Bool</hs></pre>
Протестируйте их действие с помощью определённых выше конечных автоматов. Проверьте корректность работы всех этих функций на бесконечных потоках. </task>

      <task> Напишите функцию <code>printA</code> для вывода последовательности шагов работы автомата.
	<pre><hs>λ> printA mod3 [1,0,1,0,1]
1	1
0	2
1	2
0	1
1	0</hs></pre>

	Вывести строку можно с помощью функции <code>putStrLn</code>, а применить её к элементам списка функцией <code>mapM_</code>. Проверьте с её помощью правильность работы автомата <code>brackets</code>.</task>

      <task>Опишите и проверьте правильность работы конечных автоматов, принимающих последовательность символов <tt>{'a','b'}</tt> и распознающих строки, которые
	<ul>
	  <li>соответствуют регулярному выражению <tt>"ab+a"</tt> (<t>"aba"</t>, <t>"abba"</t>,<t>"abbbba"</t> и т.п.);</li>
	  <li>содержат подстроку <tt>"abba"</tt>;</li>
	  <li>соответствуют регулярному выражению <tt>"(aba)+"</tt> (<t>"aba"</t>, <t>"abaaba"</t>,<t>"abaabaaba"</t> и т.п.);</li>
	  <li>оканчиваются на <tt>"aaa"</tt>;</li>
	  <li>начинаются на <tt>"bbb"</tt>;</li>
 	  <li>начинаются и оканчиваются одинаковым символом;</li>
	  <li>содержат чётное число символов <tt>'a'</tt>.</li>
	</ul>
      </task>

      <br/>
      
      <p>Конечные автоматы имеют существенное ограничение -- число их состояний конечно и должно быть известно на этапе пректирования. Это сильно снижает их вычислительную мощность. Если заменить набор конечных состояний на изменяемый стек, то можно получить более мощный вычислитель: автомат со стековой памятью. Такой автома уже способен производить вычисления конечных арифметических выражений произвольной сложности, разбирать и транслировать широкий класс искусственных языков, которые называются контекстно-свободными.</p>
     
      <p> Классический пример задачи, которую может решить стековый автомат, но не сможет конечный автомат -- это распознавание сбалансированного скобочного выражения. К сбалансированным выражениям относятся, например такие: <tt>(), (()), ()(), (()((())()))</tt> и т.п., а вот несколько примеров несбалансированных выражений: <tt>)(, (, (()(()(</tt>. </p>

      <p>Автомат, распознающий их может быть определён нами так:</p>
      <pre><hs>brackets = Automat "()" f [] [] [[]]
  where f ('(' : s) ')' = s
        f s x = x:s</hs></pre>

      <task>Дополните автомат <code>brackets</code> так, чтобы он был способен распознавать правильные скобочные выражения, содержащие три различных вида скобок <tt>(), [], {}</tt>.</task>

      <task>Часто невоможно перечислить допустимые символы, поскольку они образуют бесконечные множества (например, все строки, содержащие цифры). Измените определение функции <code>scanA</code>) таким образом, чтобы пустой список допустимых символов в определении автомата означал произвольные входные символы. После чего перепишите автомат <code>brackets</code> так, чтобы в скобочных выражениях могли, кроме скобок, встречаться любые символы, как в примерах:
	<pre><hs>"(defun (abs x) (if (< x 0) (- x) x)))"
"[(2+33)/(4-6*(12-7))]^4"
"[(1, 2), (3, 4), (2, 5)]"</hs></pre></task>

      <h2>Стековый калькулятор</h2>      
      <p><img class='logo' src='img/rpn.jpg' width=30%/>Со времени появления калькуляторов HewlettPackard и MK-36 прошло более сорока лет. Они отличались от обыкновенных, во-первых, тем, что были стековыми, а во-вторых -- программируемыми. И это не случайно. Стековые вычисления очень хорошо подходят для написания несложных программ для примитивного вычислителя. Принцип вычислений, который они реализовали остался актуален и используется тогда, когда есть необходимость производить вычисления на очень ограниченных вычислительных мощностях. В наше время стековые языки программирования нашли применение в виртуальных машинах: это языки для JVM для платформы Java и вычислителя CLR для .Net, для управления роботами: язык FORTH, и, наконец, язык программирования для управления принтерами PostScript. Всё это необычные, предельно простые языки с примитивной грамматикой, программы на которых с непривычки непросто писать, но необычайно просто выполнять.</p>

      <p>Мы реализуем в форме стекового автомата простейший калькулятор, позволяющий вычислять арифметические выражения произвольной сложности. Программы представляют собой выражения, записанные в обратной польской нотации. <i>Обратной польской нотацией</i> (ОПН) называется способ записи арифметических и логических выражений, который совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН -- плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек. Приведём алгоритм вычисления для стековой машины:<ul>
	  <li>Обработка входного символа
	  <li>Если на вход подан операнд (число), он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	  <li>Если входной набор символов обработан не полностью, перейти к шагу 1.
	</ul>
	После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.</p>
      
      <p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

      <p>Начнём с описания интерпретации отдельных команд:</p>

      <pre>
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s</pre>


      <task>Реализуйте стековый калькулятор в виде автомата. Он должен быть способен вычислять выражения, представленные в форме строк с командами, разделёнными запятыми: "2 3 +", "4 5 + 3 *". В качестве лексического анализатора, разбивающего строку-программу на отдельные команды, можно использовать стандартную функцию <code>words</code>.</task>

      <task>Представьте в обратной польской записи и вычислите с помощью калькулятора выражения: <eq>2+5\cdot6-9, (2+5)\cdot(6-9), 31-15-6,</eq> <eq>31-(15-9), (43-3*5)/2+5</eq></task>

      <h2>Трансляция арифметических выражений. Алгоритм Дейкстры</h2>

      <p>Обратная польская запись идеальна для вычисления машиной. Она не требует ни скобок, ни приоритета операций, которые появились исторически и не имеют под собой строгой математической основы. Однако, мы вынуждены считаться с традицией и с традиционной инфиксной записью арифметических выражений.</p>

      <p>Существует эффективный алгоритм трансляции традиционной формы арифметических выражений в обратную польскую, известный как алгоритм сортировочной станции или алгоритм Дейкстры. Этот алгоритм использует стек и обрабатывая символы из потока ввода формирует поток вывода.</p>
      <ul>
	<li> Пока не все токены обработаны:</li>
	<ul>
	  <li> Прочитать токен.</li>
	  <li> Если токен — число, то добавить его в очередь вывода.</li>
	  <li> Если токен — оператор op1, то:</li>
	  <ul>
	    <li> Пока присутствует на вершине стека токен оператор op2, чей приоритет выше или равен приоритету op1, и при равенстве приоритетов op1 является левоассоциативным:</li>
	    <ul>
	      <li> переложить op2 из стека в выходную очередь;</li>
	    </ul>
	    <li> Положить op1 в стек.</li>
	  </ul>
	  <li> Если токен — открывающая скобка, то положить его в стек.</li>
	  <li> Если токен — закрывающая скобка:</li>
	  <ul>
	    <li>Пока токен на вершине стека не является открывающей скобкой, перекладывать операторы из стека в выходную очередь.</li>
	    <li>Выкинуть открывающую скобку из стека, но не добавлять в очередь вывода.</li>
	    <li> Если стек закончился до того, как был встречен токен открывающая скобка, то в выражении пропущена открывающая скобка.</li>
	  </ul>
	  <li> Если больше не осталось токенов на входе:</li>
	  <ul>
	    <li>Пока есть токены операторы в стеке:</li>
	    <ul>
	      <li>Если токен оператор на вершине стека — скобка, то в выражении присутствует незакрытая скобка.</li>
	      <li>Переложить оператор из стека в выходную очередь.</li>
	    </ul>
	  </ul>
	</ul>
	<li>Конец.</li>
      </ul>
      
      <p>Мы вернёмся к задаче разбора и трансляции арифметических выражения в разделе этого курса, посвящённом комбинаторным методам трансляции. Там эта же задача будет решена более изящным и универсальным образом.</p>


 
 <!--
 <hr/>
<h3>Дополнение для тех, кому не хватило</h3>
 
  <task>Добавьте в язык калькулятора следующие команды управления стеком:
    <pre><hs> -- повторение верхнего элемента
1 2 3 4 d      ⟹  4 4 3 2 1
-- вращение двух верхних элементов
1 2 3 4 s      ⟹  3 4 2 1
-- копирование указанного элемента стека
1 2 3 4 1 i    ⟹  4 4 3 2 1  -- копирование последнего элемента
1 2 3 4 2 i    ⟹  3 4 3 2 1  -- копирование предпоследнего элемента
1 2 3 4 3 i    ⟹  2 4 3 2 1  -- копирование третьего сверху элемента
-- копирование нескольких верхних элементов стека
1 2 3 4 1 c    ⟹  4 4 3 2 1     -- копирование одного элемента
1 2 3 4 2 c    ⟹  4 3 4 3 2 1   -- копирование двух элементов
1 2 3 4 3 c    ⟹  4 3 2 4 3 2 1 -- копирование трёх элементов
-- вращение нескольких верхних элементов стека
1 2 3 4 2 1 r  ⟹  4 3 2 1 -- вращение двух элементов на один шаг
1 2 3 4 3 1 r  ⟹  3 2 4 1 -- вращение трех элементов на один шаг
1 2 3 4 3 2 r  ⟹  2 4 3 1 -- вращение трех элементов на два шага</hs></pre>

    Вам может понадобиться функция <code>splitAt</code>, входящая в стандартную библиотеку. 

  </task>
 
 <task>Напишите последовательность команд для калькулятора, вычисляющую для двух верхних чисел на стеке сумму их квадратов.</task>
  <pre><hs> norm = "..."
 calculator norm [3,4] ⟹ [25]</hs></pre>

 <task>Напишите последовательность команд для калькулятора, вычисляющую по схеме Горнера значение полинома второй степени <eq>a x^2 + b x + c</eq> в указанной точке <eq>x</eq>. Коэффициенты полинома и значение <eq>x</eq> находятся на стеке перед вычислением.</task>
  <pre><hs> poly2 = "..."
 calculator poly2 [2,1,0,1]  ⟹ [5]
 calculator poly2 [10,2,4,1] ⟹ [241]  </hs></pre>
 
 <task>Напишите программу для калькулятора, вычисляющую для трёх верхних чисел на стеке <code>[c, b, a]</code> корни квадратного уравнения <eqn>a x^2 + b x + c = 0.</eqn></task>
  <pre><hs> roots = "..."
 calculator roots [1,-2,1] ⟹ [1,1]
 calculator roots [-6,1,1] ⟹ [2,-3]
 calculator roots [1,0,1]  ⟹ [NaN,NaN] </hs></pre>

 <task>Созданный нами язык является конкатенативным. Это значит, что конкатенация двух программ является их композицией. Объединив программы <code>roots</code> и <code>poly2</code> проверьте, что они работают корректно, подставляя найденные корни полинома в полином.</task>

 <task>Чего не хватает языку управления калькулятором для полноты по Тьюрингу? Можно ли реализовать с помощью свёртки Тьюртнг-полный язык?</task>

-->
	
      <!-- <p> -->
      <!-- 	Следующие два задания являются факультативными. Выберите одно из них, которое вам кажется более интересным или понятным. -->
      <!-- </p> -->
      
      <!-- 	<task>Для работы с очень большими числами применяется разложение числа по большому основанию. Так, скажем, число <code>1234567</code> по основанию <code>1000</code> можно представить в виде списка <code>[1, 234, 567]</code>. Напишите функцию, умножающую "длинное число" в системе счисления с основанием, например, <eq>10^{9}</eq> (это число разрядов в типе <code>Int</code>, занимающем два байта), представляемое списком 9-значных "цифр" на число типа <code>Int</code>: -->
      <!-- 	  <pre><hs><def>multLong :: Int -> [Int] -> [Int]</def></hs></pre> -->
      <!-- 	Посчитайте с его помощью факториал 100 или 1000.</task> 
	
	<task>Составьте программу поиска всех решений ребуса <eqn>\mathrm{VOLVO} + \mathrm{FIAT} = \mathrm{MOTOR}.</eqn> Разным буквам соответствуют разные цифры, одинаковым — одинаковые. Старшая цифра каждого числа отличается от нуля (см.&nbsp;<a href ='haskell-ref.html#Генераторы списков' target='_blank'>Генераторы списков</a>).
	  <p>Программа в интерпретаторе будет работать довольно медленно. Для решения реальных задач программу следует скомпилировать с включённым флагом оптимизации. Для этого можно включить командную строку в редакторе <sl>Emacs</sl> с помощью команды<br/> <keystroke>M-x</keystroke> <tt>eshell</tt>. Далее выполняем компиляцию с оптимизирующим флагом <tt>-O3</tt>:
	  <pre>&gt; ghc.exe -O3 test.hs
[1 of 1] Compiling Main             ( test.hs, test.o )
Linking test ...
&gt; test.exe</pre>
	  </p>
	</task>-->


    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
