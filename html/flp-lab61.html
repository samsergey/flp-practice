<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о моноидах построим гибкую и расширяемую систему для вывода графики, использующую web-интерфейс. Наша система будет представлять собой небольшой встроенный предметно-ориентированный язык (EDSL) для декларативного описания графики. Этот язык будет трансливаться в изображения формата SVG (Scalable Vector Graphics) -- это текстовый формат, используемый веб-браузерами и многими векторными графическими редакторами (<sl>Corel Draw</sl>, <sl>Inkscape</sl> и т.п.) или в код на языке JavaScript, так чтобы можно было создать растровое изображение (JPG, PNG, и т.п.)</p>

      
      <p>Наша цель создания собственного языка для описания изображений, в котором можно создавать фигуры: ломаные линии, точки, круги...; трасформировать эти фигуры: вращать, масштабировать, перемещать...; и, самое главное, объединять их: накладывать друг на друга, размещать их, указывая что один объект находится сбоку или сверху от другого и т.д. По существу мы хотим построить алгебру изображений и научиться её вычислять, получая реальные изображения в доступных форматах.</p>

      <h4>Типы для графических примитивов и изображения</h4>
      <p>Определим типы для представления некоторых графических примитивов: точек, ломаных линий. Картинка будет представлена множеством примитивов <code>Picture</code>:</p>
      <pre><hs>type Pt = (Float, Float)
  
data Primitive = Point Pt
               | Line [Pt]
               deriving Show

data Picture = Picture [Primitive] deriving Show</hs></pre>

      <p>Примитивы, которые хранятся в типе <code>Picture</code>, будут изображаются, накладываясь друг на друга в порядке перечисления, это наводит на мысль, что изображения образуют моноид с операцией наложения. Определим экземпляр класса <code>Monoid</code> для типа <code>Picture</code>:</p>
      <pre><hs>instance Monoid Picture where
  mempty = Picture mempty
  Picture p1 `mappend` Picture p2 = Picture (p1 <> p2)</hs></pre>

      <task>Напишите функции-конструкторы для элементарных фигур:
	<pre><hs>point :: Pt -> Picture
line :: [Pt] -> Picture
square :: Pt -> Float -> Picture
rectangle :: Pt -> Float -> Float -> Picture
triangle :: Pt -> Float -> Float -> Picture</hs></pre>
	У всех этих функций первый аргумент -- это координата нижнего левого угла фигуры, другие агрументы задают ширину и высоту фигуры.
      </task>

      <task>Опишите с помощью имеющихся примитивов простенький рисунок, например, квадратный домик с треугольной крышей.</task>


      <h4>Представление примитивов в формате SVG</h4>
      
      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle rx='x' ry='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <task>SVG -- это текстовый формат. Для того, чтобы упростить генерацию SVG напишите функцию <code>format</code> для форматирования строк по шаблону, последовательно заменяя символ <tt>'_'</tt> строками из списка. Например:
	<pre><ghci> Main> format "_ said: '_'" ["John", "Hello!"]
"John said: 'Hello!'"</ghci></pre>
	<em>Подсказка: воспользуйтесь функцией <code>splitOn</code> из модуля <code>Data.List.Split</code> для того, чтобы разбить форматируемую строку на части, а потом с помощью функции <code>zipWith</code> перемешайте эти части со строками из списка.</em>
      </task>

      <p>Определим собственный класс для того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
  toSVG :: a -> String</hs></pre></p>

      <task>Определите экземпляр этого класса для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG p = case p of
    Point (x,y) -> _
    Line pts -> _</hs></pre>
      </task>
      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='black'&gt;
  примитив
  примитив
  ...
&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения, прочие параметры задают графические атрибуты, используемые по умолчанию.</p>

      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code>, задав фиксированные размеры изображения, скажем, 400×300.</task>

      <task>Запишите SVG-выражение, описывающее домик в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в веб-браузере. Создайте вспомогательную функцию <code>writeSVG</code> для удобного экспорта изображений в файл. <pre><hs>writeSVG :: SVG a => String -> a -> IO ()</hs></pre></task>

      <task>Напишите конструктор <pre><hs>polygon :: Pt -> Int -> Float -> Picture</hs></pre> для правильных многоугольников заданного размера (размер задаётся радиусом описанной окружности). Первый аргумент определяет центр пногоугольника.</task>
      <task>Создайте избражение, показанное на рисунке:
	<p><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>

      <h4>Определение размеров изображения</h4>

      <p>Правильнее было бы не фиксировать размеры поля изображения в SVG-описании, а вычислять его, находя минимальные и максимальные значения координат примитивов. Эта информация будет нужна нам и для размещения изображений друг относительно друга.</p>

      <p>Включим "рамку", обрамляющую изображения, в тип <code>Picture</code> и определим тип для координат рамки:</p>
      <pre><hs>data Picture = Empty
             | Picture Box [Primitive]
             deriving Show

type Box = ((Min Float, Min Float), (Max Float, Max Float))

instance Bounded Float where
  minBound = -1000
  maxBound = 1000</hs></pre>
      
      <p>В типе <code>Box</code> первая пара задаёт левый нижний угол изображения, а вторая – правый верхний. Мы используем здесь полугруппы <code>Min</code> и <code>Max</code>, которые экпортируются из библиотеки <code>Data.Semigroup</code>. Для того, чтобы тип <code>Box</code> стал моноидом, мы определили минимальную и максимальную границы значений координат.</p>

      <task>Внесите необходимые изменения в определении экземпляра класса <code>Monoid</code> для типа <code>Picture</code>.</task>

      <task>Переопределите конструкторы <code>poiny, line, square, ...</code>
	<p>Для этого имеет смысл определить две вспомогательные функции <code>findBox</code> и <code>makePicture</code>, которые выполняли бы необходимые вычисления обрамляющей рамки для указанного примитива:
	  <pre><hs>findBox :: Primitive -> Box 
makePicture :: Primitive -> Picture</hs></pre>

	  Используйте моноидальные свойства типа <code>Box</code> при вычислении рамки для примитива <code>Line</code>.

      </task>

      <task>Наконец, используйте информацию об обрамляющей рамке изображения для вычисления размеров, указываемых в заголовке SVG-файла. Для этого напишите ещё несколько простых универсально полезных вспомогательных функций (геттеров для типа <code>Picture</code>):
	<pre><hs>box :: Picture -> (Pt, Pt)
with :: Picture -> Float
height :: Picture -> Float
contents :: Picture -> [Primitive]</hs></pre>
      </task>

      <h3>Преобразования изображений</h3>

      <p>
	Воспользуемся тем, что мы научились перемножать матрицы для преобразования изображений. Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги, повороты и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг (или их композицию), а вектор <eq>\vec v</eq> -- параллельный перенос. Преобразование можно выразить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преоьразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т.п.) используется именно такая реализация афинных преобразований. 
      </p>

      <task>Опрелите три основные вида преобразований:
	<ul>
	  <li> масштабирование осей: <code>scaleM a b</code>
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос: <code>translateM x y</code>
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на заданный угол: <code>rotateM alpha</code>
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </task>

      <task>Применять афинные преобразованияможно к точкам, примитивам и целыи изображениям. Это наводит на мысль о классе <code>Affine</code>, который абстрагировал это свойство в виде оператора афинных преобразований <code>(.$)</code>:
      <pre><hs>class Affine a where
  (.$) :: Transform -> a -> a

type Transform = M Float</hs></pre>

Напишите экземпляры этого класса для типов <code>Pt</code>, <code>Primitive</code> и <code>Picture</code>. 
      </task>
      
      <task>Напишите преобразователи изображений:
	  <pre><hs>scaleX :: Float -> Transform -- масштабирует координату x
scaleY :: Float -> Transform -- масштабирует координату y
scale :: Float -> Transform -- масштабирует обе координаты
shift :: Float -> Float -> Transform -- параллельный перенос изображения
rotate :: Float -> Transform -- поворот на угол, задаваемый в градусах	</hs></pre>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><hs>let s = square (0,0) 50
s <> rotate 90 .$ s
s <> shift 10 30 .$ s
s <> (scaleX 2 <> scaleY 3) .$ s
s <> rotate 60 .$ s
s <> (shift 30 0 <> rotate 60) .$ s </hs></pre></task>      

      <task>Объясните как вычисляется следующее выражение:
	<pre><hs>(rotate 30 .$) <> (shift 40 40 .$) $ square 10</hs></pre></task>
      
      <task>Добавьте к типу <code>Primitive</code> конструктор <code>Circle Pt Float</code> для окружности. Пусть, для простоты, при преобразованиях окружности, изменяется только положение центра координат. Окружность, которую можно транформировать произвольной матрицей (увеличивать, превращать в эллипс и т.д.) можно построить с помощью функции <code>polygon</code> сбольшим числом углов.</task>
      
      <task>Преобразователи позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига даёт нам возможность не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании квадрата и прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, с помощью которого, например, можно было бы построить квадрат с вписанной в него окружностью и расположить его в координатах (100, 100) так:
	<pre><hs>(circle 50 <> rectangle 50 50) `at` (100,100)</hs></pre></task>
     
      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат. Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат.</task>

      <task>Постройте картинку, задаваемую выражением:
      	<pre>mconcat $ take 48 $ iterate (rotate 7.5) $ square 50 `at` (25,25)</pre>
	<p align='center'><img src="img/wheel.png"/></p>
      </task>

      
    </div>

   <p id="footer"></p>
  <script src="../lib/postprocessing.js"></script>
 </body>
</html>

