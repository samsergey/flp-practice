<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <h2>Язык для описания изображений</h2>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о моноидах, построим гибкую и расширяемую систему для вывода графики, использующую общедоступный web-интерфейс. Наша система будет представлять собой небольшой <em>встроенный предметно-ориентированный язык</em> (EDSL) для декларативного описания графики. Этот язык будет транслироваться в изображения формата SVG (Scalable Vector Graphics -- это текстовый формат, используемый веб-браузерами и многими векторными графическими редакторами, такими как <sl>Corel Draw</sl>, <sl>Inkscape</sl> и т.п.) или в код на языке JavaScript, так чтобы можно было создавать растровое изображение (форматов JPG, PNG, и т.п.)</p>

      <p>Опишем возможности разрабатываемого языка. С его помощью можно:<ul>
	  <li> описывать элементарные фигуры: ломаные линии, точки, круги и т.д.;
	  <li> трансформировать эти фигуры: вращать, масштабировать, перемещать...;
	  <li> задавать стиль элементов изображения (цвет, заливку, толщину линий и т.п.);
	  <li> и, самое главное, комбинировать изображения: накладывать друг на друга, размещать их, указывая что один объект находится сбоку или сверху от другого и т.д. 
	</ul>
	По существу, мы построим алгебру изображений и научимся её вычислять (интерпретировать), получая реальные изображения в общедоступных графических форматах.</p>

      <h3>Типы для графических примитивов и изображений</h3>
      
      <p>Определим тип <code>Primitive</code> для представления двух (для начала) графических примитивов: точек и ломаных линий. Изображение будет представлено типом <code>Picture</code>, объединяющим множество примитивов:</p>
      <pre><hs>type Pt = (Float, Float)
  
data Primitive = Point Pt
               | Line [Pt]
               deriving Show

data Picture = Picture [Primitive] deriving Show</hs></pre>

      <p>Сразу продумаем как можно помбинировать примитивы и изображения. Самый непротиворечивый способ -- накладывать их друг на друга, то есть, изображать на одном холсте.</p>
      <p align='center'>
	<table>
	  <tr>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<circle cx='44' cy='34' r='30'  fill='red' stroke='black'/>
	    </svg></td>
	    <td><code>&lt;&gt;</code></td>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<polyline points=' 4,34 4,4 34,4 34,34 4,34' fill='blue' stroke='black'/>
	    </svg></td>
	    <td>=</td>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<circle cx='44' cy='34' r='30' fill='red' stroke='black'/>
		<polyline points=' 4,34 4,4 34,4 34,34 4,34' fill='blue' stroke='black'/>
	    </svg></td>
	  </tr>
      </table></p>

	
      <p>
	Более того, изображения образуют моноид с операцией наложения (убедитесь мысленно, что наложение ассоциативно и имеет нейтральный элемент). Определим экземпляр класса <code>Monoid</code> для типа <code>Picture</code>:</p>
      <pre><hs>instance Monoid Picture where
  mempty = Picture mempty
  Picture p1 `mappend` Picture p2 = Picture (p1 &lt;&gt; p2)</hs></pre>

      <task>Напишите функции-конструкторы для элементарных фигур:
	<pre><hs>point :: Pt -> Picture
line :: [Pt] -> Picture
square :: Pt -> Float -> Picture
rectangle :: Pt -> Float -> Float -> Picture
triangle :: Pt -> Float -> Float -> Picture</hs></pre>
	У всех этих функций первый аргумент -- это координата нижнего левого угла фигуры, другие агрументы задают ширину и высоту фигуры.
      </task>

      <task>Опишите с помощью имеющихся примитивов простенький рисунок, например, квадратный домик с треугольной крышей.</task>


      <h4>Представление примитивов в формате SVG</h4>
      
      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle rx='x' ry='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <task>SVG -- это текстовый формат. Для того, чтобы упростить генерацию SVG напишите функцию <code>format</code> для форматирования строк по шаблону, последовательно заменяя символ <tt>'_'</tt> строками из списка. Например:
	<pre><ghci> Main> format "_ said: '_'" ["John", "Hello!"]
"John said: 'Hello!'"</ghci></pre>
	<em>Подсказка: воспользуйтесь функцией <code>splitOn</code> из модуля <code>Data.List.Split</code> для того, чтобы разбить форматируемую строку на части, а потом с помощью функции <code>zipWith</code> перемешайте эти части со строками из списка.</em>
      </task>

      <p>Определим собственный класс для того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
  toSVG :: a -> String</hs></pre></p>

      <task>Определите экземпляр этого класса для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG p = case p of
    Point (x,y) -> _
    Line pts -> _</hs></pre>
      </task>
      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='black'&gt;...&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения, прочие параметры задают графические атрибуты, используемые по умолчанию.</p>

      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code>, задав фиксированные размеры изображения, скажем, 400×300.</task>

      <task>Запишите SVG-выражение, описывающее домик в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в веб-браузере. Создайте вспомогательную функцию <code>writeSVG</code> для удобного экспорта изображений в файл. <pre><hs>writeSVG :: SVG a => String -> a -> IO ()</hs></pre></task>

      <task>Напишите конструктор <pre><hs>polygon :: Pt -> Int -> Float -> Picture</hs></pre> для правильных многоугольников заданного размера (размер задаётся радиусом описанной окружности). Первый аргумент определяет центр пногоугольника.</task>
      <task>Создайте изображение, показанное на рисунке:
	<p><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>

      <h4>Определение размеров изображения</h4>

      <p>Правильнее было бы не фиксировать размеры поля изображения в SVG-описании, а вычислять его, находя минимальные и максимальные значения координат примитивов. Эта информация будет нужна нам и для размещения изображений друг относительно друга.</p>

      <p>Включим "рамку", обрамляющую изображения, в тип <code>Picture</code> и определим тип для координат рамки:</p>
      <pre><hs>data Picture = Picture (Box, [Primitive])
             deriving Show

type Box = ( (Min Float, Min Float)
           , (Max Float, Max Float) )

instance Bounded Float where
  minBound = -1000
  maxBound = 1000</hs></pre>
      
      <p>В типе <code>Box</code> первая пара задаёт левый нижний угол изображения, а вторая – правый верхний. Для того, чтобы использовать полугруппы <code>Min</code> и <code>Max</code>, экпортируем их (и только их) из библиотеки <code>Data.Semigroup</code>. <pre><hs>import Data.Semigroup (Min(..), Max(..))</hs></pre> Для того, чтобы тип <code>Box</code> стал моноидом, мы определили минимальную и максимальную границы значений координат.</p>

      <p>
	В свою очередь, размеры изображения складываются из размеров примитивов, его составляющих. Значит, имеет смысл определить класс для типов, имеющих размер. Создадим такой класс, а в нём опишем несколько универсально полезных функций, имеющих для всех экземпляров класса определение по умолчанию
	<pre><hs>class Boxed a where
  box :: a -> Box

  width :: a -> Float
  width p = x2 - x1
    where ((Min x1,_),(Max x2,_)) = box p

  height :: a -> Float
  height p = y2 - y1
    where ((_,Min y1),(_,Max y2)) = box p</hs></pre>
	  Для экзепляров класса <code>Boxed</code> достаточно определить функцию <code>box</code>, все остальные выводятся через неё. Так, например определяется экземпляр <code>Boxed</code> для типа <code>Picture</code>:
	  <pre><hs>instance Boxed Picture where
  box (Picture (b,_)) = b</hs></pre>

	  А так можно опредлить размеры для точки:
	  <pre><hs>instance Boxed Pt where
  box (x,y)= ((Min x, Min y), (Max x, Max y))
  width _ = 0
  height _ = 0</hs></pre> 
      </p>   

      <task>Определите экземпляр <code>Boxed Primitive</code>. Используйте моноидальные свойства типа <code>Box</code> при вычислении рамки для примитива <code>Line</code>.</task>

      <task>Надо ли изменять что-либо в определении экземпляра <code>Monoid Picture</code>?</task>
      
      <task>Переопределите конструкторы <code>poiny, line, square, ...</code>
	<p>Для этого имеет смысл определить вспомогательную функцию <code>primitive</code>, которая выполняла бы необходимые вычисления обрамляющей рамки для формируемого изображения:
	  <pre><hs>primitive :: Primitive -> Picture</hs></pre>
      </task>

      <task>Наконец, используйте информацию об обрамляющей рамке изображения для вычисления размеров, указываемых в заголовке SVG-файла. Для этого напишите ещё одну вспомогательную функцию для типа <code>Picture</code>:
	<pre><hs>contents :: Picture -> [Primitive]</hs></pre>
      </task>

      <task>Определите в классе <code>Boxed</code> универсальную функцию <code>corner</code>, возвращающую углы обрамляющей рамки изображения, или примитива
      <pre><hs>corner :: a -> ((Pt, Pt), (Pt, Pt))</hs></pre> и четыре селектора <code>left, right, upper, lower</code>
      так, чтобы можно было бы получить правый нижний угол изображения с помощью выражения:
      <pre><hs> right . lower . corner $ p</hs></pre></task>
      
      <h2>Преобразования изображений</h2>

      <p>
	Научимся изменять изображения. Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги, повороты и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг (или их композицию), а вектор <eq>\vec v</eq> -- параллельный перенос. Преобразование можно выразить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преобразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т.п.) используется именно такая реализация афинных преобразований. 
      </p>

      <p>Приведём три основные вида преобразований:
	<ul>
	  <li> масштабирование осей <eq>x</eq> и <eq>y</eq> с множителями <eq>a</eq> и <eq>b</eq>:
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос вдоль вектора <eq>(x,y)</eq>:
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на угол <eq>\alpha</eq>:
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </p>

      <task>Применять афинные преобразования можно к разным объектам: точкам, примитивам и целым изображениям. Это наводит на мысль о классе <code>Affine</code>, который абстрагирует это свойство и определяет оператор афинных преобразований, обозначим его <code>affine</code>:
      <pre><hs>class Affine a where
  affine :: M Float -> a -> a</hs></pre>

Напишите экземпляры этого класса для типов <code>Pt</code>, <code>Primitive</code> и <code>Picture</code>. 
      </task>

      <p>Композиция афинных преобразований соответствует перемножению матриц. Это значит, что функцию <code>affine</code> можно вынести за скобки: <eqn>\mathrm{affine}\,T_1 \circ \mathrm{affine}\,T_2 \circ ... \circ T_n = \mathrm{affine}\,(T_1 \cdot T_2\cdot ... \cdot T_n).</eqn> Сначала перемножить несколько небольших матриц, а потом применить к большому числу точек выгоднее, чем применять их ко всем точкам по очереди.</p>

      <p>Чтобы воспользоваться этим свойством преобразований нужно отделить применение преобразований от применения функции <code>affine</code>. Это можно сделать, расширив тип <code>Picture</code>, добавив в него явное преобразование изображения:
	<pre><hs>data Picture = Picture (Box, [Primitive])
             | Transform :$: Picture
             deriving Show</hs></pre>
	Это даёт нам возможность перед применением преобразований провести такую оптимизацию:
	<pre>t1 :$: (t2 :$: p) = t1 &lt;&gt; t2 :$: p</pre> Для этого напишем функцию <code>transform</code>

	<pre><hs>transform p = case p of
  Picture p -> Picture p
  (Affine t) :$: Picture p -> affine t (Picture p)
  t1 :$: (t2 :$: p) -> transform $ (t1 &lt;&gt; t2) :$: p</hs></pre>

	Для преобразований определим тип-моноид <code>Transform</code>:
	<pre><hs>data Transform = Transform (M Float) deriving Show

instance Monoid Transform where
  mempty = Transform mempty
  Transform m1 `mappend` Transform m2 = Transform (m1 &lt;&gt; m2)</hs></pre>
      </p>
    
      <task>Тип <code>Picture</code> расширился, значит, определение класса <code>Monoid</code> для него, а также все функции, имеющие тип <code>Picture -> a</code> требуют дополнения. Внесите необходимые исправления, прежде чем двигаться дальше.</task>
    
      <task>Напишите, используя оператор <code>(:$:)</code>, следующие преобразователи изображений:
	<pre><hs>scaleX :: Float -> Picture -> Picture -- масштабирует координату x
scaleY :: Float -> Picture -> Picture -- масштабирует координату y
scale :: Float -> Picture -> Picture -- одинаково масштабирует обе координаты
shift :: Float -> Float -> Picture -> Picture -- параллельный перенос изображения
rotate :: Float -> Picture -> Picture -- поворот на угол, задаваемый в градусах вокруг центра координат
rotateAt :: Pt -> Float -> Picture -> Picture -- поворот вокруг указанной точки</hs></pre>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><hs>let s = square (0,0) 50
s &lt;&gt; rotate 45 s
s &lt;&gt; shift 10 30 s
s &lt;&gt; (scaleX 2 . scaleY 3) s
s &lt;&gt; rotate 60 s
s &lt;&gt; (shift 30 0 . rotate 60) s </hs></pre></task>      

      <p>Обратите внимание на то, как мы "переопределили" по-своему действие оператора композиции <code>(.)</code>  для преобразований. Смысл композиции остался прежним и результат от наших действий не изменится, но изменилась последовательность вычислений и их эффективность. Это очень характерный приём функционального программирования.</p>
      
      <task>Добавьте к типу <code>Primitive</code> конструктор <code>Circle Pt Float</code> для окружности. Пусть, для простоты, при преобразованиях окружности изменяется только положение центра координат. Окружность, которую можно транформировать произвольной матрицей (увеличивать, превращать в эллипс и т.д.) можно построить с помощью функции <code>polygon</code> с большим числом углов.</task>
      
      <task>Преобразователи позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига даёт нам возможность не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании квадрата и прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, задающий абсолютные координаты левого нижнего угла изображения. С его помощью, например, можно было бы построить квадрат с вписанной в него окружностью и расположить его в координатах (100, 100) так:
	<pre><hs>(circle 50 &lt;&gt; rectangle 50 50) `at` (100, 100)</hs></pre></task>
      
      <task>Объясните, каким образом вычисляется следующее выражение:
	<pre><hs>(rotate 30) &lt;&gt; (`at` (40, 40)) $ square 10</hs></pre>
      </task>

      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз, традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат. Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат.</task>

      <task>Постройте картинку, задаваемую выражением:
      	<pre><hs>mconcat $ take 48 $ iterate (rotate 7.5) $ square 50 `at` (25,25)</hs></pre>
	<p align='center'><img src="img/wheel.png"/></p>
      </task>

      <h3>Новые способы комбинирования изображений</h3>
      
      <task>Имея в своём распоряжении композицию изображений и операцию сдвига несложно определить ещё два полезных комбинатора, располагающих изображения рядом вертикально и горизонтально: <code>above</code> и <code>beside</code>. Напишите их определение так, чтобы при результаты были такими, как показано на рисунке:
	<pre><hs>circle 30 `beside` square 40</hs></pre>
	<p align='center'><img src="img/beside.png"/></p>
	<pre><hs>circle 30 `above` square 40</hs></pre>
	<p align='center'><img src="img/above.png"/></p>
      </task>

      <task>Напишите две функции <code>row</code> и <code>column</code>, которые располагали бы список изображений в виде ряда или колонки. Например так:
	<pre><hs>row $ circle <$> [20,40,80,160,80,40,20]</hs></pre>
	<p align='center'><img src="img/row1.png"/></p>
      </task>

      <task>Напишите функцию <code>chart :: Picture -> [Int] -> Picture</code>, которая строила бы диаграммы для списков целочисленных значений, как показано на примере:
	<pre><hs>chart (square 10) [1,2,1,2,3,2,1,4,2,3,6,5,4,3,4,3,1,2,1]</hs></pre>
	<p align='center'><img src="img/chart1.png"/></p>
      </task>

      <task>Напишите функцию <code>barChart :: Double -> [Double] -> Picture</code>, которая строила бы столбчатую диаграмму для числовых списков, используя указанную ширину столбца:
	<pre><hs>scaleY 10 $ barChart 10 [1,2,3,2,3,4,5,4,3,2]</hs></pre>
	<p align='center'><img src="img/chart2.png"/></p>
      </task>

      <h3>Стиль изображений</h3>

      <p>Добавим нашему языку красок! Изменение атрибутов примитивов и изображений можно тоже рассмативать, как преобразование. С геометрическими преобразованиями мы уже разобрались. А можно ли смешивать эти преобразования каким-либо однородным способом? Так, чтобы можно было бы написать и вычислить такое выражение:
	<pre><hs>(rotate 45 . color "red" $ square 20 `at` (20,30)) <> fill "blue" (circle 30)</hs></pre></p>

      
      <p>Кроме того, атрибуты изображения или примитива естественным образом компбинируются: можно задать и цвет линии и цвет заливки, а также прозрачность и все эти свойства "сложатся" у одного изображения. Это наводит на моноидальные мысли.</p>

      
      <p>Итак, наряду с геометрическими преобразованиями, мы имеем ещё один вид преобразований, имеющий моноидальные свойства. Значит, эти преобразования можно объединить в пару и получить обобщённое преобразование-моноид. Изменим определение для типа	<code>Transform</code>:
	<pre><hs>data Transform = Transform (M Float, [Attribute]) deriving Show</hs></pre>

type Attribute  = [(String, String)]

     </div>

   <p id="footer"></p>
  <script src="../lib/postprocessing.js"></script>
 </body>
</html>

