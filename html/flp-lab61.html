<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о моноидах, построим гибкую и расширяемую систему для вывода графики, использующую общедоступный web-интерфейс. Наша система будет представлять собой небольшой встроенный предметно-ориентированный язык (EDSL) для декларативного описания графики. Этот язык будет транслироваться в изображения формата SVG (Scalable Vector Graphics -- это текстовый формат, используемый веб-браузерами и многими векторными графическими редакторами, такими как <sl>Corel Draw</sl>, <sl>Inkscape</sl> и т.п.) или в код на языке JavaScript, так чтобы можно было создавать растровое изображение (форматов JPG, PNG, и т.п.)</p>

      <p>Мы создадим собственный язык для описания изображений, в котором можно задавать элементарные фигуры: ломаные линии, точки, круги...; трасформировать эти фигуры: вращать, масштабировать, перемещать...; и, самое главное, объединять их: накладывать друг на друга, размещать их, указывая что один объект находится сбоку или сверху от другого и т.д. По существу, мы построим алгебру изображений и научимся её вычислять (интерпретировать), получая реальные изображения в доступных форматах.</p>

      <h4>Типы для графических примитивов и изображений</h4>
      <p>Определим тип <code>Primitive</code> для представления двух (для начала) графических примитивов: точек и ломаных линий. Изображение будет представлено типом <code>Picture</code>, объединяющим множество примитивов:</p>
      <pre><hs>type Pt = (Float, Float)
  
data Primitive = Point Pt
               | Line [Pt]
               deriving Show

data Picture = Picture [Primitive] deriving Show</hs></pre>

      <p>Сразу продумаем как можно помбинировать примитивы и изображения. Самый непротиворечивый способ -- накладывать их друг на друга, то есть, изображать на одном холсте.</p>
      <p align='center'>
	<table>
	  <tr>
	    <td><img style="border: dotted 1px gray;" src="img/pmon1.png"/></td>
	    <td><code>&lt;&gt;</code></td>
	    <td><img style="border: dotted 1px gray;" src="img/pmon2.png"/></td>
	    <td>=</td>
	    <td><img style="border: dotted 1px gray;" src="img/pmon3.png"/></td>
	  </tr>
      </table></p>

	
      <p>
	Более того, изображения образуют моноид с операцией наложения (убедитесь мысленно, что наложение ассоциативно и имеет нейтральный элемент). Определим экземпляр класса <code>Monoid</code> для типа <code>Picture</code>:</p>
      <pre><hs>instance Monoid Picture where
  mempty = Picture mempty
  Picture p1 `mappend` Picture p2 = Picture (p1 <> p2)</hs></pre>

      <task>Напишите функции-конструкторы для элементарных фигур:
	<pre><hs>point :: Pt -> Picture
line :: [Pt] -> Picture
square :: Pt -> Float -> Picture
rectangle :: Pt -> Float -> Float -> Picture
triangle :: Pt -> Float -> Float -> Picture</hs></pre>
	У всех этих функций первый аргумент -- это координата нижнего левого угла фигуры, другие агрументы задают ширину и высоту фигуры.
      </task>

      <task>Опишите с помощью имеющихся примитивов простенький рисунок, например, квадратный домик с треугольной крышей.</task>


      <h4>Представление примитивов в формате SVG</h4>
      
      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle rx='x' ry='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <task>SVG -- это текстовый формат. Для того, чтобы упростить генерацию SVG напишите функцию <code>format</code> для форматирования строк по шаблону, последовательно заменяя символ <tt>'_'</tt> строками из списка. Например:
	<pre><ghci> Main> format "_ said: '_'" ["John", "Hello!"]
"John said: 'Hello!'"</ghci></pre>
	<em>Подсказка: воспользуйтесь функцией <code>splitOn</code> из модуля <code>Data.List.Split</code> для того, чтобы разбить форматируемую строку на части, а потом с помощью функции <code>zipWith</code> перемешайте эти части со строками из списка.</em>
      </task>

      <p>Определим собственный класс для того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
  toSVG :: a -> String</hs></pre></p>

      <task>Определите экземпляр этого класса для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG p = case p of
    Point (x,y) -> _
    Line pts -> _</hs></pre>
      </task>
      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='black'&gt;...&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения, прочие параметры задают графические атрибуты, используемые по умолчанию.</p>

      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code>, задав фиксированные размеры изображения, скажем, 400×300.</task>

      <task>Запишите SVG-выражение, описывающее домик в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в веб-браузере. Создайте вспомогательную функцию <code>writeSVG</code> для удобного экспорта изображений в файл. <pre><hs>writeSVG :: SVG a => String -> a -> IO ()</hs></pre></task>

      <task>Напишите конструктор <pre><hs>polygon :: Pt -> Int -> Float -> Picture</hs></pre> для правильных многоугольников заданного размера (размер задаётся радиусом описанной окружности). Первый аргумент определяет центр пногоугольника.</task>
      <task>Создайте изображение, показанное на рисунке:
	<p><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>

      <h4>Определение размеров изображения</h4>

      <p>Правильнее было бы не фиксировать размеры поля изображения в SVG-описании, а вычислять его, находя минимальные и максимальные значения координат примитивов. Эта информация будет нужна нам и для размещения изображений друг относительно друга.</p>

      <p>Включим "рамку", обрамляющую изображения, в тип <code>Picture</code> и определим тип для координат рамки:</p>
      <pre><hs>data Picture = Picture (Box, [Primitive])
             deriving Show

type Box = ((Min Float, Min Float), (Max Float, Max Float))

instance Bounded Float where
  minBound = -1000
  maxBound = 1000</hs></pre>
      
      <p>В типе <code>Box</code> первая пара задаёт левый нижний угол изображения, а вторая – правый верхний. Для того, чтобы использовать полугруппы <code>Min</code> и <code>Max</code>, экпортируем их (и только их) из библиотеки <code>Data.Semigroup</code>. <pre><hs>import Data.Semigroup (Min(..), Max(..))</hs></pre> Для того, чтобы тип <code>Box</code> стал моноидом, мы определили минимальную и максимальную границы значений координат.</p>

      <task>Убедитесь в том, что в определение экземпляра класса <code>Monoid</code> для типа <code>Picture</code> никаких изменений вномить не нужно.</task>

      <task>Переопределите конструкторы <code>poiny, line, square, ...</code>
	<p>Для этого имеет смысл определить две вспомогательные функции <code>findBox</code> и <code>makePicture</code>, которые выполняли бы необходимые вычисления обрамляющей рамки для указанного примитива:
	  <pre><hs>findBox :: Primitive -> Box 
makePicture :: Primitive -> Picture</hs></pre>

	  Используйте моноидальные свойства типа <code>Box</code> при вычислении рамки для примитива <code>Line</code>.

      </task>

      <task>Наконец, используйте информацию об обрамляющей рамке изображения для вычисления размеров, указываемых в заголовке SVG-файла. Для этого напишите ещё несколько простых универсально полезных вспомогательных функций (геттеров для типа <code>Picture</code>):
	<pre><hs>box :: Picture -> (Pt, Pt)
width :: Picture -> Float
height :: Picture -> Float
contents :: Picture -> [Primitive]</hs></pre>
      </task>

      <task>Определите функцию <code>corner</code>, возвращающую углы обрамляющей рамки изображения
      <pre><hs>corner :: Picture -> ((Pt, Pt), (Pt, Pt))</hs></pre> и четыре селектора <code>left, right, upper, lower</code>
      так, чтобы можно было бы получить правый нижний угол изображения с помощью выражения:
      <pre><hs> right . lower . corner $ p</hs></pre></task>
      
      <h3>Преобразования изображений</h3>

      <p>
	Воспользуемся тем, что мы научились перемножать матрицы (см. прошлое занятие). Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги, повороты и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг (или их композицию), а вектор <eq>\vec v</eq> -- параллельный перенос. Преобразование можно выразить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преобразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т.п.) используется именно такая реализация афинных преобразований. 
      </p>

      <p>Приведём три основные вида преобразований:
	<ul>
	  <li> масштабирование осей <eq>x</eq> и <eq>y</eq> с множителями <eq>a</eq> и <eq>b</eq>:
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос вдоль вектора <eq>(x,y)</eq>:
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на угол <eq>\alpha</eq>:
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </p>

      <task>Применять афинные преобразования можно к разным объектам: точкам, примитивам и целым изображениям (можете ли вы сказать, почему это так?). Это наводит на мысль о классе <code>Affine</code>, который абстрагирует это свойство и определяет оператор афинных преобразований, обозначим его <code>($.)</code>:
      <pre><hs>class Affine a where
  ($.) :: Transform -> a -> a

type Transform = M Float</hs></pre>

Напишите экземпляры этого класса для типов <code>Pt</code>, <code>Primitive</code> и <code>Picture</code>. 
      </task>
      
      <task>Напишите преобразователи изображений:
	  <pre><hs>scaleX :: Float -> Transform -- масштабирует координату x
scaleY :: Float -> Transform -- масштабирует координату y
scale :: Float -> Transform -- одинаково масштабирует обе координаты
shift :: Float -> Float -> Transform -- параллельный перенос изображения
rotate :: Float -> Transform -- поворот на угол, задаваемый в градусах вокруг центра координат
rotateAt :: Pt -> Float -> Transform -- поворот вокруг указанной точки</hs></pre>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><hs>let s = square (0,0) 50
s <> rotate 90 $. s
s <> shift 10 30 $. s
s <> (scaleX 2 <> scaleY 3) $. s
s <> rotate 60 $. s
s <> (shift 30 0 <> rotate 60) $. s </hs></pre></task>      
      
      <task>Добавьте к типу <code>Primitive</code> конструктор <code>Circle Pt Float</code> для окружности. Пусть, для простоты, при преобразованиях окружности изменяется только положение центра координат. Окружность, которую можно транформировать произвольной матрицей (увеличивать, превращать в эллипс и т.д.) можно построить с помощью функции <code>polygon</code> с большим числом углов.</task>
      
      <task>Преобразователи позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига даёт нам возможность не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании квадрата и прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, задающий абсолютные координаты левого нижнего угла изображения. С его помощью, например, можно было бы построить квадрат с вписанной в него окружностью и расположить его в координатах (100, 100) так:
	<pre><hs>(circle 50 <> rectangle 50 50) `at` (100,100)</hs></pre></task>
      
      <task>Объясните, каким образом вычисляется следующее выражение:
	<pre><hs>(rotate 30 $.) <> (`at` (40, 40)) $ square 10</hs></pre>
      </task>

      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз, традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат. Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат.</task>

      <task>Постройте картинку, задаваемую выражением:
      	<pre>mconcat $ take 48 $ iterate (rotate 7.5 $.) $ square 50 `at` (25,25)</pre>
	<p align='center'><img src="img/wheel.png"/></p>
      </task>

      <h4>Новые способы комбинирования изображений</h4>
      
      <task>Имея в своём распоряжении композицию изображений и операцию сдвига несложно определить ещё два полезных комбинатора, располагающих изображения рядом вертикально и горизонтально: <code>above</code> и <code>beside</code>. Напишите их определение так, чтобы при результаты были тками, как показано на рисунке:
	<pre>circle 30 `beside` square 40</pre>
	<p align='center'><img src="img/beside.png"/></p>
	<pre>circle 30 `above` square 40</pre>
	<p align='center'><img src="img/above.png"/></p>
      </task>

      <task>Напишите две функции <code>row</code> и <code>column</code>, которые располагали бы список изображений в виде ряда или колонки. Например так:
	<pre>row $ circle <$> [20,40,80,160,80,40,20]</pre>
	<p align='center'><img src="img/row1.png"/></p>
            </task>

      <task>Напишите функцию <code>chart :: Picture -> [Int] -> Picture</code>, которая строила бы диаграммы для списков целочисленных значений, как показано на примере:

	<pre>chart (square 10) [1,2,1,2,3,2,1,4,2,3,6,5,4,3,4,3,1,2,1]</pre>
	<p align='center'><img src="img/chart1.png"/></p>
      
      </task>

      <task>Напишите функцию <code>barChart :: Double -> [Double] -> Picture</code>, которая строила бы столбчатую диаграмму для числовых списков, используя указанную ширину столбца:
	<pre>scaleY 10 $. barChart 10 [1,2,3,2,3,4,5,4,3,2]</pre>
	<p align='center'><img src="img/chart2.png"/></p>
      </task>

      
    </div>

   <p id="footer"></p>
  <script src="../lib/postprocessing.js"></script>
 </body>
</html>

