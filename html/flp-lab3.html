<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/idea.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class="tasks"> 
      <h2>Знакомство со списками</h2>

      <p>Чистые функции можно представить в виде черных ящиков, имеющих один или несколько входов и единственный выход. Если типы входов и выходов согласуются, то две функции можно соединять в цепь. Каждая такая цепь сама будет представлять собой чистую функцию, то есть, черный ящик, пригодный для построения новых и новых цепей.</p>
      
      <p> Легко вообразить однократное вычисление с помощью функциональной программы: на еë вход подаются какие-то допустимые значения, а на выходе получается результат. Если же логика программы-функции предполагает еë многократное исполнение, то на вход можно подать поток данных, получая поток результатов. Мы уже делали это с помощью оператора <code><$></code>, применяя функцию к списку (потоку) данных и преобразуя их в список (поток) результатов.</p>
      
      <p>Если продолжить аналогию с потоками, то можно расширить инструментарий, добавив к преобразователям потоков функции, управляющие ими. Потоки данных можно порождать, соединять, ограничивать, фильтровать и поглощать, превращая в какое-то одно результирующее значение. Именно такое применение функционального подхода к композиции вычислений вы можете встретить в большинстве современных языков ( C#, Python, JavaScript, Ruby и т. д.).</p>
      
      <p>В функциональном программировании роль потока данных выполняют ленивые списки. В ленивом языке Haskell, они совпадают с обыкновенными списками данных.	На этом занятии вы познакомитесь с основным инструментарием работы со списками.</p>

      <p>Рассмотрим, в качестве примера, задачу представления чисел в виде строки из цифр в указанной системе счисления. Императивный алгоритм, записывающий число <eq>n</eq> в указанной системе с основанием <eq>b</eq>, может выглядеть так:</p>

      <pre> def base(n, b):
   if n==0:
     return [0]
   res = []
   while n>0:
     m = mod(n, b) # вычисляем цифру, как остаток от деления n на b.
     res = [m] + res # добавляем цифру
     n = div(n, b) # вычисляем частное от деления n на b
   return res</pre>

      <p>Функциональная программа, которая в точности повторяет логику процедурного решения и реализует такой же вычислительный процесс может быть рекурсивной:</p>

      <pre><hs>toBase b 0 _ = "0"
toBase n b = go n []
  where
    go 0 res = res
    go n res = go (div n b) ((mod n b) : res)</hs></pre>

      <p>Однако можно организовать функциональную программу совсем иначе — в виде потоков данных. Давайте сформулируем декларативное определение результата программы:</p>

      <div class="disclaimer" id="toBase">
	Цифры в позиционной записи числа <eq>n</eq> — это остатки от деления на <eq>b</eq>
	последовательности отличных от нуля частных деления числа <eq>n</eq> на <eq>p</eq>.
      </div>

      <p>Переводя на язык обработчиков списков, получаем такую программу:
	
	<pre><hs>toBase b n = reverse
           $ map (`mod` b)
           $ takeWhile (> 0)
           $ iterate (`div` b) n</hs></pre>

	Или такую, если будем использовать композицию:

	<pre><hs>toBase b = reverse
         . map (`mod` b)
         . takeWhile (> 0)
         . iterate (`div` b)</hs></pre>
      </p>

      <task>Разберитесь, какую роль играет каждый этап обработки данных. Объясните зачем завершает цепочку вычислений функция <code>reverse</code>. Переведите с помощью функции <code>toBase</code> число 2021 в систему с основаниями 2, 3, 5, 16 и 100.</task>

      <task>Выясните с помощью интерпретатора что делает функция <code>replicate</code>. Разберитесь как работают рекурсивное и потоковое определения этой функции:
	<pre><hs>-- рекурсивное определение
replicate1 0 _ = []
replicate1 n x = x : replicate1 (n - 1) x

-- определение, использующее концепцию потоков
replicate2 n x = const x <$> [1..n]</hs></pre>
	Выясните тип этих функций и удостоверьтесь, что они работает верно. Объясните смысл функции <code>const</code> и её тип.</task>

      <task>Выясните и объясните тип функций <code>take</code>, <code>map</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>filter</code>. Вычислите следующие примеры в интерпретаторе и объясните своими словами, что делают эти функции.</task>
      <pre><hs> take 5 [1..10]
 take 5 [1..3]
 take 5 [1..]
 map (+1) [1..5]
 takeWhile (&lt; 5) [1..20]
 dropWhile (&lt; 5) [1..20]
 take 3 $ dropWhile (&lt; 5) [1..]
 filter (\i -> i^2 &lt; 5) [1..20]</hs></pre>
      
      <task>Вычислите в GHCi следующие выражения и объясните что делают функции <code>zip</code>, <code>zipWith</code>, <code>tail</code> и <code>sum</code></task>
      <pre><hs> zip [1..4] [5..8]
 zipWith (+) [1..4] [5..8]
 tail [2,3,5,78]
 zip lst (tail lst) where lst = [1..5]
 sum [2,4,6]</hs></pre>
      
      <task>Выясните экспериментально и с помощью типов что делают функции <code>any</code>, <code>each</code>, <code>and</code>, <code>or</code>. </task>
      
      <h2>Списки и циклические конструкции</h2>
      
      <p>Любая серьёзная программа содержит в себе в том или ином виде повторение вычислительных действий. Для этого используются циклические конструкции. В большинстве процедурных языков программирования для этого используются такие конструкции:
	<ul>
	  <li><code>for</code> для циклов с фиксированным числом повторений и счётчиком;</li>
	  <li><code>foreach</code> для обработки конечных структур;</li>
	  <li><code>while</code> для циклов с неизвестным заранее (возможно, бесконечным) числом итераций.</li>
	</ul>
      </p>
      <p>В функциональном программировании циклические конструкции устроены иначе. В самом общем случае для организации циклов используется рекурсия. Однако на практике явной рекурсии можно избежать, сведя задачу к комбинации простых рекурсивных схем, оперирующих потоками данных:
	<ul>
	  <li><i>источник</i> — порождение потоков данных;</li>
	  <li><i>преобразователь</i> — последовательное преобразование или фильтрация всех элементов потока;</li>
	  <li><i>ограничитель</i> потока</li>
	  <li><i>слияние</i> потоков</li>
	  <li><i>сток</i> — свёртка или аггрегация потока.</li>
	</ul>
      </p>

      <task>Определите какие схемы реализуют следующие фукции Haskell:
	<pre><hs> [1 .. 13]
 sum      
 map
 takeWhile
 [1 ..]
 length
 iterate
 product
 zipWith
 dropWhile
 filter
 zip
 or
 any</hs></pre></task>

      <task>Даны два целых числа <eq>a</eq> и <eq>b</eq>. Найти сумму квадратов всех целых чисел от <eq>a</eq> до <eq>b</eq> включительно. Задачу можно разбить на три части:
	<ul>
	  <li>создайте поток чисел от <eq>a</eq> до <eq>b</eq>;</li>
	  <li>преобразуйте этот поток в поток квадратов чисел;</li>
	  <li>просуммируйте полученный поток.</li>
	</ul>
      </task>     

      
      <task> Вычислите приближение числа <eq>e</eq> в виде частичной суммы ряда:
	<eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
	с точностью до 14 знаков после запятой.
	<details><summary>Возможная схема решения</summary>
	<ul>
	  <li>определите функцию, вычисляющую факториал от n, как произведение ряда натуральных чисел от 1 до n; </li>
	  <li>сгенерируйте последовательность чисел от 0 до бесконечности;</li>
	  <li>превратите её в последовательность значений <eq>1/i!</eq>;</li>
	  <li>ограничьте полученную последовательность элементами, превышающими указанную <eq>10^{-14}</eq> (используйте функцию <code>takeWhile</code>);</li>
	  <li>просуммируйте последовательность.</li>
	</ul></details>
	Оцените количество операций, необходимых для вычисления этой функции.
      </task>

      <task>Вычислите с помощью частичного суммирования или перемножения ряда число <eq>\pi</eq>.</task>
      
      <task>Напишите функцию <code>count p lst</code>, которая считает сколько раз в списке встречается элемент, удовлетворяющий предикату <code>p</code>. Как с её помощью подсчитать в строке количество цифр?</task>

      <task>Найдите сколько точек на целочисленной сетке попадают в круг указанным целочисленным радиусом. Оцените число <eq>\pi</eq> с помощью круга радиусом 100. Здесь для каждого элемента списка следует создать и обработать ещё один список, таким образом реализуется вложенный цикл.<br/> Посмотрите в справке о <a href ='haskell-ref.html#Генераторы списков' target='_blank'>генерации списков</a>.</task>

      <task>Решите в одну строчку. Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробeг на 10% от пробега предыдущего дня. Определите, в какой день лыжник должен будет пробежать 100 км. Найдите в какой день суммарный пробег за все дни превысит 100 км. </task>

      <task><a name="Floyd"></a>Наряду с задачей FizzBuzz для обучения программированию и для собеседований часто используется ещё одна несложная задача: треугольник Флойда. Она состоит в выводе на печать такой последовательности строк:<pre>1
2 3
4 5 6
7 8 9 10
...</pre>

	Решите эту задачу на Haskell доступными вам способами (рекурсия, генераторы списков и т. п.).
	
      <details><summary>Вариант решения</summary>
	<pre><hs>floyd = (\i -> [arsum i + 1 .. arsum (i + 1)]) <$> [1 ..]
  where tr n = n*(n - 1) `div` 2</hs></pre>
	<p>Здесь <code>arsum n</code> — сумма арифметической прогрессии <eq>1,2,..,n</eq></p>
      </details>

      </task>
      
      <task>Для повышения точности численного интегрирования (см. занятие 1),  интервал интегрирования разбивается на несколько маленьких интервалов и на каждом из них интеграл вычисляется методом Гаусса, после чего результаты суммируются. Напишите функцию <code>integrate f mesh</code>, вычисляющую интеграл таким способом, используя задаваемую пользователем сетку <code>mesh</code>. <br/>

	Сравните получаемую точность интегрирования для различного числа разбиений на примере <eqn>\int_0^{20} \sin x\,dx = 1 - \cos\,20.</eqn></task>


      <h2>Данные и коданные</h2>

      <p>В большинстве парадигм программирования списки играют роль данных, которые обрабатывает программа. В функциональном программировании это тоже, как правило, так. Однако здесь есть возможность порождать список (поток) и "поглощать" его в одной программе и даже в одной функции. По существу, накакого списка в памяти так и не создаётся, он существует только в коде программы. Данные такого рода называются <strong>коданными</strong> (codata) — то есть сущностью, дуальной данным.</p>


      <task>Известно, что коэффициенты при всех степенях в разложении полинома <eq>(a + b)^n</eq> можно получить с помощью треугольника Паскаля. Треугольник Паскаля — бесконечная таблица, имеющая треугольную форму.
	<p><img src="img/PascalTriangle.png" alt="" width='40%'/><img src="img/imgFig1.gif" alt="" width='60%'/></p>
	<ul>
	  <li>Определите функцию <code>pascalStep</code>, которая для любой строки в треугольнике строит следующую строку, складывая почленно строку саму с собой, сдвинутой на один элемент. Проверьте правильность её работы на простых примерах.</li>
	  <li>Определите с помощью <code>pascalStep</code> бесконечную последовательность строк треугольника Паскаля <code>pascal</code>.</li>
	  <li> Найдите с помощью оператора <code>!!</code> коэффициенты разложения <eq>(a+b)^{15}</eq>.</li>
	  <li> Определите функцию <code>binomial n k</code>, как коэфициент при <eq>x^k</eq> в разложении <eq>(1+x)^n</eq> и сравните с биномиальным коэффициентом явно вычисленным по формуле: <eqn> C_{n}^{k} = \frac {n!}{k!(n-k)!}.</eqn>
	  <li>  Найдите коэффициент при <eq>x^{10}</eq> в разложении <eq>(1+x)^{10000}</eq>.</li>
	  <li>После этого вычислите в этом же разложении коэффициент при <eq>x^{9}</eq> и <eq>x^{11}</eq>. Обратите внимание на разницу в скорости вычисления коэффициентов и попробуйте её объяснить.</li>
	  <li>Покажите, что сумма <eq>n</eq>-ного ряда треугольника Паскаля равна <eq>2^n</eq>.</li>
      </ul></task>

      <p>Последовательность <code>pascal</code>, образованная рядами треугольника Паскаля, является не данными, а коданными, поскольку она никогда не появляется в памяти целиком. Каждый её элемент порождается по мере необходимости и тут же используется для вычислений.</p>

      <p>В роли коданных могут выступать не только линейные потоки. Принцип замены явной рекурсии порождением и обработкой индуктивных данных может быть обобщен и его можно применить к другим индуктивным структурам. Например, деревьям.</p>
      <p>Покажем это на примере рекурсивной функции <code>bisection</code>, кторую мы писали на прошлом занятии. Вспомним реализуемый ею алгоритм:
	<ul>
	  <li> задан отрезок <eq>(a,b)</eq>;</li>
	  <li> задано условие <eq>p</eq>, которое в некоторой точке на отрезке меняет значение (например, меняется знак числовой функции); 
	  <li> если <eq>p(a) = p(b)</eq>, считаем, что искомой точки на отрезке нет;
	  <li> если отрезок достаточно мал, решением является его средняя точка;
	  <li> в противном случае решение находится либо в правой, либо в левой половине отрезка.
	  </ul></p>

      <p>Можно выполнить его полную декомпозицию, используя в качестве коданных бесконечное дерево разбиений интервала:
      <ul>
	<li>Порождаем бесконечное дерево вложенных интервалов, деля их пополам.</li>
	<li>В этом дереве отыскиваем путь, соответствующий смене значения тестовой функции, представляющий собой бесконечную последовательность уменьшающихся интервалов.</li>
	<li>Отыскиваем в этой последовательности первый достаточно малый интервал.</li>
      </ul></p>

      <p>Для бесконечного дерева можно создать такой тип:
<pre><hs>data Tree a = Node a (Tree a) (Tree a) deriving Show</hs></pre>
Он параметризован типом <code>a</code>, так что наше дерево может содержать любые данные. Порождать это дерево можно такой функцией:
      <pre><hs>tree :: (a -> (a, a)) -> a -> Tree a
tree f x = let (a, b) = f x
           in Node x (tree f a) (tree f b)</hs></pre>

      А выделять в нём путь — с помощью какого-то условия так:
      
      <pre><hs>path :: (a -> Bool) -> Tree a -> [a]
path p (Node a t1 t2) =
  if p a then [] else [a] ++ path p t1 ++ path p t2 
</hs></pre>

      Наконец, мы готовы написать альтернативный вариант функции <code>bisection</code>:
      <pre><hs>bisection'
  :: Eq a2 =>
     (Double -> a2) -> (Double, Double) -> Maybe Double
bisection' p =
  (uncurry mean <$>) .
  find (\(a, b) -> abs (b - a) < 1e-11) .
  path (\(a, b) -> p a == p b) .
  tree (\(a, b) -> let c = mean a b in ((a,c),(c,b)))
</hs></pre>
      Здесь мы используем функцию <code>find</code> из библиотеки <code>Data.List</code> и функцию <code>uncurry</code>, которая функцию двух аргументов превращает в функцию от пары.</p>

      <p>Характерная особенность такого подхода состоит в том, что решение задачи сводится к комбинации универсальных инструментов: ни одна из функций <code>find</code>, <code>path</code> или <code>tree</code> изначально ничего "не знает" о том, какую именно задачу мы решаем. О конкретной постановке задачи они узнают от переданных им аргументов — лямбда-функций.</p>
      
      <task>Убедитесь в том, что <code>bisection'</code> работает точно также как и функция, реализованная нами на прошлом занятии.</task>
      
      <p>Это решение мы рассмотрели скорее для расширения сознания. Метод бисекции проще реализуется простой рекурсией. Однако, подобная декомпозиция становится по-настощему полезной при работе со сложными многоступенчатыми алгоритмами, такими как генерация сеток для численного моделирования или поиск оптимального хода в шахматах.</p>

    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

