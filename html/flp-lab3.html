<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
 <div class="tasks"> 
      <h2>Знакомство со списками</h2>

      <p>Списки в Haskell играют более фундаментальную роль, чем просто тип данных или контейнер. С их помощью выражаются циклические конструкции.</p>

      <task>Выведите на печать числа от 1 до 10 с помощью команды:</task>
      <pre><ghci><l></l> mapM_ print [1..10]</ghci></pre>

      <task>Выясните с помощью интерпретатора что делает функция <code>replicate</code> </task>

      <task>Напишем своё определение функции <code>replicate'</code>, как указано в примере.
	<pre><hs>replicate' n x = const x <$> [1 .. n]</hs></pre>
	 Выясните тип этой функции и удостоверьтесь, что она работает верно. Объясните смысл функции <code>const</code> и её тип.</task>

      <task>Выясните и объясните тип функций <code>take</code>, <code>map</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>filter</code>. Вычислите следующие примеры в интерпретаторе и объясните своими словами, что делают эти функции.</task>
      <pre><ghci>take 5 [1..10]
take 5 [1..3]
take 5 [1..]
map (+1) [1..5]
takeWhile (&lt; 5) [1..20]
dropWhile (&lt; 5) [1..20]
take 3 $ dropWhile (&lt; 5) [1..]
filter (\i -> i^2 &lt; 5) [1..20]</ghci></pre>

      
	<task>Вычислите в GHCi следующие выражения и объясните что делают функции <code>zip</code>, <code>zipWith</code>, <code>tail</code> и <code>sum</code></task>
	<pre><ghci>zip [1..4] [5..8]
zipWith (+) [1..4] [5..8]
tail [2,3,5,78]
zip lst (tail lst) where lst = [1..5]
sum [2,4,6]</ghci></pre>
	
	<task> Есть ещё одна очень полезная функция, которая порождает списки — <code>iterate</code>. Посмотрите на её тип. Поэкспериментируйте с ней на нескольких примерах:</task> 
  <pre><ghci>take 10 $ iterate (*2) 1
take 5 $ iterate cos 0.3
iterate (`div` 2) 17</ghci></pre>

	<task>Выясните экспериментально и с помощью типов что делают функции <code>any</code>, <code>each</code>, <code>and</code>, <code>or</code>. </task>
	
      <h2>Списки и циклические конструкции</h2>
	
<p>Любая серьёзная программа содержит в себе в том или ином виде повторение вычислительных действий. Для этого используются циклические конструкции. В большинстве процедурных языков программирования для этого используются такие конструкции:
  <ul>
    <li><code>for</code> для циклов с фиксированным числом повторений и счётчиком;</li>
    <li><code>foreach</code> для обработки конечных структур;</li>
    <li><code>while</code> для циклов с неизвестным заранее (возможно, бесконечным) числом итераций.</li>
  </ul>
</p>
<p>В функциональном программировании циклические конструкции устроены иначе. В самом общем случае для организации циклов используется рекурсия. Однако на практике явной рекурсии можно избежать, сведя задачу к комбинации простых рекурсивных схем, оперирующих потоками данных:
  <ul>
    <li><i>источник</i> — порождение потоков данных;</li>
    <li><i>преобразователь</i> — последовательное преобразование или фильтрация всех элементов потока;</li>
    <li><i>ограничитель</i> потока</li>
    <li><i>слияние</i> потоков</li>
    <li><i>сток</i> — свёртка или аггрегация потока.</li>
  </ul>
</p>

<task>Определите какие схемы реализуют фукции Haskell
  <pre><ghci>[1..3]
sum      
map
takeWhile
[1..]
length
iterate
product
zipWith
dropWhile
filter
zip
or
any</ghci></pre></task>

<task>Даны два целых числа <eq>a</eq> и <eq>b</eq>. Найти сумму квадратов всех целых чисел от <eq>a</eq> до <eq>b</eq> включительно. Задачу можно разбюить на три части:
  <ul>
    <li>создайте поток чисел от <eq>a</eq> до <eq>b</eq></li>
    <li>преобразуйте этот поток в поток квадратов чисел;</li>
    <li>просуммируйте полученный поток.</li>
  </ul>
</task>     

<task>Найти среднее геометрическое всех целых чисел от а до b.</task>
	
<task> Вычислите приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
	  с точностью до 14 знаков после запятой. Для этого
<ul>
  <li>определите функцию факториал от n, как произведение натуральных чисел 1,2,.. n; </li>
  <li>сгенерируйте последовательность чисел от 0 до бесконечности;</li>
  <li>превратите её в последовательность значений <eq>1/i!</eq>;</li>
  <li>ограничьте полученную последовательность элементами, превышающими указанную <eq>10^{-14}</eq> (используйте функцию <code>takeWhile</code>);</li>
  <li>просуммируйте последовательность.</li>
</ul>
Оцените количество операций, необходимых для вычисления этой функции.
	</task>

	<task>Напишите функцию <code>count p lst</code>, которая считает сколько раз в списке встречается элемент, удовлетворяющий предикату <code>p</code>. Как с её помощью подсчитать в строке количество цифр?</task>

	<task>Найдите сколько точек на целочисленной сетке попадают в круг указанным целочисленным радиусом. Оцените число <eq>\pi</eq> с помощью круга радиусом 100. Здесь для каждого элемента списка следует создать и обработать ещё один список, таким образом реализуется вложенный цикл.<br/> Посмотрите в справке о <a href ='haskell-ref.html#Генераторы списков' target='_blank'>генерации списков</a>.</task>

	<task>Решите в одну строчку. Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробeг на 10% от пробега предыдущего дня. Определите, в какой день лыжник должен будет пробежать 100 км. Найдите в какой день суммарный пробег за все дни превысит 100 км. </task>

	<task>Известно, что коэффициенты при всех степенях в разложении полинома <eq>(a + b)^n</eq> можно получить с помощью треугольника Паскаля. Треугольник Паскаля — бесконечная таблица, имеющая треугольную форму.
	  <p><img src="img/PascalTriangle.png" alt="" width='40%'/><img src="img/imgFig1.gif" alt="" width='60%'/></p>
	  <ul>
	    <li>Определите функцию <code>pascalStep</code>, которая для любой строки в треугольнике строит следующую строку, складывая почленно строку саму с собой, сдвинутой на один элемент. Проверьте правильность её работы на простых примерах.</li>
	    <li>Определите с помощью <code>pascalStep</code> бесконечную последовательность строк треугольника Паскаля.</li>
	    <li> Найдите с помощью оператора <code>!!</code> коэффициенты разложения <eq>(a+b)^{15}</eq>.</li>
	    <li>Найдите коэффициент при <eq>x^{10}</eq> в разложении <eq>(1+x)^{10000}</eq>.</li>
	    <li>После этого вычислите в этом же разложении коэффициент при <eq>x^{9}</eq> и <eq>x^{11}</eq>. Обратите внимание на разницу в скорости вычисления коэффициентов и попробуйте её объяснить.</li>
	    <li>Покажите, что сумма <eq>n</eq>-ного ряда треугольника Паскаля равна <eq>2^n</eq>.</li>
	</ul></task>
	
	<task>Для повышения точности численного интегрирования (см. занятие 1),  интервал интегрирования разбивается на несколько маленьких интервалов и на каждом из них интеграл вычисляется методом Гаусса, после чего результаты суммируются. Напишите функцию <code>integrate f mesh</code>, вычисляющую интерал таким способом используя сетку <code>mesh</code>. <br/>

      Сравните получаемую точность интегрирования для различного числа разбиений на примере <eqn>\int_0^{20} \sin x\,dx = 1 - \cos\,20.</eqn></task>
	
   </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

