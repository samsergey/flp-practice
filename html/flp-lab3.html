<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/idea.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <h2>Типы в языке Haskell</h2>

    <div class='tasks'>

      <task>Опишите тип для представления произвольной двухполюсной электрической цепи, которая может состоять из сопротивлений (с номиналами типа <code>Double</code> и допускает последовательное или параллельное соединение элементов цепи.</task>

<pre><hs>data Circuit a = R Double
               | Par Circuit Circuit
               | Seq Circuit Circuit deriving Show</hs></pre>

      <p>Например:</p>

      <pre><hs> R 20 -- сопротивление номиналом 20
 R 100 `Seq` R 10 -- последовательное соединение двух сопротивлений
 R 100 `Par` R 10 -- параллельное соединение двух сопротивлений</hs></pre>      

      <task>Опишите с помощью этих конструкторов типов цепь, показанную на рисунке:<p align='center'><img src="img/circ1.png" alt="" width='40%'/><br/>Цепь 1.</p></task>

      <task>Напишите функцию <code>resistance :: Circuit -> Double</code>, которая вычисляла бы суммарное сопротивление произвольной двухполюсной цепи. При этом используются следующие формулы: при последовательном подключении элементов складываются значения сопротивлений,  а при параллельном подключении складываются проводимости:<eqn>R_\text{seq} = R_1 + R_2,\quad\frac{1}{R_\text{par}} = \frac{1}{R_1} + \frac{1}{R_2}.</eqn> Рассчитайте с помощью функции <code>resistance</code> сопротивление цепи 1.</task>

      <task>Пусть в указанной выше схеме сопротивление номиналом 11 является переменным. Параметризуйте схему, превратив её в функцию от величины этого споротивления. Определите при каком номинале этого элемента сопротивление всей цепи будет равно 5.</task>

      <task>Добавьте в тип <code>Circuit</code> элемент, соответствующий ключу. При этом замкнутому состоянию ключа пусть соответствует нулевое, а разомкнутому -- бесконечное сопротивление (его можно получить с помощью выражения <code>1/0</code>). Поместите вместо элементов с номиналами 11 и 7 ключи и вычислите сопротивление цепи при различных сочетаниях их состояний.</task>

      <task>Определите функцию <code>connect :: Circuit -> Bool</code>, которая бы возвращала ответ на вопрос: замкнута цепь или нет. Проверьте работу этой функции при различных сочетаниях состояний ключей.</task>

      <hr/>
      
      <p>Использование бесконечного значения для представления разомкнутой цепи чревато неприятностями, не очень красиво и не позволит работать с не вещественными числами. Правильным и идиоматичным путём будет определить отдельный тип, описывающий состояние цепи в электротехнических терминах.</p>

      <task>Определите тип <code>Resistance</code>, который может представлять разомкнутую цепь <code>Break</code>, цепь замкнутую накоротко <code>Short</code> и цепь, обладающую конечным сопротивлением <code>Value Double</code>.</task>
 
      <task>Для типа <code>Resistance</code> определите операции параллельного <code>(&lt;||&gt;)</code> и последовательного <code>(&lt;&&&gt;)</code> соединения. И переопределите функцию <code>resistance</code> так чтобы она возвращала тип <code>Resistance</code>. Напишите короткое определение функции <code>connect</code>, использующее результат функции <code>resistance</code>.</task>

      <hr/>
      
      <p>При расчёте электрических цепей переменного тока роль сопротивления играет импеданс, который выражается комплексным числом. Для цепей переменного тока следует добавить реактивные элементы: ёмкости и индуктивности. Импеданс ёмкости <eq>C</eq> вычисляется по формуле <eq>1/(i \omega C)</eq>, для индуктивности <eq>L</eq> импеданс равен <eq>i\omega L</eq>, а для сопротивления импеданс равен значению сопротивления. Импедансы складываются при параллельном и последовательном соединении по тем же правилам, что и активные сопротивления. </p>

      <task>Подключите к программе модуль <code>Data.Complex</code>. Параметризуйте тип <code>Resistance</code> так чтобы кроме типа <code>Double</code> он мог содержать в себе произвольные типы. Добавьте в тип <code>Circuit</code> представление для ёмкости и индуктивности -- типы <code>C Double</code> и <code>L Double</code>. Опишите с помощью этого типа цепь 2, показанную на рисунке:<p align='center'><img src="img/circ2.jpg" alt="" width='40%'/><br/>Цепь 2.</p></task>

      <task>Дополните определение функции <code>resistance</code> так, чтобы она могла обрабатывать ёмкости и индуктивности. Для постоянного тока конденсаторы соответствуют разрыву цепи, а катушки индуктивности -- короткому замыканию. Вычислите активное сопротивление цепи 2.</task>

      <task>Дайте определение функции <code>impedance</code> и вычислите импеданс для цепи 2. В полученном комплексном числе действительная часть должна быть равна активному сопротивлению цепи, а мнимая -- реактивному (волновому).</task>

      <hr/>
      
      <p>Мы построили тип, описывающий <em>внутреннюю структуру</em> результата -- сопротивления. Это не просто число, оно может принимать различные по смыслу значения, которые по-разному комбинируются друг с другом. Если внимательно посмотреть на определения операторов <code>(&lt;||&gt;)</code> и <code>(&lt;&&&gt;)</code>, то можно заметить их сходство с логическими операторами над булевыми значениями. Если исключить из рассмотрения величины <code>Value</code>, то получатся точные определения логических операций И и ИЛИ, где роль <code>True</code> и <code>False</code> играют <code>Short</code> и <code>Break</code>, соответственно. Такое совпадение структур позволяет использовать то, что мы знаем о логике. В частности, закон де Моргана.</p>
      <eqn>\neg (A \vee B) = \neg A \wedge \neg B</eqn>
      
      <p>Осталось определить понятие отрицания для сопротивления. Это проводимость, величина, обратная сопротивлению. Ведь при параллельном соединении складываются именно проводимости, значит наша догадка верна!</p>

      <task>Определите функцию <code>inv</code>, которая преобразовывала бы сопротивления в проводимости и обратно. С её помощью закона де Моргана, определите операцию <code>(&lt;||&gt;)</code> через <code>(&lt;&&&gt;)</code> и <code>inv</code>.</task>

      <task>Рассчитайте импеданс цепи 2 для частот в диапазоне от 1Гц до 1 ГГц. Обратите внимание на то как изменяются действительная и мнимая части импеданса. Попробуйте объяснить эти инзменения.</task>

      <task>Напишите две функции: <code>resistanceToBool :: Resistance a -> Bool</code> и <code>boolToResistance :: Bool -> Resistance a</code>, которые преобразовывали значения двух типов, которые мы признали подобными, друг в друга.</task>

      <h2>Функторы</h2>

      <p>Типы в Haskell -- это больше чем описание данных. Это и описание логической или математической структуры образуемой данными. Мы увидели это на примере типа для чисел, которые могут иметь особые нечисловые значения. Такой подход универсален и наиболее часто встречающийся пример -- тип <code>Maybe a</code>, говорящий о том, что величина значения типа <code>a</code> может быть неопределена.</p>
      <task>Посмотрите информацию о типе <code>Maybe</code>  с помощью команды <tt>:i</tt>. Посмотрите, как работает функция <code>find</code>, отыскивающая элемент с заданными свойствами в списке.</task>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите функции <code>listToMaybe :: [a] -> Maybe a</code> и <code>maybeToList :: Maybe a -> [a]</code>.</task>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <code>:t (&lt;$&gt;)</code>. Посмотрите (с помощью команды <code>:i</code> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>
      
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с типами <code>Maybe a</code>  и <code>[a]</code>. Посмотрите на то, как действуют операторы <code><|></code> и <code><*></code>, вычислив в GHCi следующие выражения. Попробуйте вместо <code>Maybe a</code> использовать тип <code>[a]</code>. Объясните своими словами, для чего нужны операторы <code><$></code>, <code><|></code>, <code><*></code></task>
      <pre><ghci>Nothing <|> Just 5
Just 3 <|> Just 5
Just 3 <|> Nothing
Nothing <|> Nothing
Nothing <*> Just 5
Just (4*) <*> Just 5
Just (2*) <*> Nothing
(+) <&> Just 3 <*> Just 7
(+) <&> Nothing <*> Just 7
(+) <&> Just 3 <*> Nothing</ghci></pre>    

      <task>Рассмотрим задачу отыскания на числовой оси точек, в которых изменяется какое-либо условие. Универсальным, надёжным и достаточно быстрым является метод деления отрезка пополам. Напишите функцию <code>bisection p a b</code>, имеющую следующий тип:
      <pre><def>bisection :: Eq t => (Double -> t) -> Double -> Double -> Maybe Double</def></pre>
      Здесь функция <code>p :: Eq b => Double -> t</code> определяет условие, которое должно изменяться в искомой точке, а точки <code>a</code> и <code>b</code> определяют отрезок на котором точка ищется. Метод состоит в следующем:
      <ul>
	<li> Если на границах отрезка условие принимает одинаковые значения, считаем, что искомой точки на отрезке нет;
	<li> если отрезок достаточно мал, решением является его средняя точка;
	<li> в противном случае решение находится либо в правой, либо в левой половине отрезка (Для отношения "либо" используйте оператор <code>(&lt;|&gt;)</code>.  
      </ul>
      Продумайте условие при котором отрезок можно считать малым, учитывая, что тип <code>Double</code> представляет числа с плавающей точкой.
      
      </task>

      <task>Проверьте правильность работы функции на следующих примерах:
	<pre><hs> bisection (\x -> x < 2) 1 3
 bisection (\x -> x < 2) 0 1
 bisection (\x -> x^2 < 2) 1 2
 (^2) <$> bisection (\x -> x^2 < 2) 1 2
 bisection (\x -> cos x > 1 - 1/x) 0 2
 bisection (\x -> 1/x > 0) -1 2
 bisection (\x -> isNaN (sqrt (3 - x^2))) 0 2 </hs></pre>
      </task>

      <task>Упростите интерфейс функции <code>bisection</code> так чтобы для решения задачи можно было бы задавать не отрезок, а начальную точку для поиска ближайшего корня. Начиная с этой точки можно двигаться вправо с увеличивающимся шагом до тех пор, пока либо не будет встречен корень, либо пока точка не уйдёт слишком далеко. Реализуйте этот алгоритм в виде функции <code>findRoot</code>.
	<pre><hs>findRoot p x = go x 1e-5
  where
    go x dx | abs x > 1e16 = empty
            | otherwise = bisection p x (x+dx) <|> _</hs></pre>

	Проверьте правильность её работы на нескольких примерах.</task>
      
      <task>В цепях переменного тока реактивное сопротивление может быть положительным или отрицательным, этот знак определяет сдвиг сигнала по фазе. Однако особый интерес представляет частота при которой реактивное сопротивление обращается в ноль. Она соответствует резонансу -- собственной частоте цепи. Определите резонансную частоту цепи 2, как частоту при которой мниная часть импеданса меняет знак.</task>
      
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>empty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code>. Замените в определении <code>bisection</code> функцию <code>Just</code> на <code>pure</code>, а значение <code>Nothing</code> на <code>empty</code>. Убедитесь в том, что функция работает верно.</task>
      
      <task>Сотрите определение типа для функции <code>bisection</code> и посмотрите какой тип будет выведен компилятором. Объясните какие ограничения накладываются на типы оргументов этой функции и почему.</task>
      <task>Теперь функции <code>bisection</code> и <code>findRoot</code> работают с любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code> и т.д. 

<pre><hs> bisection (\x -> x < 2) 1 3 -- IO
 findRoot (\x -> x^2 < 2) 1 :: Maybe Double
 findRoot (\x -> x^2 < 2) 1 :: [Double]
 findRoot (\x -> x^2 < 2) 1 :: [Double]
 findRoot (\x -> cos x > 1 - 1/x) 1
 take 3 $ findRoot (\x -> cos x > 1 - 1/x) 1
 take 4 $ concat $ findRoot (\x -> tan x < x) <$> [1..] </hs></pre>

      </task>
    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

