<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
 <div class="tasks"> 
      <h2>Знакомство со списками</h2>

      <p>Чистые функции можно представить в виде черных ящиков, имеющих один или несколько входов и единственный выход. Если типы входов и выходов согласуются, то две функции можно соединять в цепь. Каждая такая цепь сама будет представлять собой чистую функцию, то есть, черный ящик, пригодный для построения новых и новых цепей.</p>
	
      <p> Легко вообразить однократное вычисление с помощью функциональной программы: на еë вход подаются какие-то допустимые значения, а на выходе получается результат. Если же логика программы- функции предполагает еë многократное исполнение, то на вход можно подать поток данных, получая поток результатов. Мы уже делали это с помощью оператора <code><$></code>, применяя функцию к списку (потоку) данных и преобразуя их в список (поток) результатов.</p>
	  
<p>Если продолжить аналогию с потоками, то можно расширить инструментарий, добавив к преобразователям потоков функции, управляющие ими. Потоки данных можно порождать, соединять, ограничивать, фильтровать и поглощать, превращая в какое-то одно результирующее значение. Именно такое применение функционального подхода к композиции вычислений вы можете встретить в большинстве современных языков ( C#, Python, JavaScript, Ruby и т. д.).
В функциональном программировании роль потока данных выполняют ленивые списки. В ленивом языке Haskell, они совпадают с обыкновенными списками данных.
На этом занятии вы познакомитесь с основным инструментарием работы со списками.</p>


<p>Рассмотрим, в качестве примера, задачу представления чисел в виде строки из цифр в указанной системе счисления. Императивный алгоритм, записывающий число n в указанной системе с основанием b, может выглядеть так:</p>

  <pre>def base(n, b):
  if n==0:
    return [0]
  res = []
  while n>0:
    m = mod(n, b) # вычисляем цифру, как остаток от деления n на b.
    res = [m] + res # добавляем цифру
    n = div(n, b) # вычисляем частное от деления n на b
  return res
</pre>

<p>Функциональная программа, которая в точности повторяет логику процедурного решения и реализует такой же вычислительный процесс может быть рекурсивной:</p>

  <pre><hs>base 0 _ = "0"
base n b = go n []
  where
    go 0 res = res
    go n res = go (div n b) ((mod n b) : res)</hs></pre>

      <p>Однако можно организовать функциональную программу совсем иначе -- в виде потоков данных. Давайте сформулируем декларативное определение результата программы:</p>

<div class="disclaimer">
  цифры в позиционной записи числа <eq>n</eq> -- это остатки от деления на b последовательности отличных от нуля частных деления числа <eq>n</eq> на <eq>p</eq>.
</div>

    <p>Переводя на язык обработчиков списков , получаем такую программу:
    
      <pre><hs>base b n = reverse $
           map (`mod` b) $
           takeWhile (> 0) $
           iterate (`div` b) n</hs></pre>


    Или, используя композицию:

      <pre><hs>base b = reverse .
          map (`mod` b) .
          takeWhile (> 0) .
          iterate (`div` b)</hs></pre>
</p>

<task>Разберитесь, какую роль играет каждый этап обработки данных. Объясните зачем завершает цепочку вычислений функция reverse. Переведите с помощью функции base число 2021 в систему с основаниями 2, 3, 5, 16 и 100.</task>

      <task>Выясните с помощью интерпретатора что делает функция <code>replicate</code>. Напишем рекурсивное и потоковое определения этой функции:
	<pre><hs>replicate1 0 _ = []
replicate1 n x = x : replicate1 (n-1) x
	    
replicate2 n x = const x <$> [1..n]</hs></pre>
	 Выясните тип этих функций и удостоверьтесь, что они работает верно. Объясните смысл функции <code>const</code> и её тип.</task>

      <task>Выясните и объясните тип функций <code>take</code>, <code>map</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>filter</code>. Вычислите следующие примеры в интерпретаторе и объясните своими словами, что делают эти функции.</task>
      <pre><ghci>take 5 [1..10]
take 5 [1..3]
take 5 [1..]
map (+1) [1..5]
takeWhile (&lt; 5) [1..20]
dropWhile (&lt; 5) [1..20]
take 3 $ dropWhile (&lt; 5) [1..]
filter (\i -> i^2 &lt; 5) [1..20]</ghci></pre>
      
	<task>Вычислите в GHCi следующие выражения и объясните что делают функции <code>zip</code>, <code>zipWith</code>, <code>tail</code> и <code>sum</code></task>
	<pre><ghci>zip [1..4] [5..8]
zipWith (+) [1..4] [5..8]
tail [2,3,5,78]
zip lst (tail lst) where lst = [1..5]
sum [2,4,6]</ghci></pre>
	
	<task>Выясните экспериментально и с помощью типов что делают функции <code>any</code>, <code>each</code>, <code>and</code>, <code>or</code>. </task>
	
      <h2>Списки и циклические конструкции</h2>
	
<p>Любая серьёзная программа содержит в себе в том или ином виде повторение вычислительных действий. Для этого используются циклические конструкции. В большинстве процедурных языков программирования для этого используются такие конструкции:
  <ul>
    <li><code>for</code> для циклов с фиксированным числом повторений и счётчиком;</li>
    <li><code>foreach</code> для обработки конечных структур;</li>
    <li><code>while</code> для циклов с неизвестным заранее (возможно, бесконечным) числом итераций.</li>
  </ul>
</p>
<p>В функциональном программировании циклические конструкции устроены иначе. В самом общем случае для организации циклов используется рекурсия. Однако на практике явной рекурсии можно избежать, сведя задачу к комбинации простых рекурсивных схем, оперирующих потоками данных:
  <ul>
    <li><i>источник</i> — порождение потоков данных;</li>
    <li><i>преобразователь</i> — последовательное преобразование или фильтрация всех элементов потока;</li>
    <li><i>ограничитель</i> потока</li>
    <li><i>слияние</i> потоков</li>
    <li><i>сток</i> — свёртка или аггрегация потока.</li>
  </ul>
</p>

<task>Определите какие схемы реализуют фукции Haskell
  <pre><ghci>[1..3]
sum      
map
takeWhile
[1..]
length
iterate
product
zipWith
dropWhile
filter
zip
or
any</ghci></pre></task>

<task>Даны два целых числа <eq>a</eq> и <eq>b</eq>. Найти сумму квадратов всех целых чисел от <eq>a</eq> до <eq>b</eq> включительно. Задачу можно разбюить на три части:
  <ul>
    <li>создайте поток чисел от <eq>a</eq> до <eq>b</eq></li>
    <li>преобразуйте этот поток в поток квадратов чисел;</li>
    <li>просуммируйте полученный поток.</li>
  </ul>
</task>     

	
<task> Вычислите приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
	  с точностью до 14 знаков после запятой. Для этого
<ul>
  <li>определите функцию факториал от n, как произведение натуральных чисел 1,2,.. n; </li>
  <li>сгенерируйте последовательность чисел от 0 до бесконечности;</li>
  <li>превратите её в последовательность значений <eq>1/i!</eq>;</li>
  <li>ограничьте полученную последовательность элементами, превышающими указанную <eq>10^{-14}</eq> (используйте функцию <code>takeWhile</code>);</li>
  <li>просуммируйте последовательность.</li>
</ul>
Оцените количество операций, необходимых для вычисления этой функции.
	</task>

	<task>Напишите функцию <code>count p lst</code>, которая считает сколько раз в списке встречается элемент, удовлетворяющий предикату <code>p</code>. Как с её помощью подсчитать в строке количество цифр?</task>

	<task>Найдите сколько точек на целочисленной сетке попадают в круг указанным целочисленным радиусом. Оцените число <eq>\pi</eq> с помощью круга радиусом 100. Здесь для каждого элемента списка следует создать и обработать ещё один список, таким образом реализуется вложенный цикл.<br/> Посмотрите в справке о <a href ='haskell-ref.html#Генераторы списков' target='_blank'>генерации списков</a>.</task>

	<task>Решите в одну строчку. Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробeг на 10% от пробега предыдущего дня. Определите, в какой день лыжник должен будет пробежать 100 км. Найдите в какой день суммарный пробег за все дни превысит 100 км. </task>

	<task>Известно, что коэффициенты при всех степенях в разложении полинома <eq>(a + b)^n</eq> можно получить с помощью треугольника Паскаля. Треугольник Паскаля — бесконечная таблица, имеющая треугольную форму.
	  <p><img src="img/PascalTriangle.png" alt="" width='40%'/><img src="img/imgFig1.gif" alt="" width='60%'/></p>
	  <ul>
	    <li>Определите функцию <code>pascalStep</code>, которая для любой строки в треугольнике строит следующую строку, складывая почленно строку саму с собой, сдвинутой на один элемент. Проверьте правильность её работы на простых примерах.</li>
	    <li>Определите с помощью <code>pascalStep</code> бесконечную последовательность строк треугольника Паскаля.</li>
	    <li> Найдите с помощью оператора <code>!!</code> коэффициенты разложения <eq>(a+b)^{15}</eq>.</li>
	    <li>Найдите коэффициент при <eq>x^{10}</eq> в разложении <eq>(1+x)^{10000}</eq>.</li>
	    <li>После этого вычислите в этом же разложении коэффициент при <eq>x^{9}</eq> и <eq>x^{11}</eq>. Обратите внимание на разницу в скорости вычисления коэффициентов и попробуйте её объяснить.</li>
	    <li>Покажите, что сумма <eq>n</eq>-ного ряда треугольника Паскаля равна <eq>2^n</eq>.</li>
	</ul></task>
	
	<task>Для повышения точности численного интегрирования (см. занятие 1),  интервал интегрирования разбивается на несколько маленьких интервалов и на каждом из них интеграл вычисляется методом Гаусса, после чего результаты суммируются. Напишите функцию <code>integrate f mesh</code>, вычисляющую интеграл таким способом, используя задаваемую пользователем сетку <code>mesh</code>. <br/>

      Сравните получаемую точность интегрирования для различного числа разбиений на примере <eqn>\int_0^{20} \sin x\,dx = 1 - \cos\,20.</eqn></task>
	
   </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

