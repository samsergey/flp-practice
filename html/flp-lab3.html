<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Свёртка списков</h2>
	
	<task>Выясните и объясните тип функций <code>foldr</code>, <code>scanr</code>, <code>foldl</code>, <code>scanl</code>. Вычислите несколько примеров в интерпретаторе:</task>
	  <pre><ghci>foldr (+) 0 [1,2,3]
foldr (+) 10 [1,2,3]
foldr (-) 0 [1,2,3]
foldr (-) 10 [1,2,3]
foldl (-) 0 [1,2,3]
foldl (-) 10 [1,2,3]
scanr (+) 0 [1,2,3]
scanl (-) 0 [1,2,3]</ghci></pre>

 
	  <task>Мы повсеместно используем позиционную систему записи чисел, в которой число определяется последовательностью цифр. Так в десятичной системе последовательность <eq>23605_{10}</eq> обозначает число <eqn>2\cdot10^4+3\cdot10^3+6\cdot10^2+0\cdot10^1+5.</eqn> По существу, цифры в числе -- это коэффициенты полинома, который мы вычисляем в точке, соответствующей основанию.

	    Для вычисления полиномов существует эффективный способ, который при том же количестве сложений и умножений, совсем не использует операцию возведения в степень, он называется схемой Горнера. Вот как по этой схеме вычисляется число <eq>23605_{10}</eq> :<eqn>(((2\cdot10 + 3)\cdot10+6)\cdot10+0)\cdot10+5.</eqn> Обратите внимание на то, что вычисления представляют собой свёртку списка цифр с помощью функции <eq>r\ d \mapsto r\cdot1+d</eq>. Напишите, используя свёртку, функцию <code>fromBase</code>, транслирующую список цифр в заданной системе счисления в целое число:

	  <pre><hs> fromBase 10 [1,2,3]  ==>  123 -- это целое число
 fromBase 2 [1,1,0,1]  ==>  13 </hs></pre>
</task>
	  
	<task> Мы уже вычисляли приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
Вычислите приближение числа <eq>e</eq> более эффективным способом. Для этого сгенерируйте последовательность значений факториалов натуральных чисел с помощью функции <code>scanl</code>.</task>

<!--
	<task>Пользуясь функцией <code>elem</code>, напишите определения для функций <code>intersect l1 l2</code> и <code>complement l1 l2</code>, реализующих пересечение и дополнение множеств, представленных списками.</task>

	<task>Добавление элемента в множество, представленное списком можно определить следующим образом:
	  <pre><hs><def>insert :: Eq t => t -> [t] -> [t]</def>
insert y [] = [y]
insert y (x:xs) | x == y = x : xs
                | otherwise = x : insert y xs</hs></pre>
	  Объясните своими словами, как работает это определение. Пользуясь этой функцией и свёрткой напишите функцию <code>union l1 l2</code>, реализующую объединение множеств.</task>

	<task>Измените определение функции <code>insert</code>, так чтобы списки, представляющие множества были упорядочены. Даёт ли это какие-либо преимущества? Что нужно сделать для того, чтобы воспользоваться этим преимуществом в работе функций <code>intersect</code> и <code>complement</code>?</task> -->

	<task>В последовательности целых чисел найдите за один проход минимальное число и количество его повторений. Используйте следующий шаблон: <pre><hs><def>minCount :: Ord a => [a] -> (a, Int)</def>
minCount [] = error "List is empty"
minCount (x:xs) = foldl count _ xs
  where
    count (r, c) x | x == r = _
                   | x &lt; r = _
                   | otherwise = _</hs></pre></task>
	
	<h2>Вычислительная мощность свёртки</h2>

    <p>Свёртка (катаморфизм) — это абстракция последовательной обработки индуктивных данных. Это означает, что любую задачу, сводимую к обработке списка элемент за элементом можно решить при помощи свёртки.</p>

    <task>Напишите свою реализацию функции <code>length</code>, <code>map</code> и <code>filter</code>.</task>

    <task>Напишите свою реализацию функций <code>foldr</code> и <code>foldl</code>. </task>
    
    <task>Реализуйте только при помощи свёртки следующие функции: <code>map</code>, <code>filter</code>, <code>reverse</code>, <code>any</code>, <code>all</code>, <code>length</code>.</task>
	

<h2>Стековый калькулятор</h2>

<p><img class='logo' src='img/rpn.jpg' width=30%/>Со времени появления калькуляторов HewlettPackard и MK-36 прошло более сорока лет. Они отличались от обыкновенных, во-первых, тем, что были стековыми, а во-вторых -- программируемыми. И это не случайно. Стековые вычисления очень хорошо подходят для написания несложных программ для примитивного вычислителя. Принцип вычислений, который они реализовали остался актуален и используется тогда, когда есть необходимость производить вычисления на очень ограниченных вычислительных мощностях. В наше время стековые языки программирования нашли применение в виртуальных машинах: это языки для JVM для платформы Java и вычислителя CLR для .Net, для управления роботами: язык FORTH, и, наконец, язык программирования для управления принтерами PostScript. Всё это необычные, предельно простые языки с примитивной грамматикой, программы на которых с непривычки непросто писать, но необычайно просто выполнять.</p>

<p>Мы реализуем простейший стековый калькулятор, не обладающий полнотой по Тьюрингу, но позволяющий вычислять арифметические выражения произвольной сложности. Программы представляют собой выражения, записанные в обратной польской нотации. <i>Обратной польской нотацией</i> (ОПН) называется способ записи арифметических и логических выражений, который совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН -- плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек. Приведём алгоритм вычисления для стековой машины:<ul>
	  <li>Обработка входного символа
	  <li>Если на вход подан операнд, он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	  <li>Если входной набор символов обработан не полностью, перейти к шагу 1.
	</ul>
	После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.</p>
      
      <p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

      <p>Начнём с описания интерпретации отдельных команд:</p>

      <pre>
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s</pre>

<p>Как видно, мы оперируем стеком, содержащим числа и строковыми командами, которые управляют состоянием стека. Определим для них типы:</p>

<pre><hs>type Command = String
type Stack = [Double]
</hs></pre>

<p>Таблицу команд легко описать как определение функции <code>interprete</code>:</p>

<pre><hs><def>interprete :: Stack -> Command -> Stack</def>
interprete (x:y:s) "+" = (x+y):s
interprete (x:y:s) "*" = (x*y):s
interprete (x:y:s) "-" = (y-x):s
interprete (x:y:s) "/" = (y/x):s
interprete s n = (read n):s
</hs></pre>

<p>С её помощью выражение <code>"2 3 +"</code> можно вычислить так:</p>

<pre>interprete (interprete (interprete [] "2") "3") "+"</pre>

<p>Это же левая свёртка! Замечательно. Значит, наш калькулятор можно описать в виде свёртки:</p>


<hr/>
 
<p>Начнём разработку калькулятора с анализа типов. Калькулятор должен принимать строку-программу и преобразовывать стек в соответствии с ней.
  <pre><hs>calculator :: Program -> Stack -> Stack</hs></pre>

<p>  Например, функция <code>calculator "2 +"</code> может преобразовать стек <code>[3]</code> в <code>[5]</code>, добавив в него двойку и произведя сложение.
</p>
  
<p>  Далее, задача разбивается на два этапа: лексический анализ и выполнение отдельной команды:
  <pre><hs>parser :: Program -> [Command]
process :: Stack -> Command -> Stack</hs></pre>
Наконец, интерпретатор, имея в своём распоряжении исполнитель, может преобразовать последовательность команд в преобразование стека:
  <pre><hs>interpretor :: [Command] -> Stack -> Stack</hs></pre>
  Сопоставляя типы, можно видеть, что калькулятор можно представить в виде композиции лексера и интерпретатора:
  <pre><hs>calculator = interpretor . parser</hs></pre> В свою очередь, вычислитель можно реализовать посредством правой свёртки, в которой последние два арумента поменяны местами. Свёртка из обработчика одной команды позволяет создать обработчик последовательности команд. Наконец, роль стека может выполнять список чисел, например <code>[Float]</code>, а в качестве команд мы будем использовать строку. 

 Напишем определение для  функции-исполнителя команд <code>process s op</code>, которая реализует базовые арифметические операции на стеке-списке
<pre><hs>process op s =
  case op of
    "+" -> x+y : s''
    "*" -> x*y : s''
    "-" -> y-x : s''
    "/" -> y/x : s''
    "n" -> (-x) : s'
    n -> read n : s
    where
      (x:s') = s
      (y:s'') = s'</hs></pre>
Для преобразования строки в число использована функция <code>read</code>. </task>


 <task>С помощью свёртки реализуйте стековый  калькулятор. В качестве лексического анализатора, разбивающего строку-программу на отдельные команды, можно использовать стандартную функцию <code>words</code>.</task>

 <task>Представьте в обратной польской записи и вычислите с помощью калькулятора выражения: <eq>2+5\cdot6-9</eq>, <eq>(2+5)\cdot(6-9)</eq>, <eq>31-15-6</eq>, <eq>31-(15-9)</eq>, <eq>(43-3*5)/2+5</eq>.</task>

 <task>Поменяйте в интерпретаторе функцию свёртки <code>foldl</code> на <code>scanl</code> и реализуйте лог выполнения программы. Вывести лог на печать можно с помощью функции <code>mapM_ print</code> </task>

 <hr/>
<h3>Дополнение для тех, кому не хватило</h3>
 
  <task>Добавьте в язык калькулятора следующие команды управления стеком:
    <pre><hs> -- повторение верхнего элемента
1 2 3 4 d      ⟹  4 4 3 2 1
-- вращение двух верхних элементов
1 2 3 4 s      ⟹  3 4 2 1
-- копирование указанного элемента стека
1 2 3 4 1 i    ⟹  4 4 3 2 1  -- копирование последнего элемента
1 2 3 4 2 i    ⟹  3 4 3 2 1  -- копирование предпоследнего элемента
1 2 3 4 3 i    ⟹  2 4 3 2 1  -- копирование третьего сверху элемента
-- копирование нескольких верхних элементов стека
1 2 3 4 1 c    ⟹  4 4 3 2 1     -- копирование одного элемента
1 2 3 4 2 c    ⟹  4 3 4 3 2 1   -- копирование двух элементов
1 2 3 4 3 c    ⟹  4 3 2 4 3 2 1 -- копирование трёх элементов
-- вращение нескольких верхних элементов стека
1 2 3 4 2 1 r  ⟹  4 3 2 1 -- вращение двух элементов на один шаг
1 2 3 4 3 1 r  ⟹  3 2 4 1 -- вращение трех элементов на один шаг
1 2 3 4 3 2 r  ⟹  2 4 3 1 -- вращение трех элементов на два шага</hs></pre>

    Вам может понядобиться функция <code>splitAt</code>, входящая в стандартную библиотеку. 

  </task>

 
 <task>Напишите последовательность команд для калькулятора, вычисляющую для двух верхних чисел на стеке сумму их квадратов.</task>
  <pre><hs> norm = "..."
 calculator norm [3,4] ⟹ [25]</hs></pre>

 <task>Напишите последовательность команд для калькулятора, вычисляющую по схеме Горнера значение полинома второй степени <eq>a x^2 + b x + c</eq> в указанной точке <eq>x</eq>. Коэффициенты полинома и значение <eq>x</eq> находятся на стеке перед вычислением.</task>
  <pre><hs> poly2 = "..."
 calculator poly2 [2,1,0,1]  ⟹ [5]
 calculator poly2 [10,2,4,1] ⟹ [241]  </hs></pre>
 
 <task>Напишите программу для калькулятора, вычисляющую для трёх верхних чисел на стеке <code>[c, b, a]</code> корни квадратного уравнения <eqn>a x^2 + b x + c = 0.</eqn></task>
  <pre><hs> roots = "..."
 calculator roots [1,-2,1] ⟹ [1,1]
 calculator roots [-6,1,1] ⟹ [2,-3]
 calculator roots [1,0,1]  ⟹ [NaN,NaN] </hs></pre>

 <task>Созданный нами язык является конкатенативным. Это значит, что конкатенация двух программ является их композицией. Объединив программы <code>roots</code> и <code>poly2</code> проверьте, что они работают корректно, подставляя найденные корни полинома в полином.</task>

 <task>Чего не хватает языку управления калькулятором для полноты по Тьюрингу? Можно ли реализовать с помощью свёртки Тьюртнг-полный язык?</task>


	
      <!-- <p> -->
      <!-- 	Следующие два задания являются факультативными. Выберите одно из них, которое вам кажется более интересным или понятным. -->
      <!-- </p> -->
      
      <!-- 	<task>Для работы с очень большими числами применяется разложение числа по большому основанию. Так, скажем, число <code>1234567</code> по основанию <code>1000</code> можно представить в виде списка <code>[1, 234, 567]</code>. Напишите функцию, умножающую "длинное число" в системе счисления с основанием, например, <eq>10^{9}</eq> (это число разрядов в типе <code>Int</code>, занимающем два байта), представляемое списком 9-значных "цифр" на число типа <code>Int</code>: -->
      <!-- 	  <pre><hs><def>multLong :: Int -> [Int] -> [Int]</def></hs></pre> -->
      <!-- 	Посчитайте с его помощью факториал 100 или 1000.</task> 
	
	<task>Составьте программу поиска всех решений ребуса <eqn>\mathrm{VOLVO} + \mathrm{FIAT} = \mathrm{MOTOR}.</eqn> Разным буквам соответствуют разные цифры, одинаковым — одинаковые. Старшая цифра каждого числа отличается от нуля (см.&nbsp;<a href ='haskell-ref.html#Генераторы списков' target='_blank'>Генераторы списков</a>).
	  <p>Программа в интерпретаторе будет работать довольно медленно. Для решения реальных задач программу следует скомпилировать с включённым флагом оптимизации. Для этого можно включить командную строку в редакторе <sl>Emacs</sl> с помощью команды<br/> <keystroke>M-x</keystroke> <tt>eshell</tt>. Далее выполняем компиляцию с оптимизирующим флагом <tt>-O3</tt>:
	  <pre>&gt; ghc.exe -O3 test.hs
[1 of 1] Compiling Main             ( test.hs, test.o )
Linking test ...
&gt; test.exe</pre>
	  </p>
	</task>-->


    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
