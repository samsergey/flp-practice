<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <h2>Транслятор и результат трансляции</h2>
      
      <p>Транслятор&nbsp;— это функция, которая преобразует входную последовательность символов (строку, или поток лексем) в некий результат. Результатом может быть логическое значение, если нас интересует только соответствие текста заданной грамматике, последовательность выходных значений, синтаксическое дерево, или число. То есть, тип транслятора, в самом общем случае, может быть каким-то таким:</p>

      <pre><hs>data Parser i a = Parser (i -> a)</hs></pre>
      
      <p>где <tt>i</tt>  тип входного потока, а <tt>a</tt>&nbsp;— тип результата. Например, лексический анализатор, читающий программу в виде строки, и возвращающий список лексем может иметь тип <tt>Parser String [Token]</tt>.</p>
      
      <p>Для того, чтобы нам было легче применять спрятанную в тип <tt>Parser</tt> функцию-преобразователь, дадим ей имя:</p>

      <pre><hs>data Parser i a = Parser { run :: i -> a }</hs></pre>

      
      <p>Определим какой-нибудь самый простой транслятор. Очень простой. </p>

      <pre><hs>next = Parser $ \(x:_) -> x</hs></pre>

     
      <p>  Он работает со списками (или строками) и просто возвращает первый элемент разбираемой последовательности, каким бы он ни был:</p>

      <pre><ghci>λ> run next "abab"
'a'
λ> run next "bab"
'b'</ghci></pre>

      <p> Транслятор работает, но он практически бесполезен, ведь мы потеряли информацию о разбираемой строке и не сможем продолжить разбор. Это приводит к мысли, что возвращаемый результат должен каким-то образом содержать в себе разбираемую строку. Объединим их в типе <tt>Result</tt>, на который можно посмотреть и сравнить с чем-нибудь:</p>

      <pre><hs>data Parser i a = Parser { run :: i -> Result i a}

data Result i a = Result i a
  deriving (Show, Eq)
	  
next = Parser $ \(x:xs) -> Result xs x</hs></pre>

      <pre><ghci>λ> run next "abab"
Result "bab" 'a'</ghci></pre>

      <p> Теперь работа транслятора стала более осмысленной, он вернул первый элемент и сократил разбираемую строку.</p>
    
      <p>А что дальше? Как нам снова применить функцию <tt>next</tt> к полученному результату?</p>

      <h2>Последовательное выполнение трансляторов</h2>

      <p>Притворимся, что мы ничего не знаем о функторах и монадах и придумаем их ещё раз, чтобы лучше понять, для чего они нужны и как устроены. Чтобы притвориться по-настоящему, скроем определения для монадических операторов, загружаемых стандартной библиотекой:
            <pre><hs>import Prelude hiding ((>>),(>>=),(<$>))</hs></pre>
      </p>
      
      <p>Определим комбинатор <tt>>></tt>, "соединяющий" трансляторы в цепочку: </p>

      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Result r' _ -> run t2 r'  </hs></pre>

      <p>Форма <tt>case</tt> потребовалась нам для того, чтобы "разобрать" результат работы транслятора <tt>t1</tt> и добыть остаток строки. Можно было воспользоваться формой <tt>let</tt> или <tt>where</tt>, но, во-первых, она читается более естественно: от <tt>t1</tt> к <tt>t2</tt>, а во-вторых, скоро мы добавим другие альтернативы.</p>
    
      <p>  Комбинатор <tt>>></tt> возвращает новый транслятор, так что его тоже можно применить к разбираемой строке с помощью функции <tt>run</tt>. Попробуем его использовать:</p>     
      <pre><ghci>λ> run (next >> next) "abab"
Ok "ab" 'b'
λ> run (next >> next >> next) "abab"
Ok "b" 'a'</ghci></pre>
      
      <p>Переходя ко второму транслятору и далее мы потеряли информацию о первом встреченном символе, но пока она и не нужна: транслятор <tt>next</tt> её всё равно не использует. И мы тоже пока об этом думать не будем.</p>

            <h3>Право на ошибку</h3>

      <p> Пора научится задавать для разбираемой последовательности какие-либо правила. Например, можно потребовать, чтобы первым символом был символ <tt>'a'</tt>, и если это так, продолжить разбор. А если не так? В этом случае надо прекратить разбор выражения и как-то показать, что трансляция завершилась неудачно.</p>
    
      <p> Расширим тип для результата трансляции, разделив его на успешную трансляцию и неудачную:</p>

      <pre><hs>data Result i a = Ok i a
                | Fail i
  deriving (Show, Eq)</hs></pre>

      <p> В случае неудачи, тип содержит неразобранную часть строки. На всякий случай.</p>
 
      <p>Раз мы изменили описание типа <tt>Result</tt>, нужно поменять и определение комбинатора <tt>>></tt>, чтобы он учитывал возможные исходы разбора и в случае неудачи, постигшей первый транслятор, не пытался вызывать следующий:</p>
      
      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Ok r' _ -> run t2 r'
  Fail r' -> Fail r'</hs></pre>

      <p> Кроме того, транслятор <tt>next</tt> может стать несколько "умнее"&nbsp;— если строка пуста, никакого следующего символа в ней нет, а это означает неудачу в разборе:</p>

      <pre><hs>next = Parser $ \r -> case r of
  [] -> Fail r
  x:xs -> Ok xs x</hs></pre>
          
      <p>Напишем теперь транслятор, который будет требовать, чтобы анализируемая строка начиналась с конкретного символа. Опять же, сначала для этого нужно удоствериться в том, что разбираемая строка не пуста:</p>

      <pre><hs>term c = Parser $ \r -> case r of
  [] -> Fail r
  x:xs -> if x == c
          then Ok xs x
          else Fail r </hs></pre>

      <p>Посмотрим, как он работает:</p>

      <pre><ghci>λ> run (term 'a') "abab"
Ok "bab" 'a'
λ> run (term 'b') "abab"
Fail "abab"
λ> run (term 'a' >> term 'b') "abab"
Ok "ab" 'b'
λ> run (term 'b' >> term 'b') "abab"
Fail "abab"
λ> run (term 'a' >> next >> term 'a') "abab"
Ok "b" 'a'
</ghci></pre>

      <p> Очень хорошо! Но сразу же хочется сделать ещё лучше. А когда делаешь лучше главное&nbsp;— не сделать хуже. В этом нам поможет тестирование.</p>
    
      <p>Напишем функцию-тестировщик.</p>

      <pre><hs>test (p, inp, outp) = when (res' /= outp) msg
  where
    res' = run p inp 
    msg = format "Fail.\n  input:    _\n expected: _\n got:      _\n"
	  [show inp, show outp, show res']</hs></pre>

      <p>Здесь нам понадобились функции <tt>when</tt>  и <code>format</code>, написанные нами ранее. Применять тестировщик можно к списку трансляторов, входных и ожидаемых выходных значений таким образом:</p>
    
    <pre><hs>runTests lst = putStr $ foldMap test lst
	
tests = runTests	
  [ (term 'a',             "abab", Ok "bab" 'a')
   ,(term 'a',             "bbab", Fail "bbab")
   ,(term 'a' >> term 'b', "abab", Ok "ab" 'b')
   ,(term 'b' >> term 'b', "abab", Fail "abab") ]</hs></pre>

      <p> Запускаем тесты...</p>
      <pre><ghci>λ> tests</ghci></pre>
      <p> и видим, что ничего не выводится. Значит, у нас всё хорошо. Испортите какой-нибудь из тестов и посмотрите, что будет.</p>

      <p>Теперь можно смело двигаться дальше!</p>

      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok i a | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: i -> Result i a }</p></basic>

<part>комбинаторы</part>
<p><basic>>></basic></p>

<part>трансляторы для коллекций</part>
<p><basic>next  term</basic></p>
</sinopsys>
      </details>


      
      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

