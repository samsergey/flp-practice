
<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>fmap {
      content: "hello&lt;$&gt;";
    }</style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в функциональном программировании — это больше чем описание данных. Это, в первую очередь, описание структуры образуемой данными, в виде математических законов, справедливых для этой структуры. Мы видели это на примере типов для электрических сопротивлений, разнообразных моноидов, изображений и т.д. Типы могут обладать структурой, которая позволяет не только комбинировать вычисления, но и управлять потоком вычислений. Для управления потоком в императивном программировании используются ветвление, циклы или исключения, в функциональном подходе часть и этой работы берут на себя типы.</p>
      
      <task>Простой и часто встречающийся пример — тип <code>Maybe a</code>, говорящий о&nbsp;том, что величина значения типа <code>a</code> может быть неопределена. Посмотрите информацию о типе <code>Maybe</code> с помощью команды <tt>:i</tt>.</task>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите функции <code>listToMaybe :: [a] -> Maybe a</code> и <code>maybeToList :: Maybe a -> [a]</code>.</task>

      <p>Оператор <code>(&lt;$&gt;)</code> имеет своё имя: <code>fmap</code>  и он определён для всех типов, являющихся <strong>функторами</strong>. Самое общее определение для функтора — это <strong>контекст, в котором производятся вычисления</strong>.</p>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <tt>:t</tt>. Посмотрите (с&nbsp;помощью команды <tt>:i</tt> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <h2>Аппликативные функторы</h2>
    
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с функторами. Посмотрите на то, как действуют операторы <code>&lt;|&gt;</code> и <code><*></code>, вычислив в <sl>GHCi</sl> следующие выражения.
      <pre><hs> Nothing &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Nothing
 Nothing &lt;|&gt; Nothing
 Nothing &lt;*&gt; Just 5
 Just (4*) &lt;*&gt; Just 5
 Just (2*) &lt;*&gt; Nothing
 (+) &lt;$&gt; Just 3 &lt;*&gt; Just 7
 (+) &lt;$&gt; Nothing &lt;*&gt; Just 7
 (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing</hs></pre>
      Объясните своими словами, для чего нужны операторы <code>&lt;$&gt;</code> (<code>fmap</code>), <code>&lt;|&gt;</code>, <code>&lt;*&gt;</code>, применительно к функтору <code>Maybe</code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните действие выражений:
	<pre><hs>(+2) &lt;$&gt; find (< 2) [2,3,1,4]
(*) &lt;$&gt; find odd [2,3,1,4] &lt;*&gt; find even [2,3,1,4]
(*) &lt;$&gt; find odd [2,6,10,4] &lt;*&gt; find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) &lt;$&gt; lookup "x" vars &lt;*&gt; lookup "a" vars</hs></pre>
 </task>

      <task>Посмотрите на определение функтора <code>Either</code>, и объясните его функториальные свойства, судя по примерам:
	<pre><hs>(*2) &lt;$&gt; Right 4
(*2) &lt;$&gt; Left 4
(*2) &lt;$&gt; Left "hello"
(+) &lt;$&gt; Right 8 &lt;*&gt; Right 5
(+) &lt;$&gt; Left "No!" &lt;*&gt; Right 5	</hs></pre>
      </task>			  

      <task>Напишите функцию <code>sqrtE</code>, которая вычисляет квадратный корень вещественного числа, и для отрицательных чисел возвращает сообщение об ошибке, в виде значения <code>Left "sqrt: got negative argument!"</code>. Вычислите с её помощью  выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>
     
      <task>Поэкспериментируйте с функториальными свойствами типа <code>[]</code>:      <pre><hs>[] &lt;|&gt; [2,3]
[1,2,3] &lt;|&gt; [4,5]
[2] &lt;|&gt; []
[] &lt;|&gt; []
[] &lt;*&gt; [2,3,4]
[(4*)] &lt;*&gt; [2,3,4]
[(4*), (3+)] &lt;*&gt; [2,3,4]
(+) &lt;$&gt; [2,3] &lt;*&gt; [4,5,6]
(+) &lt;$&gt; [] &lt;*&gt; [2,3]
(+) &lt;$&gt; [1,2,3] &lt;*&gt; []</hs></pre>
</task>

      <task>Напишите функцию <code>sqrtL</code>, которая вычисляет квадратный корень вещественного числа, причём, для положительных аргументов она должна возвращать как положительное, так и отрицательное значение корня, для нулевого — только ноль, а для отрицательных значений — ни одного значения. Вычислите с её помощью выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Посмотрите на определение типа <code>IO</code> и объясните как он действует, в&nbsp;качестве функтора:
	<pre><hs>("Hello, " ++) &lt;$&gt; getLine
let readNum = read &lt;$&gt; getLine 
(+) &lt;$&gt; readNum &lt;*&gt; readNum
print 6 &lt;|&gt; error "!!"	</hs></pre>
      </task>			  
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В&nbsp;определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>strongpty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code> (они образуют моноид). </task>

      <task>Напишите универсальную функцию <code>sqrtA</code>, обобщающую функции <code>sqrtM</code> и <code>sqrtL</code> так, чтобы она работала c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code>, причём, для списков, возвращала несколько корней.</task>

      <task>Напишите, используя альтернативные функторы, функцию <code>bisectionA</code>, отыскивающую точку смены заданного условия методом бисекции: <pre><hs><def>bisectionA :: (Alternative f, Eq a)
  => (Double -> a) -> Double -> Double -> f Double
</def></hs></pre></task>

      
<!--       <h2>Управление сообщениями об ошибках</h2> -->
      
<!--       <p>Тип <code>Either</code> похож на тип <code>Maybe</code> тем, что у него есть одно "верное" значение — правое, и "неверное" — левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p> -->

<!--       <p>Однако тип <code>Either</code> не является альтернативным функтором. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>strongpty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>strongpty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p> -->

<!--       <pre><hs>instance Monoid m =&gt; Alternative (Either m) where -->
<!--   strongpty = Left mstrongpty -->
<!--   Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно -->
<!--   Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения -->
<!--   Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения</hs></pre> -->

<!--       <task>Убедитесь на следующих примерах, что приведённое определение работает корректно: -->

<!--       <pre><code>Left "fail" &lt;|&gt; Right 42 -->
<!-- Right 42 &lt;|&gt; Left "fail" -->
<!-- Left "I am " &lt;|&gt; Left "a fail" -->
<!-- </code></pre> -->
<!--       </task> -->

<!-- <p>Для типа <code>Either String</code> определим специальный тип:<pre><hs>type Messaged = Either String</hs></pre></p> -->
      
<!--       <p>Теперь нужно научиться вводить в программу сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали их. Эта возможность должна быть определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>sqrtA</code> для разных контестов, а это уже не DRY (Don't Repeat Yourself — один из универсальных принципов программирования).</p> -->

<!--       <p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в&nbsp;нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию — <code>message</code>.</p> -->

<!--       <pre><hs>class Alternative f =&gt; Failable f where -->
<!--   message :: String -&gt; f a -->
<!--   -- определение, используемое по умолчанию -->
<!--   message _ = strongpty -->
<!-- </hs></pre> -->

<!--       <p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Messaged</code> и <code>IO</code> — специфические:</p> -->

<!--       <pre><hs>instance Failable Maybe -->
<!-- instance Failable [] -->
<!-- instance Failable Messaged where message = Left -->
<!-- instance Failable IO where message = error -->
<!-- </hs></pre> -->

<!--       <task>Внесите в определение функции <code>sqrtA</code> изменения, позволяющие использовать её в четырёх различных контекстах: -->
<!-- 	<pre><hs> sqrtA 16 :: [Double] -->
<!--  sqrtA 16 :: Maybe Double -->
<!--  sqrtA 16 :: Messaged Double -->
<!--  sqrtA 16 -->
<!--  sqrtA (-1) :: [Double] -->
<!--  sqrtA (-1) :: Maybe Double -->
<!--  sqrtA (-1) :: Messaged Double -->
<!--  sqrtA (-1)</hs></pre> -->
<!--       </task> -->
<!--       <p> -->
<!-- 	Нам в дальнейшей работе пригодится класс <code>Failable</code>, поэтому стоит выделить его и определение экземпляров для типов <code>[]</code>, <code>Maybe</code>, <code>Messaged</code> и  <code>IO</code> в отдельный модуль <tt>Failable.hs</tt> -->
<!--       </p> -->

<!--       <task>Перепишите функцию <code>bisection</code>, так, чтобы её тип стал таким: <pre><hs><def>bisection :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> Double -> Double -> f Double</def></hs></pre></task> -->


<!--       <task>Подобно тому, как мы интегрировали функцию на указанной сетке, организуйте поиск особых точек методом бисекции на произвольной сетке:<pre><hs><def>findRoot :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> [Double] -> f Double</def></hs></pre> При этом для пустой сетки и сетки с единственной точкой должны возвращаться соответствующие сообшения об ошибках.</task> -->

      <h2>Монады</h2>
      
      <p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые возвращают значение в контексте? Например, как можно дважды применить функцию <code>sqrtM</code>, чтобы вычислить <eq>\sqrt{\sqrt{16}}</eq>? Иными словами, как выполнить композицию функций, возвращающих не просто значение, а значение в некотором контексте <code>m</code>?</p>
      
      <p>Попробуем начать с использования оператора <code>&lt;$&gt;</code>:
	<pre><ghci><l></l> sqrtM &lt;$&gt; sqrtM 16
<o>Just (Just 2)</o>
<l></l> sqrtM &lt;$&gt; sqrtM (-1)
<o>Just Nothing</o></ghci></pre>
      </p> 
      
      <p>
	Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just 2)</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>Just 2</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление.</p>

      <task> Определите функцию <code>join :: Maybe (Maybe a) -&gt; Maybe a</code>, которая занималась бы "соединением" контекстов так, чтобы можно было получить такие результаты: <pre><ghci><l></l> join $ sqrtM &lt;$&gt; sqrtM 16
<o>Just 4</o>
<l></l> join $ sqrtM &lt;$&gt; sqrtM (-1)
<o>Nothing</o></ghci></pre>
      </task>

      <p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в&nbsp;цепочки любые вычисления с контекстом. Для неё есть особое обозначение: <code>=&lt;&lt;</code></p>

<p align='center'><tt>f =&lt;&lt; x  ≡  join $ f &lt;$&gt; x</tt></p>


      <p>Мы определили для типа <code>Maybe</code> функцию <code>join</code> и сразу повысили его "ранг", позволяя объединять в цепочку функции, возвращающие значения в контексте <code>Maybe</code>. Функторы (аппликативные) для которых определено соединение <code>join</code> называются <strong>монадами</strong>. </p>
      
      <task>Сравните типы операторов <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> и <code>=&lt;&lt;</code> и объясните своими словами их действие в контекстах.</task>

      <p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

      <pre><hs><def>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</def></hs></pre>

      <task>Вычислите следующие выражения в интерпретаторе и объясните как происходят вычисления:
	<pre><hs>[-1,0,1,16] &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Just 64 &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Right 16 &gt;&gt;= sqrtA
Right (-16) &gt;&gt;= sqrtA
(read &lt;$&gt; getLine) &gt;&gt;= sqrtA &gt;&gt;= print</hs></pre></task>

      <task>Изучите типы универсальных функций для работы с функторами и монадами
	<pre><hs>ap
mapM
join
(>=>)
($>)	    
foldM
sequence
traverse
replicateM</hs></pre>
	C помощью интерпретатора познакомьтесь с их поведением для типов <code>[a]</code>, <code>Maybe a</code>, <code>(,) a</code>. </task>
      

      <h2>Управление семантикой вычислений</h2>
<p>Вернёмся к задаче интерпретации арифметических выражений, записанных в обратной польской нотации. Наше решение, использующее простой стековый автомат было лаконичным и эффективным, но очень ограниченным по возможностям. В нём даже нет элементарных обработок ошибочных выражений и в исключительной ситуации он просто прерывает свою работу, не сообщая о характере ошибки. Используя аппликативные функторы и монады, как абстракцию семантики вычислений мы можем существенно расширить его функционал.</p>

<p>Для начала перепишем код калькулятора, добавив в него обработку ошибок:</p>

<pre><hs>type Stack = [Double]

calculate :: String -> Stack
calculate = foldl interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> read n : s
      where
        binop f = case s of
          x:y:s -> f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = error $ op ++": " ++ m </hs></pre>

<task>Составьте список примеров для калькулятора и проверьте на них не только правильность его работы, но и адекватность сообщений об шибках.</task>

<p>Получился уже совсем неплохой калькулятор, надёжный, расширяемый и вполне дружелюбный. Однако у него есть существенный недостаток -- в случае ошибки он прерывает выполнение не только своей работы, но и любой системы, в которую он мог бы быть включён. Это вовсе не в духе функционального программирования, где ценится тотальность и надёжность программ.</p>

<p>Стандартным решением в процедурном программировании является "поимка исключений" с помощью конструкции <code>try/catch</code>. Это добавляет программе надёжности, но позволяет потоку выполнения прерываться и перескакивать из одного блока в другой. В функциональном программирований поток вычислений непрерывен и больше похож на течение тока в электрической цепи. Здесь одним из самых типичных способов управления потоком -- использование функторов и монад.</p>

<p>Мы можем воспользоваться монадой <code>Either</code> для того, чтобы ошибочные состояния превратить в данные и прерывая вычисления, не останавливать работу всей программы. </p>
  <pre><hs>calculateE :: String -> Either String Stack
calculateE = foldM interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> Right $ sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> readE n : s
      where
        binop f = case s of
          x:y:s -> Right $ f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = Left $ op ++": " ++ m

readE :: Read a => String -> Either String a
readE s = case [x | (x,t) <- reads s, ("","") <- lex t] of
            [x] -> Right x
            _ -> Left $ "could not parse " ++ s</hs></pre>

<p>Здесь мы добавили собственный безопасный вариант функции <code>read</code>. Обратите внимание на то, что код программы изменился незначительно: функция свёртки оказалась заменена на монадический вариант <code>foldM</code>, и "хорошие" результаты вычислений оказались упакованы в конструктор <code>Right</code>.</p>

<task>Теперь появилась возможность прогнать все тесты сразу, поскольку ошибки не прерывают работы программы. Проверьте правильность работы калькулятора на ваших примерах. </task>

<p>Мощность монадических вычислений позволяют переключаться с отдной семантики вычисления прогаммы на другую, не меняя кода программы. Мы видели это на примере функции <code>bisection</code>. Нельзя ли и наш калькулятор сделать столь же универсальным?</p>

<p>Давайте создадим класс для монад, способных создавать сообщения об ошибках.</p>
<pre><hs>class Monad m => Exception (m :: * -> *) where
  exception :: String -> m a</hs></pre>
<p>Выражение <code>m :: * -> *</code> говорит о том, что <code>m</code> является не простым типом, а типом-контенером. Для того, чтобы использовать эту конструкцию нужно подключить две директивы компилятору в самом начале программы.</p>

<pre><hs>{-# language FlexibleInstances #-}</hs></pre>

<p>Экземплярами этого класса могут быть монады <code>IO</code> и <code>Either</code></p>

<pre><hs>instance Exception IO where
  exception = error

type Err = Either String

instance Exception Err where
  exception = Left</hs></pre>
  <hr/>

<p>Теперь можно написать обобщённый калькулятор:</p>
  <pre><hs>calculateE :: Exception m => String -> m Stack
calculateE = foldM interprete [] . words
  where
    interprete s op = case op of
      "+" -> binop (+)
      "*" -> binop (*)
      "-" -> binop (-)
      "/" -> binop (/)
      "sqrt" -> case s of
        x:s | x >= 0  -> pure $ sqrt x : s
            | otherwise  -> err "negative argument!"
        [] -> err "got no arguments!"
      n -> readE n : s
      where
        binop f = case s of
          x:y:s -> pure $ f y x : s
          [_]   -> err "got only one argument!"
          []    -> err "got no arguments!"

        err m = exception $ op ++": " ++ m

readE :: (Exception m, Read a) => String -> m a
readE s = case [x | (x,t) <- reads s, ("","") <- lex t] of
            [x] -> pure x
            _ -> exception $ "could not parse " ++ s</hs></pre>

<p>Конкретную монаду, в которой он работает теперь способна выбирать программа, вызывающая этот калькулятор:</p>
<pre><ghci><l></l> calculateE "2 3 + 4 *" :: IO Stack
<o>[20.0]</o>
<l></l> calculateE "2 3 + 4 *" :: Err Stack
<o>Right [20.0]</o>
<l></l> calculateE "2 3 + *" :: IO Stack
<err>*** Exception: *: got only one argument!  Stack: [5.0]</err>
<l></l> calculateE "2 3 + *" :: Err Stack
<o>Left "*: got only one argument!  Stack: [5.0]"</o></ghci></pre>

<task>Добавьте определения экземпляров класса <code>Exception</code> для монад <code>[]</code> и <code>Maybe</code>. Эти монады игнорируют сообщения, но, тем не менее способны создавать альтернативные ветви вычислений. Проверьте, что наш калькулятор способен работать и в этих монадах.</task>

    <task>Мы видели, что альтернативные функторы, позволяют производить неоднозначные вычисления со множеством вариантов ответов. Мы можем создать неоднозначным и наш калькулятор, введя операцию <eq>\pm</eq> и позволив операции <code>sqrt</code> возвращать несколько значений. Для этого нужно сделать функтор <code>Err</code> альтернативным.</task>

    <h2>Управление изменяемым состоянием</h2>

<p>Вычислительная мощность монад уже достаточно велика, для того чтобы с их помощью можно было решить любую алгоритмическую задачу. Существует огромное число самых разных монад и функторов, решающий смые разные задачи. Они даже позволяют ввести в программу изменяемое состояние, не изменяя при этом принципам чистого функционального программирования.</p>

<p>Рассмотрим несложную задачу генерации бинарного дерева, хранящего в листьях и узлах какие-то значения:</p>
<pre><hs>data BTree a = Leaf a
             | Node a (BTree a) (BTree a)
  deriving Show</hs></pre>

<p>Пусть перед нами стоит задача сгенерировать сбалансированное дерево заданной глубины, как-то нумеруя при этом листья и узлы. В нефункциональных языках мы бы завели переменный счётчик и по мере создания дерева увеличивали бы его значение. Но переменных у нас нет и нет понятия времени, то есть чётко заданной последовательности действий.</p>

<p>С помощью монад мы способны задать семантику вычислений, в которой появляются и изменяемое состояние и время. Для этого создадим новый тип-контейнер <code>State</code>:</p>
<pre><hs>data State s a = State { runState :: s -> (s, a) }</hs></pre>
<p>Его можно объявить экзепляром классов <code>Functor</code>, <code>Applicative</code> и <code>Monad</code>:</p>
<pre><hs>instance Functor (State s) where
  fmap f x = State $
             \s -> let (s', y) = runState x s
                   in (s', f y)

instance Applicative (State s) where
  pure x  = State $ \s -> (s, x)
  x <*> y = State $ \s -> let (s', f) = runState x s
                          in f <$> runState y s'

instance Monad (State s) where
  x >>= f = State $ \s -> let (s', y) = runState x s
                          in runState (f y) s'</hs></pre>

<p>Эти определения стоят того, чтобы над ними помедитировать. Тип <code>State</code> представляет собой функцию <code>runState</code>, которая принимает состояние типа <code>s</code> и возвращает новое состояние и некий результат типа <code>a</code>. Аппликативное и монадическое поведение <code>State</code> состоит в передаче от вычисления к вычислению изменяемого состония.</p>

<p>Это пока выглядит весьма абстрактно. Для работы с состоянием нужны вспомогательные функции:</p>
<pre><hs>get = State $ \s -> (s, s)
set x = State $ \_ -> (x, ())
modify f = get >>= set . f </hs></pre>
<p>Функция <code>get</code> превращает состояние в результат вычисления. Функция <code>set</code> -- устанавливает значение состонию. А <code>modify</code> изменяет состояние с помощью указанной функции. Вот как они работают:</p>
<pre><ghci><l></l> runState get 6
<o>(6,6)</o>
<l></l> runState (set 5) 6
<o>(5,5)</o>
<l></l> runState (modify (+ 1)) 6
<o>(7,7)</o></ghci></pre>

<p>А вот как с их помощью можно решить задачу генерации дерева с нумерованными узлами и вершинами:</p>
<pre><hs>mkTree 0 = Leaf <$> modify (+ 1)
mkTree n = Node <$> modify (+ 1)
                <*> mkTree (n-1)
                <*> mkTree (n-1)</hs></pre>
<pre><ghci><l></l> mkTree 2 `evalState` 0
<o>(7, Node 1 (Node 2 (Leaf 3) (Leaf 4))
           (Node 5 (Leaf 6) (Leaf 7)))</o></ghci></pre>
<p>Здесь состоянием является счетчик. Мы вызываем генератор дерева с начальным значением счётчика 0, по мере своей работы он создёт элементы дерева, увеличивая это значение. В конце мы получаем готовое дерево и текущее значение счетчика -- 7. Функция <code>mkTree</code> чистая и повторный её вызов всегда будет приводить к одинаковому результату.</p>

<p>Аппликативное определение можно переписать с помощью монадической операции <code>>>=</code> так, чтобы стал виден порядок вычислений:</p>
<pre><hs>mkTree n = modify (+ 1) >>= \i
             -> mkTree (n-1) >>= \l
             -> mkTree (n-1) >>= \r
             -> pure (Node i l r)</hs></pre>

<p>Такая запись громоздка и для неё в языке Haskell существует специальная синтаксическая форма:</p>
<pre><hs>mkTree n = do i <- modify (+ 1)
              l <- mkTree (n-1)
              r <- mkTree (n-1)
              pure $ Node i l r</hs></pre>
 <p>Она уже очень похожа на императивную программу! Давате поменяем порядок обхода дерева:</p>
<pre><hs>mkTree n = do l <- mkTree (n-1)
              i <- modify (+ 1)
              r <- mkTree (n-1)
              pure $ Node i l r</hs></pre>
<pre><ghci><l></l> mkTree 2 `evalState` 0
<o>(7, Node 4 (Node 2 (Leaf 1) (Leaf 3))
           (Node 6 (Leaf 5) (Leaf 7)))</o></ghci></pre>
<p>Как полагается, при изменении состояния, порядок вычислений начинает играть существенную роль, и теперь мы получили левый обход дерева!</p>

<task>Напишите обход дерева в глубину слева и правый обход дерева.</task>

<p>Наконец, давайте полностью инкапсулируем монадические вычисления:</p>
<pre><hs>enumTree :: Int -> BTree Int
enumTree n = evalState (mkTree n) 0

evalState :: State s a -> s -> a
evalState st = snd . runState st</hs></pre>

<p>Функцию <code>enumTree</code> можно использовать в любых вычислениях, она имеет тип, ничего не говорящий о том, что внутри неё работала монада <code>State</code>.</p>

		     
<h2>Генерация псевдослучайных чисел</h2>

<p>Монада <code>State</code> позволяет изящно реализовать работу со случайными числами, которые бывают нужны в самых разных задачах: методе Монте-Карло, тестировании больших чисел на простоту, написании игр, генерации тестовых данных и пр.</p>

<p>Мы реализуем линейный конгруэнтный метод генерации целых псевдослучайных чисел, использующий следующую итерационную формулу: 
<eqn>X_{n+1} = (a X_n + c)\ \mathrm{mod}\ m.</eqn>
В основных реализациях языка C (ANSI C, C++, gcc) используются такие значения: <eq>a=1103515245</eq>, <eq>c=12345</eq> и <eq>m=2^31</eq>. Этот метод требует начального значения <eq>X_0</eq> (random seed) для генерации последовательности <eq>X</eq>, обычно для него используется внутренее абсолютное время процессора.</p>

<p>Определим наш генератор последовательности псевдослучайных целых чисел на отрезке <eq>[0, k]</eq> таким образом:</p>
<pre><hs>random :: Integral b => b -> State b b
random k = (`mod` (k+1)) <$> modify iter 
  where
    iter x = (x * a + c) `mod` m
    (a, c, m) = (1103515245, 12345, 2^31)</hs></pre>

<p>Вот примеры его работы:</p>
<pre><ghci><l></l> random 100 `runState` 42
<o>(1250496027,27)</o>
<l></l> replicateM 10 (random 100) `runState` 42
<o>(1535244752,[27,64,53,6,35,32,33,66,59,52])</o></ghci></pre>

<p>А вот как можно сгенернировать случайное дерево ограниченное указанной глубиной:</p>
<pre><hs>randomTree 0 = Leaf <$> random 100
randomTree n = Node <$> random 100
               <*> (random n >>= randomTree)
               <*> (random n >>= randomTree)</hs></pre>
<pre><ghci><l></l> randomTree 3 `evalState` 41
<o>Node 82 (Leaf 44) (Node 82 (Leaf 40) (Leaf 66))</o>
<l></l>  randomTree 3 `evalState` 42
<o>Node 27 (Node 53 (Leaf 35) (Leaf 33)) (Leaf 59)</o>
<l></l>  randomTree 3 `evalState` 43
<o>Node 24 (Node 62 (Leaf 88) (Leaf 26)) (Node 52 (Node 54 (Leaf 72) (Leaf 82)) (Node 0 (Leaf 78) (Leaf 92)))</o></ghci></pre>

<p>Наконец, можно выйти во внешний мир с помощью монады <code>IO</code> и запросить абсолютное время у процессора в качестве затравки генератора.</p>
<pre><hs>randomTreeIO :: Integer -> IO (BTree Integer)
randomTreeIO n = evalState (randomTree n) <$> getCPUTime</hs></pre>
<pre><ghci><l></l> randomTreeIO 3
<o>Node 77 (Node 95 (Leaf 29) (Leaf 23)) (Node 65 (Leaf 19) (Leaf 25))</o>
<l></l> randomTreeIO 3
<o>Node 9 (Leaf 87) (Leaf 93)</o>
<l></l> randomTreeIO 3
<o>Node 49 (Node 19 (Leaf 41) (Leaf 35)) (Leaf 45)</o></ghci></pre>

<p>Функция <code>getCPUTime</code> определена в библиотеке <tt>System.CPUTime</tt>. Теперь вы никогда не получите два одинаковых случайных дерева, но вынуждены будете всегда работать в монаде <code>IO</code>.</p>

<task>Методом Монте-Карло оцените площадь, ограниченную кривой, заданной уравнением:
  <eqn>(x^2+y^2-1)^3 < x^2 y^3.</eqn> Постройте её в каком-либо графопостроителе (Desmos, Geogebra, Matlab и т.п.).</task>

</div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
</body>
</html>

