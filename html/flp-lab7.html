<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <h2>Транслятор и результат трансляции</h2>
      
      <p>Транслятор&nbsp;— это функция, которая преобразует входную последовательность символов (строку, или поток лексем) в некий результат. Результатом может быть любое значение: логическое, если нас интересует только соответствие текста заданной грамматике, последовательность выходных значений, синтаксическое дерево, или даже просто число. То есть, тип транслятора, в самом общем случае, может быть каким-то таким:</p>

      <pre><hs>data Parser i a = Parser ([i] -> a)</hs></pre>
      
      <p>где <code>i</code>  тип элементов входного потока, а <code>a</code>&nbsp;— тип результата. Например, лексический анализатор, читающий программу в виде строки, и возвращающий список лексем может иметь тип <code>Parser Char [Token]</code>.</p>
      
      <p>Для того, чтобы нам было легче применять спрятанную в тип <code>Parser</code> функцию-преобразователь, дадим ей имя:</p>

      <pre><hs>data Parser i a = Parser { run :: [i] -> a }</hs></pre>
      
      <p>Определим какой-нибудь самый простой транслятор. Очень простой. </p>

      <pre><hs>next = Parser head</hs></pre>

     
      <p>  Он просто возвращает первый элемент разбираемой последовательности, каким бы он ни был:</p>

      <pre><ghci><l></l> run next "abab"
<o>'a'</o>
<l></l> run next "bab"
<o>'b'</o></ghci></pre>

      <p> Транслятор работает, но он практически бесполезен, ведь мы потеряли информацию о разбираемой строке и не сможем продолжить разбор. Это приводит к мысли, что возвращаемый результат должен каким-то образом содержать в себе разбираемую строку. Объединим их в типе <code>Result</code>, на который можно посмотреть и сравнить с чем-нибудь:</p>

      <pre><hs>data Parser i a = Parser { run :: [i] -> Result [i] a}

data Result i a = Result i a
  deriving (Show, Eq)
	  
next = Parser $ \(x:xs) -> Result xs x</hs></pre>

      <pre><ghci><l></l> run next "abab"
<o>Result "bab" 'a'</o></ghci></pre>

      <p> Теперь работа транслятора стала более осмысленной, он вернул первый элемент и сократил разбираемую строку.</p>
    
      <p>А что дальше? Как нам снова применить функцию <code>next</code> к полученному результату?</p>

      <h2>Последовательное выполнение трансляторов</h2>

      <p>Притворимся, что мы ничего не знаем о функторах и монадах и придумаем их ещё раз, чтобы лучше понять, для чего они нужны и как устроены. Чтобы притвориться по-настоящему, скроем определения для монадических операторов, загружаемых стандартной библиотекой:
            <pre><hs>import Prelude hiding ((>>),(>>=),return, pure)</hs></pre>
      </p>
      
      <p>Определим комбинатор <code>>></code>, "соединяющий" трансляторы в цепочку: </p>

      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Result r' _ -> run t2 r'  </hs></pre>

      <p>Форма <code>case</code> потребовалась нам для того, чтобы "разобрать" результат работы транслятора <code>t1</code> и добыть остаток строки. Можно было воспользоваться формой <code>let</code> или <code>where</code>, но, во-первых, она читается более естественно: от <code>t1</code> к <code>t2</code>, а во-вторых, скоро мы добавим другие альтернативы.</p>
    
      <p>  Комбинатор <code>>></code> возвращает новый транслятор, так что его тоже можно применить к разбираемой строке с помощью функции <code>run</code>. Попробуем его использовать:</p>     
      <pre><ghci><l></l> run (next >> next) "abab"
<o>Result "ab" 'b'</o>
<l></l> run (next >> next >> next) "abab"
<o>Result "b" 'a'</o></ghci></pre>
      
      <p>Переходя ко второму транслятору и далее мы потеряли информацию о первом встреченном символе, но пока она и не нужна: транслятор <code>next</code> её всё равно не использует. И мы тоже пока об этом думать не будем.</p>

      <h2>Право на ошибку</h2>

      <p> Пора научится задавать для разбираемой последовательности какие-либо правила. Например, можно потребовать, чтобы первым символом был символ <code>'a'</code>, и если это так, продолжить разбор. А если не так? В этом случае надо прекратить разбор выражения и как-то показать, что трансляция завершилась неудачно.</p>
    
      <p> Расширим тип для результата трансляции, разделив его на успешную трансляцию и неудачную:</p>

      <pre><hs>data Result i a = Ok a i
                | Fail i
  deriving (Show, Eq)</hs></pre>

      <p> В случае неудачи, тип содержит неразобранную часть строки. На всякий случай.</p>
 
      <p>Раз мы изменили описание типа <code>Result</code>, нужно поменять и определение комбинатора <code>>></code>, чтобы он учитывал возможные исходы разбора и в случае неудачи, постигшей первый транслятор, не пытался вызывать следующий:</p>
      
      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Ok _ r' -> run t2 r'
  Fail r' -> Fail r'</hs></pre>

      <p> Кроме того, транслятор <code>next</code> может стать несколько "умнее"&nbsp;— если строка пуста, никакого следующего символа в ней нет, а это означает неудачу в разборе:</p>

      <pre><hs>next = Parser $ \r -> case r of
  [] -> Fail r
  x:xs -> Ok x xs</hs></pre>
          
      <p>Напишем теперь транслятор, который будет требовать, чтобы анализируемая строка начиналась с конкретного символа. Опять же, сначала для этого нужно удоствериться в том, что разбираемая строка не пуста:</p>

      <pre><hs>term c = Parser $ \r -> case r of
  [] -> Fail []
  x:xs -> if x == c
          then Ok x xs
          else Fail r </hs></pre>

      <p>Посмотрим, как он работает:</p>

      <pre><ghci><l></l> run (term 'a') "abab"
<o>Ok 'a' "bab"</o>
<l></l> run (term 'b') "abab"
<o>Fail "abab"</o>
<l></l> run (term 'a' >> term 'b') "abab"
<o>Ok 'b' "ab"</o>
<l></l> run (term 'b' >> term 'b') "abab"
<o>Fail "abab"</o>
<l></l> run (term 'a' >> next >> term 'a') "abab"
<o>Ok 'a' "b"</o>
</ghci></pre>

      <p> Очень хорошо! Но сразу же хочется сделать ещё лучше. А когда делаешь лучше главное&nbsp;— не сделать хуже. В этом нам поможет тестирование.</p>
    
      <task>Напишите функцию-тестировщик.

      <pre><hs>test (p, inp, outp) = when (res' /= outp) msg
  where
    res' = run p inp 
    msg = format "Fail.\n  input:    _\n expected: _\n got:      _\n"
	  [show inp, show outp, show res']</hs></pre>

      <p>Здесь нам понадобились функции <code>when</code>  и <code>format</code>, написанные нами ранее. Применять тестировщик можно к списку трансляторов, входных и ожидаемых выходных значений таким образом:</p>
    
    <pre><hs>runTests lst = putStr $ foldMap test lst
	
tests = runTests	
  [ (term 'a',             "abab", Ok 'a' "bab")
   ,(term 'a',             "bbab", Fail "bbab")
   ,(term 'a' >> term 'b', "abab", Ok 'b' "ab")
   ,(term 'b' >> term 'b', "abab", Fail "abab") ]</hs></pre>
      
      <p> Запускаем тесты...</p>
      <pre><ghci><l></l> tests</ghci></pre>
      <p> и видим, что ничего не выводится. Значит, у нас всё хорошо. Испортите какой-нибудь из тестов и посмотрите, что будет.</p>
      </task>

      <p>Теперь можно смело двигаться дальше!</p>

      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok a i | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: [i] -> Result [i] a }</p></basic>

<part>комбинаторы</part>
<p><basic>>></basic></p>

<part>трансляторы для коллекций</part>
<p><basic>next  term</basic></p>
</sinopsys>
      </details>

      <h2>Повышение модульности</h2>

      <p> Один из принципов Unix (и Haskell) гласит: <disclaim>"Одна функция должна делать только одно дело,<br/> но делать его хорошо."</disclaim> Наши трансляторы <code>next</code> и <code>term</code> работают хорошо, но делают по два дела каждая: проверяют не пуста ли строка и, собственно, выполняют свои задачи. Не поручить ли проверку на пустоту специальному транслятору? Назовём его, например, <code>notEnd</code>:</p>

      <pre><hs>notEnd = Parser $ \r -> case r of
  [] -> Fail []
  _ -> Ok () r</hs></pre>

      <p>Здесь мы в качестве результата разбора, в случае не пустой строки, возвращаем пустое значение. То есть, всё получилось, но возвращать нам нечего. Такие трансляторы, которые не возвращают какого-либо значения, а только проверяют строку на соответствие будем называть <our>анализаторами</em>.</p>

      <p>Теперь мы можем переопределить наши трансляторы <code>next</code> и <code>term</code> попроще:    </p>

      <pre><hs>next = notEnd >> (Parser $ \(x:xs) -> Ok x xs)
    
term c = notEnd >> Parser $ \(x:xs) -> if x == c
                                       then Ok x xs
                                       else Fail (x:xs)</hs></pre>

      <p>Запускаем тесты...
	<pre><ghci><l></l> tests</ghci></pre>
	мы ничего не поломали!</p>
    

      <hr/><task> Нет предела совершенству, но стремление к нему похвально. Функция <code>term</code> длинная, и всё ещё делает два дела: задаёт вопрос первому символу и сокращает строку. Было бы лучше определить его как-нибудь по-понятнее. Скажем, так:</p>

	<pre><hs>term c = check (== c) >> next</hs></pre>	
      
	<p>Напишите анализатор <code>check</code>, который продолжает разбор в случае, если выполняется некоторое условие на первый символ. Разбираемую строку он при этом не сокращает.</p>    
      </task>

      <hr/><task> С помощью анализатора <code>check</code> определите транслятор <code>digit</code>, ожидающий вначале строки цифру. Для него должны выполняться, например, такие тесты:
	<pre><hs>(digit, "23x", Ok '2' "3x")
(digit, "abc", Fail "abc")
(digit >> digit, "23x", Ok '3' "x")</hs></pre>
      </task>

      <hr/><task>Продолжим заманчивый путь абстракции. Напишите анализатор <code>end</code>, ожидающий окончания строки. А чтобы не было скучно, добавьте универсальный комбинатор <code>neg</code>, который возвращал бы отрицание указанного транслятора <code>p</code>: "что угодно, только не <code>p</code>". Так, например, с его помощью можно будет определить транслятор <code>notEnd</code>:
      <pre><hs>notEnd = neg end</hs></pre>

	<p> Тут нам и должно пригодиться то, что неудачный результат хранит в себе неразобранную строку. На всякий случай.</p>

	<p> Добавим в список тестов такие проверки:</p>

	<pre><hs>runTests 
  [ (neg end, "abc", Ok () "abc")
  , (term 'a' >> end, "a", Ok () "")
  , (neg digit, "abc", Ok () "abc")
  , (neg digit, "2bc", Fail "2bc") ]</hs></pre>

	<p> Для этого надо сделать так, что бы функция <code>tests</code> выполнила первый блок проверок, а затем&nbsp;— второй. Это делается с помощью специальной формы <code>do</code></p>

      <pre><hs>tests = do runTests 
             [ ... ]
           runTests 
             [ ... ]</hs></pre>

	<p>Об этой форме мы ещё обязательно поговорим, но позже</p>
	
      </task><hr>

      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok a i | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: [i] -> Result [i] a }</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic></p>

<part>комбинаторы</part>
<p><basic>>></basic></p>

<part>трансляторы для коллекций</part>
<p><basic>end  next</basic>  term</p>

<part>трансляторы для строк</part>
<p>digit</p>
</sinopsys>
      </details>

      
      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

