Когда у вас в руках молоток, то всё вокруг кажется гвоздями. Эту поговорку можно вынести эпиграфом к учебному пособию по теории категорий или абстрактным алгебрам. 

###Из пушки по воробьям###

Стрельба из пушки по воробьям может быть неплохим упражнением: и пушка не ржавеет и воробьям гимнастика. Давайте-ка применим моноиды и их свойства для решения задачи FizzBuzz.

По условию задачи следует написать программу, которая выводит на экран числа от 1 до 100, при этом вместо чисел, кратных 3, программа должна выводить слово "Fizz", а вместо чисел, кратных 5 — слово "Buzz". Если число кратно и 3, и 5, то программа должна выводить слово "FizzBuzz". Универсальное, линейное, легко расширяемое и простое императивное решение использует строковый аккумулятор. Приведём это решение на JavaScript:

```js
function fizzbuzz(n) {
  var res = ""
  if (n % 3 == 0) res += "Fizz"
  if (n % 5 == 0) res += "Buzz"
  return res == "" ? String(n) : res
}

for(var i = 1; i <= 100; i++)
	console.log(fizzbuzz(i))
```

Использование аккумулятора, тем более, строки, наводит на моноидальные мысли. Один моноид напрашивается сам собой -- строка, в которую мы что-то добавляем, но в этом решении задействован ещё один менее явный моноид. Давайте перепишем функцию fizzbuzz, вынеся за скобки присваивание:

```js
function fizzbuzz(n) {
  var res = ((n % 3 == 0) ? "Fizz" : "") + ((n % 5 == 0) ? "Buzz" : "")
  return res == "" ? String(n) : res
}
```

```js
function when(p,s) { return x => p(x) ? s : "" } 
```

```js
function fizzbuzz(n) {
  var res = (when (n % 3 == 0, "Fizz") + (when(n % 5 == 0, "Buzz")
  return res == "" ? String(n) : res
}
```

```js
function fizzbuzz(n) {
  return Math.min(String(n), when (n % 3 == 0, "Fizz") + when(n % 5 == 0, "Buzz"))
}
```

```haskell
fizzbuzz n = min (show n) (when (n % 3 == 0) "Fizz" <> when (n % 5 == 0) "Buzz")
```

```haskell
fizzbuzz = min <$> show <*> when (divBy 3) "Fizz" <> when (divBy 5) "Buzz"
```


