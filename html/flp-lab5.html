<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      <h2>Полугруппы и моноиды</h2>

      <task>Загрузите модуль <code>Data.Monoid</code>. Изучите информацию о классе <code>Monoid</code> с помощью команды <tt>:t</tt> в <sl>GHCi</sl>.</task>

      <task>В модуле <code>Data.Monoid</code> для функции <code>mappend</code> определено более котороткое обозначение: <code>&lt;&gt;</code>. Поэкспериментируйте со следующими моноидами:
	<pre><hs> [1,2,3] <> [5,6]
 "Hello" <> " world" <> "!"
 mempty :: String
 Sum 5 <> Sum 10
 mempty :: Sum Int
 Product 3 <> Product 5
 mempty :: Product Int
 Any True <> Any False
 All True <> All False</hs></pre>
      </task>

      <task>С помощью функции <code>foldMap</code> найдите для списка <code>[2,4,-3,10,6]</code>
	<ul>
	  <li> сумму,
	  <li> произведение,
	  <li> все ли элементы чётные,
	  <li> есть ли в списке отрицательные числа
	</ul>
      </task>

      <div class="disclaimer">Сами по себе моноиды были бы не столь полезны в программировании, если бы не два свойства:<ul>
	  <li> произведение типов-моноидов также образует моноид
	    <pre> (m1, m2) <> (n1, n2) = (m1 <> n1, m2 <> n2)
 mempty = (mempty, mempty)</pre> 
	  <li> функции, возвращающие моноид сами образуют моноид
	    <pre> f <> g = \x -> f x <> g x
 mempty = const mempty</pre> 
	</ul>
      </div>
      
      <h3>Произведение моноидов</h3>

      <task>Используя свойство произведения моноидов получите за один проход списка сумму и произведение его элементов. Посчитайте за один проход по списку чисел значение их среднено арифметического.</task>

      <task>Определите экземпляр класса <code>Monoid</code> для типов <code>Min a</code> и <code>Max a</code>, соответствующих минимальному и максимальному значению аргумента, имеющего тип <code>a</code>. Включите нейтральные элементы в описание этих типов.</task>

      <task>Найдите для заданного списка чисел за один проход сумму и произведение элементов, а также минимальный и максимальный элементы.</task>
     
      <task>Определите оператор <code>&&&</code> имеющий тип:<pre><hs><def>(&&&) :: (a -> b) -> (a -> c) -> (a -> (b,c))</def></hs></pre> Решите с его помощью предыдущую задачу.</task>

      <task>Исключите нейтральные элементы из определения типов <code>Min a</code> и <code>Max a</code>, и определите экземпляр класса <code>Monoid</code> для типов <code>Maybe (Min a)</code> и <code>Maybe (Max a)</code>. Удостоверьтесь, что минимальное и максимальное значения в списках находится правильно.</task>

      <task>Допишите определение функции <code>wc</code>, подсчитывающей за один проход текста количество строк, слов и символов. 
	<pre><hs><def>wc :: String -> (Int, Int, Int)</def>
wc s = getResult $ foldMap count $ zip s (tail s) 
  where
    getResult (a, (b, c)) = _

    count = countWords &&& countLines &&& countChars 

    -- счётчики
    countWords = _ -- границ между словом и любым пробельным символом
    countLines = _ -- символов переноса строки
    countChars = _ -- всех символов</hs></pre>
      </task>
      
      <h3>Функции, возвращающие моноид</h3>

      <task>Удостоверьтесь в том, что функции, возвращающие моноид сами образуют моноид на нескольких примерах. Напишите определение функции <pre><hs><def>when :: Monoid m => (a -> Bool) -> m -> a -> m</def></hs></pre> Решите задачу <a >FizzBuzz</a>, используя эту функцию и то обстоятельство, что строки образуют моноид.</task>
      
      <task>Моноид образует тип <code>Ordering</code>. Выясните что является моноидальной суммой и нейтральным элементом для этого типа.</task>

      <task>Определите тип <code>Person</code> для записи информации о клиенте, содержащий имя <code>name :: String</code>, возраст <code>age :: Int</code> и семейное положение <code>married :: Bool</code>. С создайте небольшую "клиентскую базу" из 6 записей. Напишите функцию <code>comparing :: Ord b => (a -> b) -> a -> a -> Ordering</code>, которая позволит сравнивать записи по отдельным полям. Выясните тип для композиции <pre><hs> comparing name <> comparing age</hs></pre> </task>

      <task>Используя функции <code>sortBy</code> их модуля <code>Data.List</code> отсортируйте вашу базу, используя следующие приоритеты  ключей:
	<ul>
	  <li>возраст <eq>\to</eq> имя,
	  <li> имя  <eq>\to</eq> семейное положение,
	  <li> семейное положение <eq>\to</eq> возраст <eq>\to</eq> имя.
	</ul>
      </task>
      
      <h3>Быстрое умножение</h3>
      
      <p>Быстрое умножение, известное как "русское" или "египетское" умножение, -- это метод позволяющий призводить многократную композицию бинарной ассоциативной операции. Под умножением моноида на число будем понимать следующее:<pre>0×a = mempty
1×a = a
2×a = a <> a
3×a = a <> a <> a
...</pre>
	Способ основан на очень простых преобразованиях:
	<pre>если множитель чётный:    2na = n(2a)
если множитель нечётный:  (2n+1)a = a + 2na</pre>

	Ниже приводится классический вариант быстрого умножения для чисел. Обобщите его для произвольного моноида.
	<pre><hs>times :: (Num n, Integral i) => i -> n -> n
0 `times` _ = 0
0 `times` _ = 0
10 `times` _ = 0
	    n `times` a | r == 0    = b
            | otherwise = a + b
  where
    (q, r) = n `divMod` 2
    b = q `times` (a + a)
</hs></pre>

      </p>



      
      
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

