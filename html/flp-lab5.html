<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <h2>Язык для описания изображений</h2>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о моноидах, построим гибкую и расширяемую систему для вывода графики, использующую общедоступный web-интерфейс. Наша система будет представлять собой небольшой <em>встроенный предметно-ориентированный язык</em> (EDSL) для декларативного описания графики. Этот язык будет транслироваться в изображения формата SVG (Scalable Vector Graphics — это текстовый формат, используемый веб-браузерами и многими векторными графическими редакторами, такими как <sl>Corel Draw</sl>, <sl>Inkscape</sl> и т.п.) или в код на языке JavaScript, так чтобы можно было создавать растровое изображение (форматов JPG, PNG, и т.п.)</p>

      <p>Опишем возможности разрабатываемого языка. С его помощью можно:<ul>
	  <li> описывать элементарные фигуры: ломаные линии, точки, круги и т.д.;
	  <li> трансформировать эти фигуры: вращать, масштабировать, перемещать...;
	  <li> задавать стиль элементов изображения (цвет, заливку, толщину линий и т.п.);
	  <li> и, самое главное, комбинировать изображения: накладывать друг на друга, размещать их, указывая что один объект находится сбоку или сверху от другого и т.д. 
	</ul>
	По существу, мы построим алгебру изображений и научимся её вычислять (интерпретировать), получая реальные изображения в общедоступных графических форматах.</p>

      <h3>Типы для графических примитивов и изображений</h3>
      
      <p>Определим тип <code>Primitive</code> для представления двух (для начала) графических примитивов: точек и ломаных линий. Изображение будет представлено типом <code>Picture</code>, объединяющим множество примитивов:</p>
      <pre><hs>type Pt = (Float, Float)
  
data Primitive = Point Pt
               | Line [Pt]
               deriving Show

data Picture = Picture [Primitive] deriving Show</hs></pre>

      <p>Сразу продумаем как можно помбинировать примитивы и изображения. Самый непротиворечивый способ — накладывать их друг на друга, то есть, изображать на одном холсте.</p>
      <div class='equation' style='width:70%'>
	<table>
	  <tr>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<circle cx='44' cy='34' r='30'  fill='red' stroke='black'/>
	    </svg></td>
	    <td><code>&lt;&gt;</code></td>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<polyline points=' 4,34 4,4 34,4 34,34 4,34' fill='blue' stroke='black'/>
	    </svg></td>
	    <td>=</td>
	    <td><svg style="border: dotted 1px gray;" width='80' height='80'>
		<circle cx='44' cy='34' r='30' fill='red' stroke='black'/>
		<polyline points=' 4,34 4,4 34,4 34,34 4,34' fill='blue' stroke='black'/>
	    </svg></td>
	  </tr>
      </table></div>

	
      <p>
	Более того, изображения образуют моноид с операцией наложения (убедитесь мысленно, что наложение ассоциативно и имеет нейтральный элемент). Определим экземпляр класса <code>Monoid</code> для типа <code>Picture</code>:</p>
      <pre><hs>instance Monoid Picture where
  mempty = Picture mempty
  Picture p1 `mappend` Picture p2 = Picture (p1 &lt;&gt; p2)</hs></pre>

      <task>Напишите функции-конструкторы для элементарных фигур:
	<pre><hs>point :: Pt -> Picture
line :: [Pt] -> Picture
square :: Pt -> Float -> Picture
rectangle :: Pt -> Float -> Float -> Picture
triangle :: Pt -> Float -> Float -> Picture</hs></pre>
	У всех этих функций первый аргумент — это координата нижнего левого угла фигуры, другие агрументы задают ширину и высоту фигуры.
      </task>

      <task>Опишите с помощью имеющихся примитивов простенький рисунок, например, квадратный домик с треугольной крышей.</task>


      <h2>Представление примитивов в формате SVG</h2>
      
      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle rx='x' ry='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <task>SVG — это текстовый формат. Для того, чтобы упростить генерацию SVG напишите функцию <code>format</code> для форматирования строк по шаблону, последовательно заменяя символ <tt>'_'</tt> строками из списка. Например:
	<pre><ghci><l></l> format "_ said: '_'" ["John", "Hello!"]
<o>"John said: 'Hello!'"</o></ghci></pre>
	<em>Подсказка: воспользуйтесь функцией <code>splitOn</code> из модуля <code>Data.List.Split</code> для того, чтобы разбить форматируемую строку на части, а потом с помощью функции <code>zipWith</code> перемешайте эти части со строками из списка.</em>
      </task>

      <p>Определим собственный класс для того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
  toSVG :: a -> String</hs></pre></p>

      <task>Определите экземпляр этого класса для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG p = case p of
    Point (x,y) -> _
    Line pts -> _</hs></pre>
      </task>
      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='black'&gt;...&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения, прочие параметры задают графические атрибуты, используемые по умолчанию.</p>

      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code>, задав фиксированные размеры изображения, скажем, 400×300.</task>

      <task>Запишите SVG-выражение, описывающее домик в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в веб-браузере. Создайте вспомогательную функцию <code>writeSVG</code> для удобного экспорта изображений в файл. <pre><hs>writeSVG :: SVG a => String -> a -> IO ()</hs></pre></task>

      <task>Напишите конструктор <pre><hs>polygon :: Pt -> Int -> Float -> Picture</hs></pre> для правильных многоугольников заданного размера (размер задаётся радиусом описанной окружности). Первый аргумент определяет центр пногоугольника.</task>
      <task>Создайте изображение, показанное на рисунке:
	<p><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>

      <h2>Определение размеров изображения</h2>

      <p>Правильнее было бы не фиксировать размеры поля изображения в SVG-описании, а вычислять его, находя минимальные и максимальные значения координат примитивов. Эта информация будет нужна нам и для размещения изображений друг относительно друга.</p>

      <p>Включим "рамку", обрамляющую изображения, в тип <code>Picture</code> и определим тип для координат рамки:</p>
      <pre><hs>data Picture = Picture (Box, [Primitive])
             deriving Show

type Box = ( (Min Float, Min Float)
           , (Max Float, Max Float) )

instance Bounded Float where
  minBound = -1000
  maxBound = 1000</hs></pre>
      
      <p>В типе <code>Box</code> первая пара задаёт левый нижний угол изображения, а вторая – правый верхний. Для того, чтобы использовать полугруппы <code>Min</code> и <code>Max</code>, экпортируем их (и только их) из библиотеки <code>Data.Semigroup</code>. <pre><hs>import Data.Semigroup (Min(..), Max(..))</hs></pre> Для того, чтобы тип <code>Box</code> стал моноидом, мы определили минимальную и максимальную границы значений координат.</p>

      <p>
	В свою очередь, размеры изображения складываются из размеров примитивов, его составляющих. Значит, имеет смысл определить класс для типов, имеющих размер. Создадим такой класс, а в нём опишем несколько универсально полезных функций, имеющих для всех экземпляров класса определение по умолчанию
	<pre><hs>class Boxed a where
  box :: a -> Box

  width :: a -> Float
  width p = x2 - x1
    where ((Min x1,_),(Max x2,_)) = box p

  height :: a -> Float
  height p = y2 - y1
    where ((_,Min y1),(_,Max y2)) = box p</hs></pre>
	  Для экзепляров класса <code>Boxed</code> достаточно определить функцию <code>box</code>, все остальные выводятся через неё. Так, например определяется экземпляр <code>Boxed</code> для типа <code>Picture</code>:
	  <pre><hs>instance Boxed Picture where
  box (Picture (b,_)) = b</hs></pre>

	  А так можно опредлить размеры для точки:
	  <pre><hs>instance Boxed Pt where
  box (x,y)= ((Min x, Min y), (Max x, Max y))
  width _ = 0
  height _ = 0</hs></pre> 
      </p>   

      <task>Определите экземпляр <code>Boxed Primitive</code>. Используйте моноидальные свойства типа <code>Box</code> при вычислении рамки для примитива <code>Line</code>.</task>

      <task>Надо ли изменять что-либо в определении экземпляра <code>Monoid&nbsp;Picture</code>?</task>
      
      <task>Переопределите конструкторы <code>poiny, line, square, ...</code>
	<p>Для этого имеет смысл определить вспомогательную функцию <code>primitive</code>, которая выполняла бы необходимые вычисления обрамляющей рамки для формируемого изображения:
	  <pre><hs>primitive :: Primitive -> Picture</hs></pre>
      </task>

      <task>Наконец, используйте информацию об обрамляющей рамке изображения для вычисления размеров, указываемых в заголовке SVG-файла. Для этого напишите ещё одну вспомогательную функцию для типа <code>Picture</code>:
	<pre><hs>contents :: Picture -> [Primitive]</hs></pre>
      </task>

      <task>Определите в классе <code>Boxed</code> универсальную функцию <code>corner</code>, возвращающую углы обрамляющей рамки изображения, или примитива
      <pre><hs>corner :: a -> ((Pt, Pt), (Pt, Pt))</hs></pre> и четыре селектора <code>left, right, upper, lower</code>
      так, чтобы можно было бы получить правый нижний угол изображения с помощью выражения:
      <pre><hs> right . lower . corner $ p</hs></pre></task>
      
      <h2>Преобразования изображений</h2>

      <p>
	Научимся изменять изображения. Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги, повороты и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг (или их композицию), а вектор <eq>\vec v</eq> — параллельный перенос. Преобразование можно выразить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преобразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т.п.) используется именно такая реализация афинных преобразований. 
      </p>

      <p>Приведём три основные вида преобразований:
	<ul>
	  <li> масштабирование осей <eq>x</eq> и <eq>y</eq> с множителями <eq>a</eq> и <eq>b</eq>:
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос вдоль вектора <eq>(x,y)</eq>:
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на угол <eq>\alpha</eq>:
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </p>

      <task>Применять афинные преобразования можно к разным объектам: точкам, примитивам и целым изображениям. Это наводит на мысль о классе <code>Affine</code>, который абстрагирует это свойство и определяет оператор афинных преобразований, обозначим его <code>affine</code>:
      <pre><hs>class Affine a where
  affine :: M Float -> a -> a</hs></pre>

Напишите экземпляры этого класса для типов <code>Pt</code>, <code>Primitive</code> и <code>Picture</code>. 
      </task>

      <p>Композиция афинных преобразований соответствует перемножению матриц. Это значит, что функцию <code>affine</code> можно вынести за скобки: <eqn>\mathrm{affine}\,T_1 \circ \mathrm{affine}\,T_2 \circ ... \circ T_n = \mathrm{affine}\,(T_1\,T_2,\,...\,T_n).</eqn> Сначала перемножить несколько небольших матриц, а потом применить к большому числу точек выгоднее, чем применять их ко всем точкам по очереди.</p>

      <p>Чтобы воспользоваться этим свойством преобразований нужно отделить применение преобразований от применения функции <code>affine</code>. Это можно сделать, расширив тип <code>Picture</code>, добавив в него явное преобразование изображения:
	<pre><hs>data Picture = Picture (Box, [Primitive])
             | Transform :$ Picture
             deriving Show</hs></pre>
	Это даёт нам возможность перед применением преобразований провести такую оптимизацию:</p>
      <p align='center'><tt>t1 :$ (t2 :$ p) = t1 &lt;&gt; t2 :$ p</tt></p> 
      <p>
	Для этого напишем функцию <code>transform</code>

	<pre><hs>transform p = case p of
  Picture p -> Picture p
  Transform t :$ Picture p -> affine t (Picture p)
  t1 :$ (t2 :$ p) -> transform $ (t1 &lt;&gt; t2) :$ p</hs></pre>

	Для преобразований определим тип-моноид <code>Transform</code>:
	<pre><hs>data Transform = Transform (M Float) deriving Show

instance Monoid Transform where
  mempty = Transform mempty
  Transform m1 `mappend` Transform m2 = Transform (m1 &lt;&gt; m2)</hs></pre>
      </p>
    
      <task>Тип <code>Picture</code> расширился, значит, определение класса <code>Monoid</code> для него, а также все функции, имеющие тип <code>Picture -> a</code> требуют дополнения. Внесите необходимые исправления, прежде чем двигаться дальше.</task>
    
      <task>Напишите, используя оператор <code>(:$)</code>, следующие преобразователи изображений:
	<pre><hs>scaleX :: Float -> Picture -> Picture -- масштабирует координату x
scaleY :: Float -> Picture -> Picture -- масштабирует координату y
scale :: Float -> Picture -> Picture -- одинаково масштабирует обе координаты
rescaleTo :: Float -> Float -> Picture -> Picture -- приводит изображение к указанным размерам 
shift :: Float -> Float -> Picture -> Picture -- параллельный перенос изображения
rotate :: Float -> Picture -> Picture -- поворот на угол, задаваемый в градусах вокруг центра координат
rotateAt :: Pt -> Float -> Picture -> Picture -- поворот вокруг указанной точки</hs></pre>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><hs>let s = square (0,0) 50
s &lt;&gt; rotate 45 s
s &lt;&gt; shift 10 30 s
s &lt;&gt; (scaleX 2 . scaleY 3) s
s &lt;&gt; rotate 60 s
s &lt;&gt; (shift 30 0 . rotate 60) s
s &lt;&gt; (rotate 60 . shift 30 0) s </hs></pre></task>      

      <p>Обратите внимание на то, как мы "переопределили" по-своему действие оператора композиции <code>(.)</code>  для преобразований. Смысл композиции остался прежним и результат от наших действий не изменится, но изменилась последовательность вычислений и их эффективность. Это очень характерный приём функционального программирования.</p>
      
      <task>Добавьте к типу <code>Primitive</code> конструктор <code>Circle Pt Float</code> для окружности. Пусть, для простоты, при преобразованиях окружности изменяется только положение центра координат. Окружность, которую можно транформировать произвольной матрицей (увеличивать, превращать в эллипс и т.д.) можно построить с помощью функции <code>polygon</code> с большим числом углов.</task>
      
      <task>Преобразователи позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига даёт нам возможность не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании квадрата и прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, задающий абсолютные координаты левого нижнего угла изображения. С его помощью, например, можно было бы построить квадрат с вписанной в него окружностью и расположить его в координатах (100, 100) так:
	<pre><hs>(circle 50 &lt;&gt; rectangle 50 50) `at` (100, 100)</hs></pre></task>
      
      <task>Объясните, каким образом вычисляется следующее выражение:
	<pre><hs>(rotate 30) &lt;&gt; (`at` (40, 40)) $ square 10</hs></pre>
      </task>

      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз, традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат. Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат.</task>

      <task>Постройте картинку, задаваемую выражением:
      	<pre><hs>mconcat $ take 48 $ iterate (rotate 7.5) $ square 50 `at` (25,25)</hs></pre>
	<p align='center'><img src="img/wheel.png"/></p>
      </task>

      <h2>Новые способы комбинирования изображений</h2>
      
      <task>Имея в своём распоряжении композицию изображений и операцию сдвига несложно определить ещё два полезных комбинатора, располагающих изображения рядом вертикально и горизонтально: <code>above</code> и <code>beside</code>. Напишите их определение так, чтобы при результаты были такими, как показано на рисунке:
	<pre><hs>circle 30 `beside` square 40</hs></pre>
	<p align='center'><svg width='108.0' height='68.0' fill='none' stroke='blue'><circle cx='34.0' cy='34.0' r='30.0'/><polyline points=' 64.0,64.0 104.0,64.0 104.0,24.0 64.0,24.0 64.0,64.0'/></svg></p>
	<pre><hs>circle 30 `above` square 40</hs></pre>
	<p align='center'><svg width='68.0' height='108.0' fill='none' stroke='blue'><circle cx='34.0' cy='34.0' r='30.0'/><polyline points=' 4.0,104.0 44.0,104.0 44.0,64.0 4.0,64.0 4.0,104.0'/></svg></p>
      </task>

      <task>Напишите две функции <code>row</code> и <code>column</code>, которые располагали бы список изображений в виде ряда или колонки. Например так:
	<pre><hs>row $ circle <$> [4,8,16,32,16,8,4]</hs></pre>
	<p align='center'><svg width='184.0' height='72.0' fill='none' stroke='blue'><circle cx='8.0' cy='64.0' r='4.0'/><circle cx='20.0' cy='60.0' r='8.0'/><circle cx='44.0' cy='52.0' r='16.0'/><circle cx='92.0' cy='36.0' r='32.0'/><circle cx='140.0' cy='52.0' r='16.0'/><circle cx='164.0' cy='60.0' r='8.0'/><circle cx='176.0' cy='64.0' r='4.0'/></svg></p>
      </task>

      <task>Напишите функцию <code>chart :: Picture -> [Int] -> Picture</code>, которая строила бы диаграммы для списков целочисленных значений, как показано на примере:
	<pre><hs>chart (square 10) [1,2,1,2,3,2,1,4,2,3,6,5,4,3,4,3,1,2,1]</hs></pre>
	<p align='center'><img src="img/chart1.png"/></p>
      </task>

      <task>Напишите функцию <code>barChart :: [Double] -> Picture</code>, которая строила бы столбчатую диаграмму для числовых списков, используя ширину столбца 1:
	<pre><hs>rescaleTo 200 100 $ barChart [1,2,3,2,3,4,5,4,3,2]</hs></pre>
	<p align='center'><svg fill='none' stroke='blue' width='204' height='104' ><polyline points=' 4.0,104.0 24.0,104.0 24.0,84.0 4.0,84.0 4.0,104.0'/><polyline points=' 24.0,104.0 44.0,104.0 44.0,64.0 24.0,64.0 24.0,104.0'/><polyline points=' 44.0,104.0 64.0,104.0 64.0,44.0 44.0,44.0 44.0,104.0'/><polyline points=' 64.0,104.0 84.0,104.0 84.0,64.0 64.0,64.0 64.0,104.0'/><polyline points=' 84.0,104.0 104.0,104.0 104.0,44.0 84.0,44.0 84.0,104.0'/><polyline points=' 104.0,104.0 124.0,104.0 124.0,24.0 104.0,24.0 104.0,104.0'/><polyline points=' 124.0,104.0 144.0,104.0 144.0,4.0 124.0,4.0 124.0,104.0'/><polyline points=' 144.0,104.0 164.0,104.0 164.0,24.0 144.0,24.0 144.0,104.0'/><polyline points=' 164.0,104.0 184.0,104.0 184.0,44.0 164.0,44.0 164.0,104.0'/><polyline points=' 184.0,104.0 204.0,104.0 204.0,64.0 184.0,64.0 184.0,104.0'/></svg></p>
      </task>

      <h3>Стиль изображений</h3>

      <p>Добавим нашему языку красок! Изменение атрибутов примитивов и изображений можно тоже рассмативать, как преобразование. С&nbsp;геометрическими преобразованиями мы уже разобралисьб а можно ли смешивать эти преобразования каким-либо однородным способом? Так, чтобы можно было бы написать и вычислить такое выражение:
	<pre><hs>(rotate 45 . color "red" $ square 20 `at` (30,20))
 <> (opacity 0.5 . fill "blue" $ circle 30)</hs></pre></p>
      <p align='center'><svg width='83.961945' height='112.246216' fill='none' stroke='blue'><g  fill="red"><polyline points=' 44.6066,74.71068 79.961945,39.355343 44.6066,4.0 9.251263,39.355343 44.6066,74.71068'/></g><g  stroke-opacity=0.5 fill-opacity=0.5 fill="blue"><circle cx='34.0' cy='78.246216' r='30.0'/></g></svg></p>
      
      <p>Кроме того, видно, что атрибуты изображения или примитива естественным образом комбинируются: можно задать и цвет линии и цвет заливки, а также прозрачность и все эти свойства "сложатся" у одного изображения. Это наводит на моноидальные мысли.</p>
      
      <p>Итак, наряду с геометрическими преобразованиями, мы имеем ещё один вид преобразований, имеющий моноидальные свойства. Значит, эти преобразования можно объединить в пару и получить обобщённое преобразование-моноид  с минимальными изменениями в коде. Изменим определение для типа	<code>Transform</code>:
	<pre><hs>data Transform = Transform (M Float, [Attribute])
  deriving Show</hs></pre>
	И введём тип для некоторых атрибутов: 

	<pre><hs>data Attribute = LineColor String
               | Fill String
               | LineWidth Float
               | Opacity Float
               deriving (Show, Eq)</hs></pre>

	Перед нами теперь встают три задачи: <ul>
	  <li> определить каким образом новые преобразования будут действовать на изображения;
	  <li> определить, как интерпретировать атрибуты изображений в формате SVG;
	  <li> созать набор функций-преобразователей: <code>color</code>, <code>fill</code> и т.д.;
	</ul>
      </p>

      
      <task>Имеет смысл присваивать стиль не каждому примитиву, а целым группам. Это соотвествует духу SVG, в котором существует элемент <code>g</code>, группирующий другие элементы.
	В формате SVG для атрибутов принято единообразное обозначение: <tt>attribute=value</tt>. Перечисленным в типе <code>Attribute</code> конструкторам соответствуют следующие параметры элементов SVG:
	<p>
	  <table>
	    <tr><td><code>LineColor</code></td><td><tt>stroke</tt></td></tr>
	    <tr><td><code>Fill</code></td><td><tt>fill</tt></td></tr>
	    <tr><td><code>LineWidth</code></td><td><tt>stroke-width</tt></td></tr>
	    <tr><td><code>Opacity</code></td><td><tt>stroke-opacity</tt> и <tt>fill-opacity</tt></td></tr>
	  </table>
	</p>
	
	<p> Группа, для которой установлены цвет линии и заливки декларируется следующим образом:
	  <pre>&lt;g stroke="red" fill="blue"&gt;...&lt;/g&gt;</pre>
	  Определите экземпляр класса <code>SVG Attribute</code>.</p>

	<p> Добавьте в тип <code>Primitive</code> конструктор для группы примитивов <code>Group&nbsp;[Attribute]&nbsp;[Primitive]</code> и расширьте все определения функций над примитивами.</p>
      </task>

      <task>Измените функцию <code>transform</code> следующим образом:
	<pre><hs>transform :: Picture -> Picture
transform pic = case pic of
  t1 :$ (t2 :$ p) -> transform $ (t1 &lt;&gt; t2) :$ p
  Picture p -> Picture p
  Transform (m, s) :$ Picture p -> app style s . app affine m $ Picture p
  where
    app e m = if m == mempty then id else e m
    style s (Picture (b,p)) = Picture (b, [Group s p]) </hs></pre>
      Объясните как работает функция <code>app</code>.</task>

      <task>С помощью вспомогательных функций
	<pre><hs>mkAffine :: M Float -> Picture -> Picture
mkAffine m = (Transform (m, mempty) :$)

mkStyle :: (t -> Attribute) -> t -> Picture -> Picture
mkStyle k v = (Transform (mempty, [k v]) :$)</hs></pre>
	Переопределите геометрические функции-преобразователи и введите преобразователи стиля
	<pre><hs>lineColor :: String -> Picture -> Picture -- цвет линии
fill :: String -> Picture -> Picture -- цвет заливки
color :: String -> Picture -> Picture  -- одинаковый цвет линии и заливки
lineWidth :: Float -> Picture -> Picture -- толщина линии
opacity :: Float -> Picture -> Picture -- прозрачность фигуры</hs></pre>
      </task>

      
      <p>Построенный нами встроенный язык построения изображений имеет несколько замечательных свойств:
	<ul>
	  <li> Он декларативен, но, в то же время, позволяет производить сколь угодно сложные вычисления для построения изображений;
	  <li> Он легко расширяем: можно вводить новые конструкторы примитивов и новые примитивы и их комбинаторы
	  <li> Все преобразования изображений однородны. Если потребуется ввести новый вид преобразований (например, фильтры или анимацию, доступные в SVG), достаточно будет расширить кортеж в типе <code>Transform</code> и объединить действие преобразователей в функции transform.
	</ul>
      </p>

      <task>Напишите функцию <code>plot</code>
	<pre><hs>plot :: (Float -> Float) -> Float -> Float</hs></pre>
	которая строит график произвольной числовой функции в указанных пределах по оси <eq>x</eq>. Пример использования:
	<pre><hs>rescaleTo 400 300 $ lineColor "blue" (plot sinc (-15) 15)</hs></pre>

	<p align='center'><svg width='408.0' height='308.0' fill='none' stroke='blue'><g  stroke="black"><polyline points=' 4,250.46 404,250.46'/><polyline points=' 204.00,304 204.00,4'/></g><g  stroke-width=2.0><polyline points=' 4,239.77 6,237.90 8,236.28 10,234.94 12,233.93 14,233.27 16,232.99 18,233.10 20,233.60 22,234.50 24,235.78 26,237.43 28,239.40 30,241.67 32,244.20 34,246.93 36,249.80 38,252.75 40,255.73 42,258.66 44,261.48 46,264.11 48,266.51 50,268.60 52,270.33 54,271.66 56,272.54 58,272.94 60,272.84 62,272.23 64,271.11 66,269.48 68,267.37 70,264.81 72,261.85 74,258.53 76,254.93 77.99,251.11 79.99,247.16 81.99,243.15 83.99,239.17 85.99,235.32 87.99,231.68 89.99,228.34 91.99,225.38 93.99,222.89 95.99,220.95 97.99,219.60 99.99,218.90 101.99,218.91 103.99,219.63 105.99,221.09 107.99,223.29 109.99,226.20 111.99,229.79 113.99,234.02 115.99,238.82 117.99,244.11 119.99,249.80 121.99,255.78 123.99,261.93 125.99,268.14 127.99,274.27 130,280.17 132,285.73 134,290.78 136,295.20 138,298.85 140,301.61 142,303.36 144,303.99 146,303.43 148,301.60 150,298.44 152,293.92 154,288.02 156,280.75 158,272.14 160,262.24 162,251.12 164,238.87 166,225.60 168,211.45 170,196.56 172,181.09 174,165.23 176,149.15 178,133.05 180,117.12 182,101.56 184,86.56 186,72.33 188,59.03 190,46.85 192,35.95 194,26.46 196,18.52 198,12.23 200,7.68 202,4.92 204,4 206,4.92 208,7.67 210,12.23 212,18.52 214,26.46 216,35.94 218,46.85 220,59.03 222,72.32 224,86.56 226,101.55 228,117.11 230,133.04 232,149.14 234,165.22 236,181.09 238,196.55 240,211.44 242,225.59 244,238.86 246,251.11 248,262.23 250,272.14 252,280.75 254,288.02 256,293.92 258,298.44 260,301.60 262,303.43 264,304 266,303.36 268,301.61 270,298.85 272,295.20 274,290.78 276,285.73 278,280.18 280,274.27 282,268.14 284,261.94 286,255.78 288,249.80 290,244.11 292,238.82 294,234.03 296,229.80 298,226.20 300,223.29 302,221.09 304,219.63 306,218.91 308,218.90 310,219.60 312,220.94 314,222.89 316,225.38 318,228.33 320,231.67 322,235.31 324,239.17 326,243.15 328,247.16 330,251.11 332,254.93 334,258.53 336,261.85 338,264.81 340,267.37 342,269.48 344,271.10 346,272.23 348,272.84 350,272.94 352,272.54 354,271.66 356,270.33 358,268.60 360,266.51 362,264.11 364,261.48 366,258.66 368,255.73 370,252.76 372,249.80 374,246.93 376,244.20 378,241.68 380,239.40 382,237.43 384,235.78 386,234.50 388,233.60 390,233.10 392,232.99 394,233.27 396,233.93 398,234.94 400,236.28 402,237.90 404,239.77'/></g></svg></p>
	Удостоверьтесь в том, что графики можно комбинировать, например, так:
	<pre><hs>(color "red" $ plot sinc (-15) 15) <>
  lineWidth 0.5 ((color "blue" $ plot sin (-15) 15) <>
                 (color "green" $ plot (1/) 0.3 15))</hs></pre>      </task>


     </div>

   <p id="footer"></p>
  <script src="../lib/postprocessing.js"></script>
 </body>
</html>

