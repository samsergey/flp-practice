<!DOCTYPE html>
<html lang="ru">
  <head>
    <title>Haskell. Краткая справка</title>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/HRef.css">
    <link rel="stylesheet" href="../css/idea.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">
    
    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
</head>
<body>
  <div id="toc" class="toc">
    <h1>Haskell.<br/>Краткая справка.</h1><hr/>
  </div>
  <div class="main"></p>

<h1>Haskell.<br/> Краткая справка</h1>

<hr />

<p><article></p>

<h2>Общие правила синтаксиса</h2>

<p>Программа на Haskell -- это последовательность определений функций. Определения могут следовать в произвольном порядке.</p>

<p>Определения отделяются друг от друга символом перевода строки.</p>

<p>В языке нет понятия последовательности операторов, поэтому нет необходимости в символе, отделяющем операторы (точки с запятой, например).</p>

<div class="disclaimer">
Haskell -- язык с двумерным синтаксисом: отступы и выравнивание имеют семантическое значение!
</div>

<pre><hs> x = if y>6 
     then 6
       else y  -- ошибка! лишние пробелы

 x = if y>6 
     then 6
     else y  -- правильно.
</hs></pre>

<p></article></p>

<hr />

<p><article></p>

<h2>Выражения</h2>

<p>Арифметические выражения записываются в инфиксной форме:</p>

<pre><hs> 2 + 3
 x * (n - 1)/2
 (x + y*z)^2
</hs></pre>

<p>Аппликация функции записывается в префиксной форме: </p>

<pre><tt>функция аргумент1 аргумент2 ...
</tt></pre>

<p>Скобки и запятые при аппликации не требуются.</p>

<pre><hs> sin 3.14             -- функция одного аргумента
 map f lst            -- функция двух аргументов
 foldl f x (tail lst) -- функция трёх аргументов
 -- третий аргумент – результата вызова функции
</hs></pre>

<p>Инфиксные операторы можно записывать в префиксной форме: </p>

<pre><hs> (+) 3 4          ≡ 3 + 4
 (+) 3 ((*) 4 13) ≡ 3 + 4 * 13
 (++) "abc" "XYZ" ≡ "abc" ++ "XYZ"
</hs></pre>

<p>Бинарные функции можно записывать в инфиксной форме:</p>

<pre><hs> f `map` lst      ≡ map f lst
 2 `elem` [1,2,3] ≡ elem 2 [1,2,3]
</hs></pre>

<h3>Каррирование (сечение) функций</h3>

<p>Если при вызове функции передать не все аргументы,
функция становится каррированой – результатом вызова станет
новая функция, которая при вызове и примет оставшиеся аргументы</p>

<pre><hs> (+ 2) 4                         ==> 6
 map (+ 2) [1,2,3]               ==> [3,4,5]
 map (map (* 2)) [[1,2],[3,4,5]] ==> [[2,4],[6,8,10]]

 -- фиксируем первый аргумент функции elem
 filter ( 5 `elem`) [[1,3,5],[5,6],[2,7]] 
 ==> [[1,3,5],[5,6]]

 -- фиксируем второй аргумент функции elem
 filter (`elem` [1,2,3,4]) [1,3,5,2]
 ==> [1,3,2]
</hs></pre>

<h3>Комбинирование функций</h3>

<p>Композиция</p>

<pre><hs> (f . g) x ≡ f (g x)
 (f . g . h) x ≡ f (g (h x))

 filter ((== 3).length) [ "кто", "не", "работает"
                        , "тот", "не", "ест" ] 
 ==> ["кто", "тот", "ест"]
</hs></pre>

<p>Оператор аппликации <code>$</code> позволяет избавиться от лишних скобок</p>

<pre><hs> f $ x ≡ f x
 f x $ g x ≡ f x (g y)
 f $ g $ h x ≡ f (g (h x))
 h $ f x $ g x ≡ h (f x (g y)) 
</hs></pre>

<p>Связь операторов аппликации и композиции</p>

<pre><hs> g $ f x ≡ (g . f) x
 map f $ map g lst ≡ map (f . g) lst
</hs></pre>

<p>Смена порядка аргументов</p>

<pre><hs> (flip f) x y z ≡ f z y x</hs></pre>

<h3>Дополнительные определения</h3>

<p>Форма <code>let</code> позволяет вводить локальные определения в выражениях.</p>

<p>Так определяются значения символов <code>v₁</code>, <code>v₂</code>, ... для вычислении выражения <code>expr</code>.</p>

<pre><hs> let v₁ = expr₁
     v₁ = expr₂
     ...
 in expr</hs></pre>

<p>Например:</p>

<pre><hs> let x = 5
     y = x^2-z
     z = 2*x-x^3
 in (z + y)*(z-y)</hs></pre>

<div class="disclaimer">
Дополнительные определения могут даваться в произвольном порядке. Однако необходимо избегать цикличных определений, они вызовут бесконечные вычисления.
</div>

<p></article></p>

<hr />

<p><article></p>

<h2>Определение функций</h2>

<h3>Простые определения</h3>

<pre><hs>f x = expr  -- унарная функция

g x y = expr  -- бинарная функция

x `op` y = expr  -- бинарная функция в инфиксной форме
</hs></pre>

<h3>Определение через каррирование</h3>

<pre><hs>g x y = expr  -- бинарная функция

f = g x  -- унарная функция

dub = map (* 2)

dub [1,2,3] ==> [2,4,6] 
</hs></pre>

<h3>Определение с образцом</h3>

<pre><hs>f patt₁ = expr₁
f patt₂ = expr₂
...
</hs></pre>

<p>Образцами могут быть</p>

<ul>
<li>литералы: числа, символы, списки литералов, строки</li>
<li>конструктор списка <code>(:)</code></li>
<li>конструкторы типов</li>
<li>символ <code>_</code>, означающий "всё, что угодно".</li>
</ul>

<pre><hs>fact 0 = 1
fact n = n * (fact $ n-1)

map _ [] = []
map f (h:t) = f h : map f t

count [_] = "one"
count [_, _] = "two"
count [_, _, _] = "three"
count _ = "many"</hs></pre>

<h3>Определение с охраной</h3>

<pre><hs>f args 
 | p₁ = expr₁
 | p₂ = expr₂
...
 | otherwise = expr
</hs></pre>

<p>Возвращает выражения <code>expr1</code>,<code>expr2</code>,... при выполнении соответствующих условий <code>p1</code>, <code>p2</code>,... Если ни одно из условий <code>p</code> не выполнилось, возвращает <code>expr</code>.</p>

<pre><hs>fact n 
  | n < 0 = error "факториал не определен"
  | n <= 1 = 1
  | otherwise = n * (fact $ n-1)</hs></pre>

<h3>Анонимные функции</h3>

<p>Анонимные функции определяются с помощью символов <code>\</code> и <code>-&gt;</code></p>

<pre><hs> \ x -> x*x
 \ x y -> x*x + y*y

 map (\ x -> x*x-x) [1,2,3]  ==> [0,2,6]
</hs></pre>

<p>При определении анонимной функции можно использовать сопоставление с образцом:</p>

<pre><hs> \ (x:xs) -> xs ++ [x]
 \ (Just x) y -> Just (x + y) 
 -- cм. раздел "Типы данных и функций"
</hs></pre>

<h3>Дополнительные определения</h3>

<p>Оператор <code data-language="haskell">where</code> позволяет вводить локальные определения</p>

<pre><hs>
f args = expr 
  where v₁ = expr₁
        v₂ = expr₂
        ...
</hs></pre>

<p>Вводит локальные определения символов <code>v₁</code>, <code>v₂</code>, ... для вычислении выражения <code>expr</code>.</p>

<div class="disclaimer">
Программы на Haskell очень "плотные" и  имеют свойство расти в ширину. Использование операторов композиции и аппликации позволяет вытянуть программу в длину и сделать её "прозрачнее". Но ещё лучше разбивать выражения на осмысленные именованные выражения с помощью `let` и `where`.
</div>

<p>Сравните:</p>

<pre><hs>tuples n lst = sum (map product (filter (\ x -> length x == n) (subsequences lst)))
</hs></pre>

<pre><hs>tuples n lst =
  sum $ 
  map product $ 
  filter ((== n).length) $ 
  subsequences lst 
</hs></pre>

<pre><hs>tuples n lst =  sum products
  where 
    products =  map product ntuples
    ntuples = filter ((== n).length) $ 
              subsequences lst 
</hs></pre>

<p></article></p>

<hr />

<p><article></p>

<h2>Условные выражения</h2>

<pre><hs> if p then expr₁ else expr₂</hs></pre>

<p>Возвращает <code>expr₁</code> если условие <code>p == True</code>, и <code>expr₂</code> -- иначе.</p>

<pre><hs> case expr of 
  patt₁ -> expr₁
  patt₂ -> expr₁
  ...
</hs></pre>

<p>Сопоставляет  выражение <code>expr</code> образцам <code>patt₁, patt₂, ...</code> и возвращает соответствующие им выражения.</p>

<p></article></p>

<hr />

<p><article></p>

<h2>Типы данных и функций</h2>

<p>Типы в языке Haskell играют три основные роли:</p>

<ul>
<li>идентификация и представление данных и функций</li>
<li>определение свойств данных и функций</li>
<li>проверка согласованности всех элементов программы</li>
</ul>

<div class="disclaimer"> 
Все имена типов, и только они, начинаются с заглавной буквы латинского алфавита.
</div> 

<p>В языке используются <em>алгебраические типы данных</em>, состоящие их небольшого набора <em>базовых типов</em>, которые можно комбинировать с помощью <em>конструкторов типов</em>, создавая при этом сколь угодно сложные структуры.</p>

<h3>Декларация типов</h3>
Определяя функцию, можно указать типы аргументов и тип возвращаемого значения явно. Но делается это в отдельной строчке, а не в теле определения. Например, так выглядит определение типа для простой числовой функции:

<pre><def>f :: Int -> Int</def>
<hs>f x = x^2 + 3*x `mod` 5</hs></pre>

Система типов языка позволяет компилятору автоматически выводить большинсво типов для данных и функций в программе. Однако явное указание типа определяемой функции бывает полезным.

<h3>Универсальные конструкторы типов</h3>

<p>Существуют <em>универсальные</em> конструкторы типов, отражающие основные операции над типами и не имеющие иной семантики.</p>
<pre><hs> () -- универсальный единичный тип
 (a,b) -- универсальное произведение типов a и b
 Either a b -- универсальная сумма типов a и b
 a -> b -- универсальный функциональный тип (экспоненциальный)
</hs></pre>

<p>Универсальность этих конструкторов состоит в том, что любые единичные или функциональные типы, а так же суммы и произведения типов можно взаимооднозначно сопоставить любым другим соответствующим конструкциям с какой-либо конкретной семантикой.</p>

<h3>Примитивные типы</h3>
<p>Конкретные (неуниверсальные) примитивные типы образуются с помощью конструкторов типов без аргументов или базовых типов.</p>

<p>К базовым типам данных относятся:</p>

<pre><hs>Int -- целое число (два байта)
Integer -- целое число произвольной величины
Float -- число с плавающей точкой (8 знаков)
Double -- число с плавающей точкой (16 знаков)
Char -- символ (юникода)</hs></pre>

<p>Примеры конкретных единичных типов:</p>

<pre><hs>True, 
False, 
Monday, 
Tuesday, 
Red, 
Blue, 
Nothing</hs></pre>

<h3>Типы-контейнеры</h3>
<p>Типы-контейнеры (контексты) образуются с помощью унарных конструкторов</p>

<pre><hs>Maybe a,
[a],
Sum a,
Velocity a</hs></pre>

<h3>Произведение типов</h3>
<p>Произведение типов образуется с помощью конструкторов типов арности 2 и выше.</p>
    
<pre><hs>-- бинарные конструкторы типов
Point Float Float, 
Rational Integer Integer, 
Person Name Age 

-- тернарные конструкторы типов
Rectangle Point Point Color
Date Year Month Day</hs></pre>

<h3>Сумма типов</h3>
<p>Роль оператора "суммы" играет оператор объединения типов <code>|</code></p>

<pre><hs>-- сумма единичных типов
Bool = True | False
   
Color = Red 
      | Blue 
      | Green

Day = Monday | Tuesday | Wednsday 
    | Thursday | Friday | Saturday | Sunday

-- сумма единичного типа и произведения типов
    
Tree = Node Int 
     | Branches Tree Tree</hs></pre>

<p>Типы могут быть параметризованы другими типами</p>

<pre><hs>Maybe a = Just a | Nothing

Either a b = Left a | Right b
  
Result a = Ok a | Error String</hs></pre>

<p>Новые типы объявляются с помощью оператора <code>data</code></p>

<pre><hs>data Point a = (a, a) | (a, a, a)

data Polygon = [Point Float]
</hs></pre>

<h3>Функциональный тип</h3>

<p>Функциии имеют тип, определяемый с помощью оператора <code>-&gt;</code></p>
унарная функция
<pre><def>f :: Arg -> Res</def></pre>

бинарная функция
<pre><def>g :: Arg₁ -> Arg₂ -> Res</def></pre>

-- бинарная функция, первый аргумент которой -- унарная функция</hs>
<pre><def>h :: (Arg' -> Res') -> Arg₂ -> Res</def></pre>

<p>Полиморфные функции, определены с точностью до типа. При этом произвольный тип записывается маленькой буквой.</p>

<pre><def>length :: [a] -> Int</def>

<def>map :: (a -> b) -> [a] -> [b]</def>

<def>filter :: (a -> Bool) -> [a] -> [a]</def>

<def>lookup :: a -> [(a,b)] -> Maybe b</def></pre>

<h3>Сопоставление с образцом и типы данных</h3>

<p>Конструкторы типов могут использоваться в операторе <code>case</code>:</p>

<pre><hs> case lookup k dict of
   Nothing -> "No entry"
   Just x -> "Found" ++ show x
</hs></pre>

<p>Конструкторы типов могут использоваться при определении функций с помощью сопоставления с образцом.</p>

<pre><hs>data Figure = Rectangle (Int, Int) Int Int
            | Square (Int, Int) Int
            | Point (Int, Int)</hs>

<def>area :: Figure -> Int</def>
<hs>area (Point     _)     = 0
area (Square    _ s)   = s * s
area (Rectangle _ w h) = w * h
</hs></pre>


<div class="disclaimer">
Типы функций в программе писать не обязательно, они будут выведены компилятором, однако, разобраться в сообщениях об ошибках типизации проще, если явно записать тип проектируемой функции.
</div>

<div class="disclaimer"> Внимательно читайте сообщения об ошибках типизации. Они позволят узнать о вашей собственной программе много нового!
</div>

<p></article></p>

<hr />

<p><article></p>

<h2>Классы типов</h2>

<p>Типы данных могут принадлежать одному или нескольким классам типов. Больше всего они похожи на интерфейсы в объектно-ориентированных языках программирования и позволяют реализовывать перегрузку функций. Класс типов определяет набор функций, определённых для любых экземпляров класса. В интерпретаторе можно получить информацию о классе типов с помощью команды <code>:i</code></p>

<h3>Часто встречающиеся классы типов</h3>
<pre><hs>Show -- определяет строковое представление для типов.
Eq -- определяет отношение эквивалентности.
Ord -- определяет отношение порядка.
Semigroup (Data.Semigroup) -- определяет полугруппу (множество в ассоциативной бинарной операцией).
Monoid (Data.Monoid) -- определяет моноид (полугруппу с нейтральным элементом).</hs></pre>

<h3>Числовые классы типов</h3>
<pre><hs>Num -- определяет представление в виде числа.
Integral -- определяет представление в виде целого числа.
Fractional -- определяет представление в виде дробного числа.
Floating -- определяет представление в виде числа с плавающей точкой.
Ratio (Data.Ratio)-- определяет представление в виде рационального числа.
Complex (Data.Complex)-- определяет представление в виде комплексного числа.
</hs></pre>

<h3>Классы, определяющие структуру</h3>
<pre><hs>Functor -- класс для функторов.
Applicative -- класс для аппликативных функторов.
Alternative (Control.Applicative) -- класс для альтернативных аппликативных функторов. 
Monad -- класс для монад.
Comonad (Control.Comonad) -- класс для комонад.
</hs></pre>

<p></article></p>

<hr />

<p><article></p>

<h2>Списки и функции для работы со списками</h2>

<h3>Литералы</h3>

<pre><hs>[] -- пустой список

[1, 2, 3] -- список чисел

[[1, 2], [3, 4, 5]] -- вложенный список

[1 .. 5] -- список чисел от 1 до 5

['a' .. 's'] -- список символов от 'a' до 's'

[2 ..] -- бесконечный список чисел, 2,3,4,...

[1, 3 .. 100] -- список чисел, 1,3,5,7,... 100

[1, 3 ..] -- бесконечный список чисел, 1,3,5,7,... 100
</hs></pre>

<h3>Конструкторы</h3>

<pre><hs> x : lst -- добавление элемента в начало списка

 lst₁ ++ lst₂ -- конкатенация списков

 lst ++ [x] -- добавление элемента в конец списка
</hs></pre>

<h3>Селекторы</h3>

<pre><hs> head lst -- возвращает первый элемент

 tail lst -- отбрасывает первый элемент

 lst !! n -- возвращает n-ый элемент, начиная с 0

 length lst -- возвращает длину списка

 take n lst -- возвращает первые n элементов

 drop n lst -- отбрасывает первые n элементов

 takeWhile p lst -- возвращает начало списка до первого элемента, для которого выполняется условие p

 dropWhile p lst -- отбрасывает начало списка до первого элемента, для которого выполняется условие p
</hs></pre>

<h3>Модификаторы</h3>

<pre><hs> map f lst -- возвращает список результатов применения функции f ко всем элементам списка

 zipWith f lst₁ lst₂ -- возвращает список результатов   применения функции f к последовательным парам элементов из списков

 filter p lst -- возвращает список элементов lst,      удовлетворяющих условию p

 reverse lst -- возвращает список с обратным порядком  элементов
</hs></pre>

<h3>Генераторы списков</h3>

<pre><hs>[f x | x <- lst] ≡ map f lst

[x | x <- lst, p x] ≡ filter p lst

[f x | x <- lst, p x] ≡ map f $ filter p lst

[(x, y) | x <- lst₁, y <- lst₂] -- возвращает список   всех пар элементов списков lst1 и lst2
</hs></pre>

<p></article></p>

<hr />

<p><article></p>

<h2>Ввод-вывод</h2>

<p>Haskell язык функциональный, чистый  и к тому же ленивый. Это значит, что формально ввод-вывод в программе на Haskell невозможен. Однако, без этого невозможно программировать, так что, конечно, операции ввода-вывода в языке реализованы. Но надо иметь в виду, что функции ввода-вывода очень плохо сочетаются с чистыми вычислениями. Они выделяются в отдельные функции, в которых вычисления организованы особым образом -- в виде цепочки вызовов с чётко определённым порядком.</p>

<h3>Базовые функции вывода</h3>

<pre><hs> -- вывод в консоль (stdout)
 print expr   -- выводит строковое представление выражения
 putStr s     -- выводит строку s
 putStrLn s   -- выводит строку s и возвращает каретку

 -- ввод с консоли (stdin)
 getChar      -- считывает символ
 getLine      -- считывает строку
 getContents  -- считывает символы до `EOF`

 -- вывод в файл
 writeFile file s  -- выводит строку s в файл file
 appendFile        -- добавляет строку s в файл file

 -- ввод в файл
 readFile          -- читает содержимое файла в строку
</hs></pre>

<h3>Организация последовательности вычислений</h3>

<p>Для организации последовательных вычислений используется блок <code>do</code>, или операторы <code>&gt;&gt;=</code> и <code>&gt;&gt;</code>.</p>

<pre><hs>
 do statement₁
    statement₂
    ...
</hs></pre>

<p>Здесь <code>statement</code> это либо функция вывода, либо функция ввода, но для того, чтобы получить доступ к вводимым величинам используется оператор <code>&lt;-</code></p>

<pre><hs> -- пример работы с консолью
 do putStr "Введите ваше имя:"
    name <- getLine
    putStr $ "Здравствуйте, " ++ name ++ "!"

 -- пример работы с файлом
 do putStr "Введите имя файла для чтения:"
    fin <- getLine
    putStr "Введите имя файла для записи:"
    fout <- getLine
    txt <- readFile fin
    writeFile $ unwords $ filter ((< 5).length) $ words txt
</hs></pre>

<div class="disclaimer">
Не пытайтесь смешивать чистые вычисления и побочные эффекты. Иначе страшная монада IO заберёт все результаты в гнездо и больше уже не отдаст. 
</div>

<p></article></p>

<hr />

<p><article></p>

<h2>Модули</h2>

<p>Любая программа на Haskell является модулем, который экспортирует свои определения. Но для того, чобы эти определения можно было бы импортировать, модуль нужно поименовать с помощью оператора <code>module</code>.</p>

<pre><hs> module ModuleName where -- экспортирует все определения
 module ModuleName (fun₁, fun₂, ...) where -- экспортирует лишь указанные определения
</hs></pre>

<p>При этом имя файла и модуля должны совпадать. Так модуль <code>ModuleName</code> должен быть записн в файле <code>ModuleName.hs</code>.</p>

<p>Импортируются молули командой <code>import</code></p>

<pre><hs> import Module1 -- импортирует все определения
 import Module1 (fun₁, fun₂, ...) -- импортирует только указанные определения
 import Module1 hiding (fun₁, fun₂, ...) -- импортирует все, кроме указанных определений
</hs></pre>

<p></article></p>

<hr />

<p></div>

<script>
function makeTOCitem(el, lev) {
    var text = el.innerHTML
    el.innerHTML = "<a id='" + text + "'>" + text +"</a>"
    TOC += "<div class='" + lev + "'><a href='#" + text + "'>" + text + "</a></div>"
}

function makeArticle(a) {
    makeTOCitem(a.getElementsByTagName("h2")[0],"l1")
    var heads = a.getElementsByTagName("h3")
    if (heads.length == 0) return
    for(var j = 0; j<heads.length; j++) {
    makeTOCitem(heads[j],"l2")
    }
}

var TOC = toc.innerHTML
var articles = document.getElementsByTagName("article")
for (var i = 0; i<articles.length; i++) 
    makeArticle(articles[i])
toc.innerHTML = TOC
</script>
    <script src='../lib/postprocess.js'></script>
    <script>
    document.onLoad = function () {
  var defs = document.getElementsByTagName("def")
  for (var i = 0; i<defs.length; i++) 
      defs[i].innerHTML = defs[i].innerText || defs[i].textContent
    }
</script>

    <script src="../lib/postprocessing.js"></script>
</body>
</html>
