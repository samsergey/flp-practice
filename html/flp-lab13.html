<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/idea.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->
<h2>Транслятор регулярных выражений</h2>

<p><img class='logo' src='img/regexp.jpg' width=20%/>Рассмотрим достаточно серьёзную и важную практически задачу разбора и трансляции регулярных выражений. Регулярные выражения представляют собой компактную форму описания регулярных грамматик, применительно к обработке текстовой информации. По-существу, это метаязык, подобный создаваемому нами языку описания трансляторов. Он очень широко используется в системном администрировании, в веб-программировании, в задачах обработки текстов. Регулярные выражения используются набором утилит, поставляемых в дистрибутивах UNIX (<tt>grep</tt>, <tt>awk</tt>, <tt>sed</tt> и т.д.), многими текстовыми редакторами. Большинство современных языков программирования имеют встроенную  или библиотечную поддержку регулярных выражений. Есть она и в языке Haskell, но мы построим собственный транслятор.</p>

<p>
  Транслятор регулярных выражений должен превращать строку в транслятор, соответствующий регулярному выражению. Например, строку <code>"a.b+"</code> он должен интерпретировать как выражение:

  <pre><hs> only (term 'a') <> only next <> msome (term 'b')</hs></pre>

<p>Таким образом, перед нами стоит задача трансляции строк в трансляторы. Такой процесс называется <strong>суперкомпилированием</strong>.</p>

 <p>Мы не будем здесь реализовывать полный набор функций, реализованных в стандартах POSIX или Perl, остановимся на основных элементах и их комбинаторах:</p>
					
 <p>Регулярное выражение может быть:</p>
   <ul>
     <li/> <em>символом-литералом</em>, которые представляют сами себя;
     <li/> метасимволом <code>.</code> (точка), представляющим <em>любой символ</em>;
     <li/> <em>символьным классом</em>  — набором символов в квадратных скобках <code>[&nbsp;]</code>, представляющим множество возможных символов (<code>[cat]</code> означает <code>c</code> или <code>a</code> или <code>t</code>); если требуется указать символы, которые не входят в указанный набор, то используют символ <code>^</code> внутри квадратных скобок (<code>[^cat]</code> — любой символ, кроме <code>c</code>, <code>a</code> или <code>t</code>); возможно указание диапазонов символов с помощью тире, например <code>[0-9]</code> — означает любой цифровой символ;
     <li/> <em>группой</em> — регулярным выражением, окружённым круглыми скобками;
     <li/> <em>последовательностью</em> регулярных выражений;
     <li/> <em>объединением</em> (перечислением) регулярных выражений;
     <li/> регулярным выражением с модификаторами повторения.
   </ul>

 <p>Приведём формальное описание грамматики регулярных выражений, трансляцию которых мы реализуем:</p>


<pre><nt>R</nt> = a     <ht>символ-литерал</ht>
    .     <ht>любой символ</ht>
    [<nt>C</nt>]   <ht>символьный класс</ht>
    (<nt>R</nt>)   <ht>группа</ht>
    <nt>R</nt>|<nt>R</nt>   <ht>объединение</ht>
    <nt>R</nt><nt>R</nt>    <ht>конкатенация (последовательность)</ht>
    <nt>R</nt><nt>M</nt>    <ht>модификация</ht>

символьный класс
<nt>С</nt> = a     <ht>символ-литерал</ht>
    a-b   <ht>диапазон символов</ht>
    ^<nt>C</nt>    <ht>отрицание класса</ht>

модификаторы повторения 
<nt>M</nt> = *     <ht>повторение элемента ноль или много раз</ht>
    +     <ht>повторение элемента один или много раз</ht>
    ?     <ht>повторение элемента ноль или один раз</ht></pre> 
</p>

 <p>Регулярные выражения "собираются" с помощью трёх операций — объединения, конкатенации и модификации, причём приоритет объединения ниже чем у конкатенации, а у конкатенации — ниже чем у модификаторов. Объединение можно определить функциональной свёрткой <code>chainr</code>, а конкатенацию осуществить в виде монадической суммы <code>msome</code>:</p>

<pre><hs>regexp_ = msome element `chainr` alt
  where
    alt = (<|>) <$ term '|'
    element = (group <|> (only <$> symbol)) <**> modifier
    group = regexp_ `between` "()"
    symbol = anychar <|> charClass <|> literal</hs></pre>

<p>Теперь определим элементы их интерпретацию. (Сейчас будет немного сюрреализма, но смысл в этом всё же есть.) Все элементы после распознавания транслируются в трансляторы, которые, в свою очередь свои результаты комбинируют в строку.</p>

 <p>Символ-литерал интерпретируется, как транслятор <code>term</code>.</p>
<pre><hs>literal = term <$> term `except` "?+*()[]|."</hs></pre>

 <p>Метасимвол <code>.</code> (точка) переводится в транслятор <code>next</code></p>
<pre><hs>anychar = next <$ term '.'</hs></pre>

 <p>Определение для символьных классов выглядит более сложным, но устроено достаточно прямолинейно:</p>

 <pre><hs>charClass = c `between` "[]"
   where
     c = except term <$> (term '^' *> chars)
         <|> oneof term <$> chars
     chars = msome (range <|> only char)
     char = term `except` "]"
     range = enumFromTo <$> char <*> (term '-' *> char)</hs></pre>

<p>Модификаторы сделаем функциями, как и разделитель <tt><|></tt>:</p>				

 <pre><hs>modifier = option <|> repeat0 <|> repeat1 <|> pure id
  where
    option = mopt <$ term '?'
    repeat1 = msome <$ term '+'
    repeat0 = mmany <$ term '*'</hs></pre>

 <p>Наконец, сам транслятор регулярных выражений превратим в полноценный транслятор:</p>
						
<pre><hs>regexp s = case run regexp_ s of
  Ok "" p -> p
  _ -> empty</hs></pre>

 <p>Вот как можно им пользоваться:</p>

 <pre><ghci><l></l> run (search (regexp "c.(t|p)")) "the cat has a cup"
<o>Ok ["cat","cup"] ""</o> </ghci></pre>

					
<p>Вот более полезный пример. Пусть нам нужно из извлечь параметры из URL:</p>
<pre>www.site.org?day=7&name=adam&fruit=apple</pre>
Мы можем сделать это с помощью регулярного выражения так:

 <pre><hs>params = search (regexp "[a-z]+=[^&]+")</hs></pre>

 <pre><ghci><l></l> run params "www.site.org?day=7&name=adam&fruit=apple"
<o>Ok ["day=7","name=adam","fruit=apple"] ""</o></ghci></pre>
 
 А так — транслировать в словарь:
 
 <pre><hs>params = search ((,) <$> key <*> (term '=' *> value))
  where key = regexp "[a-z]+"
        value = regexp "[^&]+"</hs></pre>

 <pre><ghci><l></l> run params "www.site.org?day=7&name=adam&fruit=apple"
<o>Ok [("day","7"),("name","adam"),("fruit","apple")] ""</o></ghci></pre>
 
 <task>Проверьте правильность работы транслятора регулярных выражений на нескольких примерах:
   <ul>
     <li> число с плавающей точкой,,
     <li> простой e-mail адрес,
     <li> дата в формате <tt>DD.MM.YYYY</tt>,
     <li> слова типа "тум-там-тум", "там-там-там-тарарам", "трам-тарарам-там-там" и т.д.
   </ul>
 </task>

 <task>Напишите трансляторы, заменяющие в предложении "What a wonderfull day it was!" все слова, начинающиеся с буквы 'w' (заглавной, или строчной, неважно) 1) на это же слово, но записанное в обратном порядке, 2) на длину слова.</task>


 <h2>Арифметические выражения в традиционной нотации</h2>

<p>Пора написать классический транслятор, который используется, как пробный камень во всех статьях по лексическому анализу и компиляции: транслятор произвольных арифметических выражений с учётом приоритетов, ассоциативности и скобок.</p>

<p> Грамматика арифметических выражений с левоассоциативными операциями такова:
  <eqns> E \rightarrow E ~(\text{'+'}~|~ \text{'}-\text{'})~T ~|~ T\\
    T \rightarrow T ~(\text{'*'}~|~\text{'/'})~ P ~|~ P\\
    P \rightarrow \text{'('}~ E ~\text{')'} ~|~ N
  </eqns>
  где <eq>N</eq>&nbsp;— целое число.
</p>

 <p>Можно честно перевести её к виду, исключающему левую рекурсию, но мы воспользуемся надёжным инструментом: вычислением цепочек <code>chainl</code>. Наделим термы <code>'+'</code>, <code>'-'</code> и т.д. функциональными свойствами:</p>
  
<pre><hs>add = (+) <$ term '+'
sub = (-) <$ term '-'
mul = (*) <$ term '*'
frac = div <$ term '/' </hs></pre>

<p>Имея такую свёртку, легко напишем транслятор арифметических выражений, производящий вычисления в ходе трансляции:</p>

<pre><hs>expr = _E
  where _E = _T `chainl` (add <|> sub)
        _T = _P `chainl` (mul <|> frac)
        _P = _E `between` "()" <|> integer

	add = (+) <$ term '+'
        sub = (-) <$ term '-'
        mul = (*) <$ term '*'
        frac = div <$ term '/'</hs></pre>

Проверяем:

<pre><hs>testExpr = runTestsFor expr
  [ ("23",                    Ok "" 23)
  , ("23+5",                  Ok "" 28)
  , ("23+5-13",               Ok "" 15)
  , ("23-5-13",               Ok "" 5)
  , ("23-(5-13)",             Ok "" 31)
  , ("2*3+4*5",               Ok "" 26)
  , ("2*(3+4)*5",             Ok "" 70)
  , ("32/2/2/2",              Ok "" 4)
  , ("32/(2/(2/2))",          Ok "" 16)
  , ("((((5))))",             Ok "" 5)
  , ("(2*(8-7/2)+5*8)/(2+3)", Ok "" 10)]</hs></pre>

Замечательно!

<hr><task>
  Перепишите определения <code>add</code>, <code>sub</code>, <code>mul</code>, <code>frac</code> так, чтобы транслятор <code>expr</code> переводил арифметические выражения в постфиксную форму, как в языках Fort или PostScript:

<pre><code>"23"         ==>  "23"
"23+5"       ==>  "23 5 +"
"23+5-13"    ==>  "23 5 + 13 -"
"23-5-13"    ==>  "23 5 - 13 -"
"23-(5-13)"  ==>  "23 5 13 - -"
"2*3+4*5"    ==>  "2 3 * 4 5 * +"
"2*(3+4)*5"  ==>  "2 3 4 + * 5 *"
"((((5))))"  ==>  "5"
"(2*(8-7/2)+5*8)/(2+3)"  ==>
       "2 8 7 2 / - * 5 8 * + 2 3 + /"</code></pre>
  
</task>

<hr><task>  Напишите транслятор арифметических выражений в префиксную скобочную форму, как в языке Lisp:

<pre><code>"23"         ==>  "23"
"23+5"       ==>  "(+ 23 5)"
"23+5-13"    ==>  "(- (+ 23 5) 13)"
"23-5-13"    ==>  "(- (- 23 5) 13)"
"23-(5-13)"  ==>  "(- 23 (- 5 13))"
"2*3+4*5"    ==>  "(+ (* 2 3) (* 4 5))"
"2*(3+4)*5"  ==>  "(* (* 2 (+ 3 4)) 5)"
"(2*(8-7/2)+5*8)/(2+3)"  ==>
    "(/ (+ (* 2 (- 8 (/ 7 2))) (* 5 8)) (+ 2 3))"</code></pre>
</task>

<hr><task> Добавьте в грамматику и в трансляторы унарный минус, так чтобы правильно интерпретировались такие выражения:

  <pre><code>-5
-(-5)
-3*3
3*(-3)
2+(-3)
2-(-3) </code></pre>
</task>

<hr><task> Напишите транслятор арифметических выражений в абстрактное синтаксическое дерево.</task>

<hr><task> Напишите вычислитель выражений в префиксной скобочной форме и транслятор из в префиксной скобочной формы в постфиксную.</task>

<hr><task>Напишите анализатор для условного оператора в языке C#.</task><hr/>

<h2>Чтение SVG</h2>

      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

