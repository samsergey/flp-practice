<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <h2>Знакомство с типами</h2>
    
    <div class='tasks'>
      
      <p>До сих пор мы не указывали типы у аргументов функций и возвращаемых ими значений. Но Haskell статически типизированный язык, а это значит, что все выражения в программе имеют определённый тип. Типы выводятся компилятором <em>автоматически</em> и это следствие чистоты языка.</p> 
       
      <task> Выясните тип следующих выражений в интерпретаторе с помощью команды <code>:t</code>      </task>
	<pre><ghci>:t 'a'
:t "Hello"
:t 56
:t [1..5]
:t 2 < 3
:t (<)
:t (==)
:t sin
:t map
:t (+)
:t (+ 2)
:t id
:t ($)
:t (.)
:t integrate
:t (\x -> x)
:t (\x y -> x)
:t (\x y -> x + y)</ghci></pre>	

      <p>Cм. <a href ='haskell-ref.html#Типы данных и функций' target='_blank'>Типы данных и функций</a>.</p>
      
      <task>Посмотрите информацию о типах с помощью команды <code>:i</code>      </task>
	<pre><ghci>:i Char
:i String
:i Bool
:i Int
:i []</ghci></pre>

      <p>Cм. <a href ='haskell-ref.html#Классы типов' target='_blank'>Классы типов</a>.</p>
      <task>Посмотрите информацию о классах типов с помощью команды <code>:i</code></task>
	<pre><ghci>:i Show
:i Eq
:i Ord
:i Num
:i Floating</ghci></pre>
         
      <p>Несмотря на то, что компилятор хорошо справляется с выводом типов, указывать явно тип определяемой в программе функции полезно. Это, во-первых, хорошая документация к функции. Во вторых, при работе с полиморфными функциями и типами, иногда компилятору требуются некоторые подсказки.</p>
  
      <div class="disclaimer">Основные принципы проектирования функциональных программ:
	<ul>
	  <li> Каждая функция должна делать только одно дело, но делать его хорошо.
	  <li> Полиморфные функции лучше специальных.
	  <li> Тотальные функции лучше функций, вызывающих исключения.
	  <li> Структура типов должна отражать логику и универсальные свойства моделируемых объектов, а не моделировать сами объекты.
	  <li> "Не готовьте еду при клиенте". Клиент — это внешний мир, с которым мы общяемся с помощью операций ввода-вывода или связываясь по протоколам. Чистые функции полностью готовят решение внутри себя, а потом предлагают его внешнему миру. 
	</ul>
	</div>
      
      <p>
	Общий подход к решению реальных (и учебных) задач, предлагаемый функциональным программированием состоит в следующем: <ul>
	  <li> разбиваем задачу на отдельные очень небольшие, логически замкнутые и чистые подзадачи, определяя метод их комбинирования
	  <li> определяем, вычисляем или выясняем тип функций, представляющих решение этих подзадач
	  <li> пишем прототипы функций и тестируем их в REPL
	  <li> комбинируем подзадачи для решения общей задачи
	  <li> на последнем этапе создаём связь с внешним миром — ввод/вывод
	</ul>
      </з>
      
      <h2>Списки и циклы</h2>

      <p>Списки в Haskell играют более фундаментальную роль, чем просто тип данных или контейнер. С их помощью выражаются циклические конструкции.</p>

      <task>Выведите на печать числа от 1 до 10 с помощью команды:</task>
      <pre><ghci><l></l> mapM_ print [1..10]</ghci></pre>

      <task>Выясните с помощью интерпретатора что делает функция <code>replicate</code> </task>

      <task>Напишем своё определение функции <code>replicate'</code>, как указано в примере.
	<pre><hs>replicate' n x = const x <$> [1 .. n]</hs></pre>
	 Выясните тип этой функции и удостоверьтесь, что она работает верно. Объясните смысл функции <code>const</code> и её тип.</task>

      <h2>Выделение части списка</h2>
	
	<task>Выясните и объясните тип функций <code>take</code>, <code>map</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>filter</code>. Вычислите следующие примеры в интерпретаторе и объясните своими словами, что делают эти функции.</task>
	<pre><ghci>take 5 [1..10]
take 5 [1..3]
take 5 [1..]
map (+1) [1..5]
takeWhile (&lt; 5) [1..20]
dropWhile (&lt; 5) [1..20]
take 3 $ dropWhile (&lt; 5) [1..]
filter (\i -> i^2 &lt; 5) [1..20]</ghci></pre>
	    		    
	<task>Даны два целых числа <eq>a</eq> и <eq>b</eq>. Найти сумму квадратов всех целых чисел от <eq>a</eq> до <eq>b</eq> включительно.</task>     

	<task>Найти среднее геометрическое всех целых чисел от а до b.</task>

	<task>Найдите сколько точек на целочисленной сетке попадают в круг указанным целочисленным радиусом. Оцените число <eq>\pi</eq> с помощью круга радиусом 100. Здесь для каждого элемента списка следует создать и обработать ещё один список, таким образом реализуется вложенный цикл.<br/> Посмотрите в справке о <a href ='haskell-ref.html#Генераторы списков' target='_blank'>генерации списков</a>.</task>
	
	<task> Вычислите приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
	  с точностью до 14 знаков после запятой. Для этого
<ul>
  <li>определите функцию факториал от n, как произведение натуральных чисел 1,2,.. n; </li>
  <li>сгенерируйте последовательность чисел от 0 до бесконечности;</li>
  <li>превратите её в последовательность значений <eq>1/i!</eq>;</li>
  <li>ограничьте полученную последовательность элементами, превышающими указанную <eq>10^{-14}</eq> (используйте функцию <code>takeWhile</code>);</li>
  <li>просуммируйте последовательность.</li>
</ul>
Оцените количество операций, необходимых для вычисления этой функции.
	</task>

	<task>Напишите функцию <code>count p lst</code>, которая считает сколько раз в списке встречается элемент, удовлетворяющий предикату <code>p</code>. Как с её помощью подсчитать в строке количество цифр?</task>


	<h2>Генерация списков</h2>
	
	<task>С помощью списков и функций их обрабатывающих можно производить вычисления, соотвествующие циклам <tt>for</tt> и <tt>while</tt>. Есть ещё одна очень полезная функция, которая порождает списки — <code>iterate</code>. Посмотрите на её тип. Поэкспериментируйте с ней на нескольких примерах:</task> 
	<pre><ghci>take 10 $ iterate (*2) 1
take 5 $ iterate cos 0.3
iterate (`div` 2) 17</ghci></pre>

	<task>Решите в одну строчку. Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробeг на 10% от пробега предыдущего дня. Определите, в какой день лыжник должен будет пробежать 100 км. Найдите в какой день суммарный пробег за все дни превысит 100 км. </task>
	


	<task>Вычислите в GHCi следующие выражения и объясните что делают функции <code>zip</code>, <code>zipWith</code>, <code>tail</code> и <code>sum</code></task>
	<pre><ghci>zip [1..4] [5..8]
zipWith (+) [1..4] [5..8]
tail [2,3,5,78]
zip lst (tail lst) where lst = [1..5]
sum [2,4,6]</ghci></pre>
	
	<task>Известно, что коэффициенты при всех степенях в разложении полинома <eq>(a + b)^n</eq> можно получить с помощью треугольника Паскаля. Треугольник Паскаля — бесконечная таблица, имеющая треугольную форму.
	  <p><img src="img/PascalTriangle.png" alt="" width='40%'/><img src="img/imgFig1.gif" alt="" width='60%'/></p>
	  <ul>
	    <li>Определите функцию <code>pascalStep</code>, которая для любой строки в треугольнике строит следующую строку, складывая почленно строку саму с собой, сдвинутой на один элемент. Проверьте правильность её работы на простых примерах.</li>
	    <li>Определите с помощью <code>pascalStep</code> бесконечную последовательность строк треугольника Паскаля.</li>
	    <li> Найдите с помощью оператора <code>!!</code> коэффициенты разложения <eq>(a+b)^{15}</eq>.</li>
	    <li>Найдите коэффициент при <eq>x^{10}</eq> в разложении <eq>(1+x)^{10000}</eq>.</li>
	    <li>После этого вычислите в этом же разложении коэффициент при <eq>x^{9}</eq> и <eq>x^{11}</eq>. Обратите внимание на разницу в скорости вычисления коэффициентов и попробуйте её объяснить.</li>
	    <li>Покажите, что сумма <eq>n</eq>-ного ряда треугольника Паскаля равна <eq>2^n</eq>.</li>
	</ul></task>
	
	<task>Для повышения точности численного интегрирования (см. предыдущее занятие),  интервал интегрирования разбивается на несколько маленьких интервалов и на каждом из них интеграл вычисляется методом Гаусса, после чего результаты суммируются. Напишите функцию <code>integrate f mesh</code>, вычисляющую интерал таким способом используя сетку <code>mesh</code>. <br/>

      Сравните получаемую точность интегрирования для различного числа разбиений на примере <eqn>\int_0^{20} \sin x\,dx = 1 - \cos\,20.</eqn></task>
	
    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
