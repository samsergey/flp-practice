<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <h2>Знакомство с типами</h2>
    
    <div class='tasks'>
      
      <p>До сих пор мы не указывали типы у аргументов функций и возвращаемых ими значений. Но Haskell статически типизированный язык, а это значит, что все выражения в программе имеют определённый тип. Типы выводятся компилятором <em>автоматически</em> и это следствие чистоты языка.</p> 
       
      <task> Выясните тип следующих выражений в интерпретаторе с помощью команды <code>:t</code>      </task>
	<pre><ghci>:t 'a'
:t "Hello"
:t 56
:t [1..5]
:t 2 < 3
:t (<)
:t (==)
:t sin
:t map
:t (+)
:t (+ 2)
:t id
:t ($)
:t (.)
:t integrate
:t (\x -> x)
:t (\x y -> x)
:t (\x y -> x + y)</ghci></pre>	

      <p>Cм. <a href ='haskell-ref.html#Типы данных и функций' target='_blank'>Типы данных и функций</a>.</p>
      
      <task>Посмотрите информацию о типах с помощью команды <code>:i</code>      </task>
	<pre><ghci>:i Char
:i String
:i Bool
:i Int
:i []</ghci></pre>

      <p>Cм. <a href ='haskell-ref.html#Классы типов' target='_blank'>Классы типов</a>.</p>
      <task>Посмотрите информацию о классах типов с помощью команды <code>:i</code></task>
	<pre><ghci>:i Show
:i Eq
:i Ord
:i Num
:i Floating</ghci></pre>
         
      <p>Несмотря на то, что компилятор хорошо справляется с выводом типов, указывать явно тип определяемой в программе функции полезно. Это, во-первых, хорошая документация к функции. Во вторых, при работе с полиморфными функциями и типами, иногда компилятору требуются некоторые подсказки.</p>
  
      <div class="disclaimer">Основные принципы проектирования функциональных программ:
	<ul>
	  <li> Каждая функция должна делать только одно дело, но делать его хорошо.
	  <li> Полиморфные функции лучше специальных.
	  <li> Тотальные функции лучше функций, вызывающих исключения.
	  <li> Структура типов должна отражать логику и универсальные свойства моделируемых объектов, а не моделировать сами объекты.
	  <li> "Не готовьте еду при клиенте". Клиент — это внешний мир, с которым мы общяемся с помощью операций ввода-вывода или связываясь по протоколам. Чистые функции полностью готовят решение внутри себя, а потом предлагают его внешнему миру. 
	</ul>
	</div>
      
      <p>
	Общий подход к решению рельных (и учебных) задач, предлагаемый функциональным программированием состоит в следующем: <ul>
	  <li> разбиваем задачу на отдельные очень небольшие, логически замкнутые и чистые подзадачи, определяя метод их комбинирования
	  <li> определяем, вычисляем или выясняем тип функций, представляющих решение этих подзадач
	  <li> пишем прототипы функций и тестируем их в REPL
	  <li> комбинируем подзадачи для решения общей задачи
	  <li> на последнем этапе создаём связь с внешним миром — ввод/вывод
	</ul>
      </з>
      
      <h2>Списки и циклы</h2>

      <p>Списки в Haskell играют более фундаментальную роль, чем просто тип данных или контейнер. С их помощью выражаются циклические конструкции.</p>

      <task>Вывести на печать числа от 1 до 10.</task>
      <pre><ghci><l></l> mapM_ print [1..10]</ghci></pre>

      <task>Даны целые числа n и k. Вывести  на печать n раз число k.</task>
      <pre><ghci><l></l> mapM_ print $ replicate n k</ghci></pre>

      <task>Напишите определение функции <code>replicate</code>, определите её тип.
	<pre><hs>replicate' n x = const x <$> [1 .. n]</hs></pre>
	Удостоверьтесь, что оно работает верно. Объясните смысл функции <code>const</code>.</task>

      <h2>Выделение части списка</h2>
	
	<task>Выясните и объясните тип функций <code>take</code>, <code>map</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>filter</code>. Вычислите следующие примеры в интерпретаторе и объясните своими словами, что делают эти функции.</task>
	<pre><ghci>take 5 [1..10]
take 5 [1..3]
take 5 [1..]
map (+1) [1..5]
takeWhile (&lt; 5) [1..20]
dropWhile (&lt; 5) [1..20]
take 3 $ dropWhile (&lt; 5) [1..]
filter (\i -> i^2 &lt; 5) [1..20]</ghci></pre>
	    		    
	<task>Даны два целых числа <eq>a</eq> и <eq>b</eq>. Найти сумму квадратов всех целых чисел от <eq>a</eq> до <eq>b</eq> включительно.</task>     

	<task>Найти среднее геометрическое всех целых чисел от а до b.</task>

	<task>Найдите сколько точек на целочисленной сетке попадают в круг указанным целочисленным радиусом. Оцените число <eq>\pi</eq> с помощью круга радиусом 100. Здесь для каждого элемента списка следует создать и обработать ещё один список, таким образом реализуется вложенный цикл.<br/> Посмотрите в справке о <a href ='haskell-ref.html#Генераторы списков' target='_blank'>генерации списков</a>.</task>
	
	<task> Вычислите приближение числа <eq>e</eq> по формуле:
	  <eqn>e = 1 + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ...</eqn>
	  с точностью до 14 знаков после запятой. Для этого
<ul>
  <li>определите функцию факториал от n, как произведение натуральных чисел 1,2,.. n; </li>
  <li>сгенерируйте последовательность чисел от 0 до бесконечности;</li>
  <li>превратите её в последовательность значений <eq>1/i!</eq>;</li>
  <li>ограничьте полученную последовательность элементами, превышающими указанную <eq>10^{-14}</eq> (используйте функцию <code>takeWhile</code>);</li>
  <li>просуммируйте последовательность.</li>
</ul>
Оцените количество операций, необходимых для вычисления этой функции.
	</task>

	<task>Напишите функцию <code>count p lst</code>, которая считает сколько раз в списке встречается элемент, удовлетворяющий предикату <code>p</code>. Как с её помощью подсчитать в строке количество цифр?</task>

	<h2>Свёртка списков</h2>
	
	<task>Выясните и объясните тип функций <code>foldr</code>, <code>scanr</code>, <code>foldl</code>, <code>scanl</code>. Вычислите несколько примеров в интерпретаторе:</task>
	  <pre><ghci>foldr (+) 0 [1,2,3]
foldr (+) 10 [1,2,3]
foldr (-) 0 [1,2,3]
foldr (-) 10 [1,2,3]
foldl (-) 0 [1,2,3]
foldl (-) 10 [1,2,3]
scanr (+) 0 [1,2,3]
scanl (-) 0 [1,2,3]</ghci></pre>

	  <task>Напишите функцию <code>join sep strs</code>, которая соединяла бы список строк <code>strs</code> через строку-разделитель <code>sep</code>. примеры использования:</task>
	  <pre><hs> joinBy ", " ["John", "James", "Ana"]  ⟹  "John, James, Ana"
 joinBy " + " $ show <$> [1..5]        ⟹  "1 + 2 + 3 + 4 + 5"</hs></pre>
	  
	<task>Напишите функцию <code>fromBase b n </code>, переводящую число <code>n</code> из заданной системы счисления с основанием <code>b</code> в десятичную. Число при этом задаётся списком цифр.</task>

	<task> Вычислите приближение числа <eq>e</eq> более эффективным способом. Для этого сгенерируйте последовательность значений факториалов натуральных чисел с помощью функции <code>scanl</code>.</task>

	<task>Пользуясь функцией <code>elem</code>, напишите определения для функций <code>intersect l1 l2</code> и <code>complement l1 l2</code>, реализующих пересечение и дополнение множеств, представленных списками.</task>

	<task>Добавление элемента в множество, представленное списком можно определить следующим образом:
	  <pre><hs><def>insert :: Eq t => t -> [t] -> [t]</def>
insert y [] = [y]
insert y (x:xs) | x == y = x : xs
                | otherwise = x : insert y xs</hs></pre>
	  Объясните своими словами, как работает это определение. Пользуясь этой функцией и свёрткой напишите функцию <code>union l1 l2</code>, реализующую объединение множеств.</task>

	<task>Измените определение функции <code>insert</code>, так чтобы списки, представляющие множества были упорядочены. Даёт ли это какие-либо преимущества? Что нужно сделать для того, чтобы воспользоваться этим преимуществом в работе функций <code>intersect</code> и <code>complement</code>?</task>

	<task>В последовательности целых чисел найдите минимальное число и количество его повторений. Используйте следующий шаблон: <pre><hs><def>minCount :: Ord a => [a] -> (a, Int)</def>
minCount [] = error "List is empty"
minCount (x:xs) = foldl count _ xs
  where
    count (r, c) x | x == r    = _
                   | x &lt; r  = _
                   | otherwise = _</hs></pre></task>
	
	<h2>Генерация списков</h2>
	
	<task>С помощью списков и функций их обрабатывающих можно производить вычисления, соотвествующие циклам <tt>for</tt> и <tt>while</tt>, имитировать изменяемое состояние (функции <code>foldr</code>, <code>scanr</code> и т.п.). Есть ещё одна очень полезная функция, которая порождает списки — <code>iterate</code>. Посмотрите на её тип. Поэкспериментируйте с ней на нескольких примерах:</task> 
	<pre><ghci>take 10 $ iterate (*2) 1
take 5 $ iterate cos 0.3
iterate (`div` 2) 17</ghci></pre>

	<task>Решите в одну строчку. Начав тренировки, лыжник в первый день пробежал 10 км. Каждый следующий день он увеличивал пробeг на 10% от пробега предыдущего дня. Определите, в какой день лыжник должен будет пробежать 100 км. Найдите в какой день суммарный пробег за все дни превысит 100 км. </task>
	
	<task>Напишите функцию <code>toBase b n</code> , которая переводит число <code>n</code> из десятичной системы счисления в систему с основанием <code>b</code>. Убедитесь в том, что эта функция является обратной функции <code>fromBase</code></task>

	    <task>Вычислите в GHCi следующие выражения и объясните что делают функции <code>zip</code>, <code>zipWith</code>, <code>tail</code> и <code>sum</code></task>
    <pre><ghci>zip [1..4] [5..8]
zipWith (+) [1..4] [5..8]
tail [2,3,5,78]
zip lst (tail lst) where lst = [1..5]
sum [2,4,6]</ghci></pre>
	
	<task>Известно, что коэффициенты при всех степенях в разложении полинома <eq>(a + b)^n</eq> можно получить с помощью треугольника Паскаля. Треугольник Паскаля — бесконечная таблица, имеющая треугольную форму.
	  <p><img src="img/PascalTriangle.png" alt="" width='40%'/><img src="img/imgFig1.gif" alt="" width='60%'/></p>
	  <ul>
	    <li>Определите функцию <code>pascalStep</code>, которая для любой строки в треугольнике строит следующую строку, складывая почленно строку саму с собой, сдвинутой на один элемент. Проверьте правильность её работы на простых примерах.</li>
	    <li>Определите с помощью <code>pascalStep</code> бесконечную последовательность строк треугольника Паскаля.</li>
	    <li> Найдите с помощью оператора <code>!!</code> коэффициенты разложения <eq>(a+b)^{15}</eq>.</li>
	    <li>Найдите коэффициент при <eq>x^{10}</eq> в разложении <eq>(1+x)^{10000}</eq>.</li>
	    <li>После этого вычислите в этом же разложении коэффициент при <eq>x^{9}</eq> и <eq>x^{11}</eq>. Обратите внимание на разницу в скорости вычисления коэффициентов и попробуйте её объяснить.</li>
	    <li>Покажите, что сумма <eq>n</eq>-ного ряда треугольника Паскаля равна <eq>2^n</eq>.</li>
	</ul></task>
	
	<task>Для повышения точности численного интегрирования (см. предыдущее занятие),  интервал интегрирования разбивается на несколько маленьких интервалов и на каждом из них интеграл вычисляется методом Гаусса, после чего результаты суммируются. Напишите функцию <code>integrate' f mesh</code>, вычисляющую интерал таким способом используя сетку <code>mesh</code>. <br/>

      Сравните получаемую точность интегрирования для различного числа разбиений на примере <eqn>\int_0^{20} \sin x\,dx = 1 - \cos\,20.</eqn></task>

	<hr/>
	
      <!-- <p> -->
      <!-- 	Следующие два задания являются факультативными. Выберите одно из них, которое вам кажется более интересным или понятным. -->
      <!-- </p> -->
      
      <!-- 	<task>Для работы с очень большими числами применяется разложение числа по большому основанию. Так, скажем, число <code>1234567</code> по основанию <code>1000</code> можно представить в виде списка <code>[1, 234, 567]</code>. Напишите функцию, умножающую "длинное число" в системе счисления с основанием, например, <eq>10^{9}</eq> (это число разрядов в типе <code>Int</code>, занимающем два байта), представляемое списком 9-значных "цифр" на число типа <code>Int</code>: -->
      <!-- 	  <pre><hs><def>multLong :: Int -> [Int] -> [Int]</def></hs></pre> -->
      <!-- 	Посчитайте с его помощью факториал 100 или 1000.</task> -->
	
	<task>Составьте программу поиска всех решений ребуса <eqn>\mathrm{VOLVO} + \mathrm{FIAT} = \mathrm{MOTOR}.</eqn> Разным буквам соответствуют разные цифры, одинаковым — одинаковые. Старшая цифра каждого числа отличается от нуля (см.&nbsp;<a href ='haskell-ref.html#Генераторы списков' target='_blank'>Генераторы списков</a>).
	  <p>Программа в интерпретаторе будет работать довольно медленно. Для решения реальных задач программу следует скомпилировать с включённым флагом оптимизации. Для этого можно включить командную строку в редакторе <sl>Emacs</sl> с помощью команды<br/> <keystroke>M-x</keystroke> <tt>eshell</tt>. Далее выполняем компиляцию с оптимизирующим флагом <tt>-O3</tt>:
	  <pre>&gt; ghc.exe -O3 test.hs
[1 of 1] Compiling Main             ( test.hs, test.o )
Linking test ...
&gt; test.exe</pre>
	  </p>
	</task>

	
    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
