<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1em 1em 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>

    <h2>Знакомство с типами</h2>
    
    <div class='tasks'>
      
      <p>До сих пор мы не указывали типы у аргументов функций и возвращаемых ими значений. Но Haskell статически типизированный язык, а это значит, что все выражения в программе имеют определённый тип. Типы выводятся компилятором <em>автоматически</em> и это следствие чистоты языка.</p> 
       
      <task> Выясните тип следующих выражений в интерпретаторе с помощью команды <code>:t</code>      </task>
	<pre><ghci>:t 'a'
:t "Hello"
:t 56
:t [1..5]
:t 2 < 3
:t (<)
:t (==)
:t sin
:t map
:t (+)
:t (+ 2)
:t id
:t ($)
:t (.)
:t integrate
:t (\x -> x)
:t (\x y -> x)
:t (\x y -> x + y)</ghci></pre>	

      <p>Cм. <a href ='haskell-ref.html#Типы данных и функций' target='_blank'>Типы данных и функций</a>.</p>
      
      <task>Посмотрите информацию о типах с помощью команды <code>:i</code>      </task>
	<pre><ghci>:i Char
:i String
:i Bool
:i Int
:i []</ghci></pre>

      <p>Cм. <a href ='haskell-ref.html#Классы типов' target='_blank'>Классы типов</a>.</p>
      <task>Посмотрите информацию о классах типов с помощью команды <code>:i</code></task>
	<pre><ghci>:i Show
:i Eq
:i Ord
:i Num
:i Floating</ghci></pre>
         
      <p>Несмотря на то, что компилятор хорошо справляется с выводом типов, указывать явно тип определяемой в программе функции полезно. Это, во-первых, хорошая документация к функции. Во вторых, при работе с полиморфными функциями и типами, иногда компилятору требуются некоторые подсказки.</p>
  
      <div class="disclaimer">Основные принципы проектирования функциональных программ:
	<ul>
	  <li> Каждая функция должна делать только одно дело, но делать его хорошо.
	  <li> Полиморфные функции лучше специальных.
	  <li> Тотальные функции лучше функций, вызывающих исключения.
	  <li> Структура типов должна отражать логику и универсальные свойства моделируемых объектов, а не моделировать сами объекты.
	  <li> "Не готовьте еду при клиенте". Клиент — это внешний мир, с которым мы общяемся с помощью операций ввода-вывода или связываясь по протоколам. Чистые функции полностью готовят решение внутри себя, а потом предлагают его внешнему миру. 
	</ul>
	</div>
      
      <p>
	Общий подход к решению реальных (и учебных) задач, предлагаемый функциональным программированием состоит в следующем: <ul>
	  <li> разбиваем задачу на отдельные очень небольшие, логически замкнутые и чистые подзадачи, определяя метод их комбинирования
	  <li> определяем, вычисляем или выясняем тип функций, представляющих решение этих подзадач
	  <li> пишем прототипы функций и тестируем их в REPL
	  <li> комбинируем подзадачи для решения общей задачи
	  <li> на последнем этапе создаём связь с внешним миром — ввод/вывод
	</ul>
      </p>
         <h2>Описание электрических цепей</h2>

    В функциональном программировании типы играют очень важную роль. На этом занятии мы научимся использовать их для описания сложных данных и создадим небольшой встроенный предметно-ориентированный язык (EDSL), для описания и моделирования достаточно широкого класса электрических цепей.   

    <div class='tasks'>

      <task>Определим тип для представления произвольной двухполюсной электрической цепи, которая может состоять из сопротивлений (с&nbsp;номиналами типа <code>Double</code>) и допускает последовательное или параллельное соединение элементов цепи.</task>

<pre><hs>data Circuit = R Double
               | Par Circuit Circuit
               | Seq Circuit Circuit deriving Show</hs></pre>

      <p>Например:</p>

      <pre><hs> R 20 -- сопротивление номиналом 20 Ом
 R 100 `Seq` R 10 -- последовательное соединение двух сопротивлений
 R 100 `Par` R 10 -- параллельное соединение двух сопротивлений</hs></pre>      

      <task>Опишите с помощью этих конструкторов типов цепь, показанную на рисунке:<p align='center'><img src="img/circ1.png" alt="" width='40%'/><br/>Цепь 1.</p></task>

      <task>Напишите функцию <code>resistance</code>, которая вычисляла бы суммарное сопротивление произвольной двухполюсной цепи. <pre><hs><def>resistance :: Circuit -> Double</def></hs></pre> При этом используются следующие формулы: при последовательном подключении элементов складываются значения сопротивлений,  а при параллельном подключении складываются проводимости:<eqn>R_\text{seq} = R_1 + R_2,\quad\frac{1}{R_\text{par}} = \frac{1}{R_1} + \frac{1}{R_2}.</eqn> Рассчитайте с помощью функции <code>resistance</code> сопротивление цепи 1.</task>

      <task>Пусть в указанной выше схеме, сопротивление номиналом 11 является переменным. Параметризуйте схему, превратив её в функцию от величины этого споротивления. Определите номинал  этого элемента, при котором сопротивление всей цепи будет равно 5.</task>

      <task>Добавьте в тип <code>Circuit</code> элемент, соответствующий ключу. При этом замкнутому состоянию ключа пусть соответствует нулевое, а разомкнутому — бесконечное сопротивление (его можно получить с&nbsp;помощью выражения <code>1/0</code>). Поместите вместо элементов с номиналами 11 и 7 ключи, и вычислите сопротивление цепи, при различных сочетаниях их состояний.</task>

      <task>Определите функцию <code>connect</code>, которая бы возвращала ответ на вопрос: замкнута цепь или нет.<pre><hs><def>connect :: Circuit -> Bool</def></hs></pre>  Проверьте работу этой функции при различных сочетаниях состояний ключей.</task>

      <h2>Тип для сопротивления</h2>
      
      <p>Использование бесконечного значения для представления разомкнутой цепи чревато неприятностями, не очень красиво и не позволит работать с произвольными (невещественными) числами. Правильным и идиоматичным функциональным путём будет определить отдельный тип, описывающий состояние цепи в электротехнических терминах.</p>

      <task>Определите тип <code>Resistance</code>, который может представлять разомкнутую цепь <code>Break</code>, цепь, замкнутую накоротко <code>Short</code> и цепь, обладающую конечным сопротивлением <code>Value Double</code>.</task>
 
      <task>Для типа <code>Resistance</code> определите операции параллельного <code>(&lt;||&gt;)</code> и последовательного <code>(&lt;&&&gt;)</code> соединения. <pre><hs><def>(&lt;||&gt;),(&lt;&&&gt;) :: Resistance -> Resistance -> Resistance</def></hs></pre> И переопределите функцию <code>resistance</code> так, чтобы она возвращала тип <code>Resistance</code>. Напишите короткое определение функции <code>connect</code>, использующее результат функции <code>resistance</code>.</task>


      <p>При расчёте электрических цепей переменного тока роль сопротивления играет импеданс, который выражается комплексным числом. Для цепей переменного тока следует добавить реактивные элементы: ёмкости и индуктивности. Импеданс ёмкости <eq>C</eq>, индуктивности <eq>L</eq> и сопротивления <eq>R</eq> зависит от частоты переменного тока <eq>\omega</eq> и вычисляется по формулам: <eqn>Z_C = 1/(i \omega C),\quad Z_L = i\omega L,\quad Z_R = R.</eqn> Импедансы складываются при параллельном и последовательном соединении элементов, по тем же правилам, что и активные сопротивления. </p>

      <task>Подключите к программе модуль <code>Data.Complex</code> <pre><hs>import Data.Complex</hs></pre> Параметризуйте тип <code>Resistance</code> так, чтобы кроме типа <code>Double</code> он мог содержать в себе произвольные типы. Добавьте в тип <code>Circuit</code> представление для ёмкости и индуктивности — типы <code>C Double</code> и <code>L&nbsp;Double</code>. Опишите с помощью этого типа цепь 2, показанную на рисунке:<p align='center'><img src="img/circ2.jpg" alt="" width='40%'/><br/>Цепь 2.</p></task>

      <task>Дополните определение функции <code>resistance</code> так, чтобы она могла обрабатывать ёмкости и индуктивности. Для постоянного тока конденсаторы соответствуют разрыву цепи, а катушки индуктивности — короткому замыканию. Вычислите активное сопротивление цепи 2.</task>

      <task>Дайте определение функции <code>impedance</code>, имеющей тип<pre><hs><def>impedance :: Circuit -> Float -> Resistance (Complex Double)</def></hs></pre> и вычислите импеданс для цепи 2. В полученном комплексном числе действительная часть должна быть равна активному сопротивлению цепи, а мнимая — реактивному (волновому).</task>

      <h2>Алгебра сопротивлений</h2>
      
      <p>Мы построили тип, описывающий <em>внутреннюю структуру</em> результата — сопротивления. Это не просто число, оно может принимать различные по смыслу значения, которые по-разному комбинируются друг с другом. Если внимательно посмотреть на определения операторов <code>(&lt;||&gt;)</code> и <code>(&lt;&&&gt;)</code>, то можно заметить их сходство с логическими операторами над булевыми значениями. Если исключить из рассмотрения величины <code>Value</code>, то получатся точные определения логических операций И и ИЛИ, где роль <code>True</code> и <code>False</code> играют <code>Short</code> и <code>Break</code>, соответственно. Такое совпадение структур позволяет использовать то, что мы знаем о логике. В частности, закон де&nbsp;Моргана.</p>
      <eqn>\neg (A \vee B) = \neg A \wedge \neg B</eqn>
      
      <p>Осталось определить понятие отрицания для сопротивления. Это проводимость, — величина, обратная сопротивлению. Ведь при параллельном соединении складываются именно проводимости, значит наша догадка верна!</p>

      <task>Определите функцию <code>inv</code>, которая преобразовывала бы сопротивления в проводимости и обратно. С её помощью закона де&nbsp;Моргана, определите операцию <code>(&lt;||&gt;)</code> через <code>(&lt;&&&gt;)</code> и <code>inv</code>.</task>

      <task>Рассчитайте импеданс цепи 2 для частот в диапазоне от 1Гц до 1 ГГц. Обратите внимание на то как изменяются действительная и мнимая части импеданса. Попробуйте объяснить эти инзменения.</task>

      <task>Напишите две функции: <pre><hs><def>resistanceToBool :: Resistance a -> Bool
boolToResistance :: Bool -> Resistance a</def></hs></pre> которые преобразовывали бы значения двух типов, признанные нами подобными, друг в друга.</task>

      <task>В цепях переменного тока реактивное сопротивление может быть положительным или отрицательным, этот знак определяет сдвиг сигнала по фазе. Однако особый интерес представляет частота, при которой реактивное сопротивление обращается в ноль. Она соответствует резонансу — совпадению частоты сигнала с собственной частотой цепи. Определите резонансную частоту цепи 2, как частоту, при которой мниная часть импеданса меняет знак.</task>

      <h2>Метод бисекции</h2>
      
      <p>Поиск резонанса, как и решение произвольного алгебраического уравнения, можно и нужно автоматизировать. Для этого стоит воспользоваться универсальным и надёжным методом деления отрезка пополам, или методом бисекции. Он состоит в следующем: 
        <ul>
	  <li> задан отрезок <eq>(a,b)</eq>;
	  <li> задано условие <eq>p</eq>, которое в некоторой точке на отрезке меняет значение (например, меняется знак числовой функции); 
	  <li> если <eq>p(a) = p(b)</eq>, считаем, что искомой точки на отрезке нет;
	  <li> если отрезок мал <eq>|b-a| &lt; |b+a|\varepsilon</eq>, решением является его средняя точка;
	  <li> в противном случае решение находится либо в правой, либо в левой половине отрезка.  
	</ul>
      
      <task>Напишите функцию <code>bisection p a b</code>, которая методом деления отрезка пополам, находит точку на отрезке <eq>(a,b)</eq>, такую, что условие <eq>p</eq> в ней изменяется. <pre><hs><def>bisection :: Eq a => (Double -> a) -> Double -> Double -> Maybe Double</def></hs></pre> При этом, если на указанном отрезке искомой точки не обнаруживается, функция должна возвращать значение <code>Nothing</code>. Относительная точность <eq>\varepsilon</eq>, с которой работает функция, должна составлять <eq>10^{-11}.</eq></task>

      <task>Проверьте правильность работы функции на следующих примерах:
	<pre><hs> bisection (\x -> x < 2) 1 3
 bisection (\x -> x < 2) 0 1
 bisection (\x -> x^2 < 2) 1 2
 (^2) <$> bisection (\x -> x^2 < 2) 1 2
 bisection (\x -> cos x > 1 - 1/x) 0 2
 bisection (\x -> 1/x > 0) -1 2
 bisection (\x -> isNaN (sqrt (3 - x^2))) 0 2 </hs></pre>
      </task>

      <task>Проверьте теорему Виета, найдя сумму и произведение корней какого-либо квадратного уравнения.</task>

      <task>Добавьте в самое начало файла строчку (директиву компилятору)
	<pre><hs>{-# LANGUAGE DeriveFunctor #-}</hs></pre> и припишите к описанию типа <code>Resistance</code> указания для вывода экземпляров класса <code>Eq</code> и <code>Functor</code>: <pre><hs>deriving (Show, Eq, Functor)</hs></pre> О функторах ми поговорим несколько позже, но уже сейчас будет понятно, как мы расширили функциональность типа <code>Resistance</code> — теперь для него определен оператор <code><$></code>, позволяющий изменять значение внутри типа:
	<pre><ghci><l></l> (*2) <$> Value 5
<o>Value 10</o>
<l></l> (*2) <$> Break
<o>Break</o></ghci></pre></task>
      
      <task>Напишите функцию <code>resonance</code>, отыскивающую для цепи резонансную частоту в указанных пределах.<pre><hs><def>resonance :: Circuit -> Double -> Double -> Maybe Double</def></hs></pre></task>
      
      <task>Найдите значение ёмкости в цепи 2, при которой резонансная частота цепи составит 0.5 МГц.</task>

      <task>Как можно ускорить вычисления в последней задаче?</task>

    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
