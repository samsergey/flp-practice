<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о моноидах построим гибкую и расширяемую систему для вывода графики, использующую web-интерфейс. Наша система будет представлять собой небольшой встроенный предметно-ориентированный язык (EDSL) для декларативного описания графики. Этот язык будет трансливаться в формат SVG (Scalable Vector Graphics). Это текстовый формат, используемый веб-браузерами и многими векторными графическими редакторами (<sl>Corel Draw</sl>, <sl>Inkscape</sl> и т.п.).</p>
      
      <h4>Типы для графических примитивов</h4>
      <p>Определим типы для представления некоторых графических примитивов: точек, ломаных линий.</p>
      <pre><hs>type Pt = (Float, Float)
  
data Primitive = Point Pt
               | Line [Pt]
  deriving Show</hs></pre>

      <h4>Представление примитивов в формате SVG</h4>

      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle rx='x' ry='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <task>Для того, чтобы упростить генерацию SVG напишите функцию <code>format</code> для форматирования строк по шаблону, последовательно заменяя символ <tt>'_'</tt> строками из списка. Например:
	<pre><ghci> Main> format "_ said: '_!'" ["John", "Hello"]
"John said: 'Hello!'"</ghci></pre>
	<em>Подсказка: воспользуйтесь функцией <code>splitOn</code> из модуля <code>Data.List.Split</code> для того, чтобы разбить форматируемую строку на части, а потом с помощью функции <code>zipWith</code> перемешайте эти части со строками из списка.</em>
      </task>

      <p>Определим собственный класс для того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
    toSVG :: a -> String</hs></pre></p>

      <task>Определите экземпляр этого класса для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG (Point (x,y)) = _
  toSVG (Line pts) = _</hs></pre>
      </task>

      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='black'&gt;
  примитив
  примитив
  ...
&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения. Сохранив этот текст в файл с расширением <tt>.html</tt> можно будет увидеть изображение в веб-браузере.</p>

      <p>
	Для представления картинки определим новый тип <code>Picture</code>:
	<pre><hs>data Picture = Picture BoundingBox [Primitive]
   deriving Show

type Box = ( Min Float, Max Float
            , Min Float, Max Float )

instance Bounded Float where
  minBound = -1000
  maxBound = 1000</hs></pre>
	Здесь <code>Box</code> хранит координаты "рамки", обрамляющей изображения. Чтобы сделать тип <code>Box</code> моноидом, определим минимальное и максимальное допустимое значение координат, соответственно, -1000 и 1000 используя экземпляр класса <code>Bounded</code> для типа <code>Float</code>.
      </p>

      <task>Определите фукцию <code>findBox :: Primitive -> Box</code>, вычисляющую обрамляющие координаты для примитивов.</task>
      
      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code> и два конструктора <code>line :: [Pt] -> Picture</code> и <code>point :: Pt -> Picture</code>, которые бы вычисляли обрамляющие координаты для примитивов.</p>
      </task>

      <task>Запишите какое-либо несложное SVG-выражение в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в браузере. Сознайте вспомогательную функцию <code>writeSVG :: SVG a => FileName -> a -> IO ()</code>.</task>
      
      <task>Напишите конструктор <code>polygon</code>для правильных многоугольников заданного размера (размер задаётся радусом описанной окружности).</task>

      <task>Добавьте конструктор <code>circle</code> для окружности, представляемой двадцатигранником.</task>

      <task>Добавьте конструктор <code>square</code> для квадрата.</task>
      
      <h3>Композиция изображений</h3>
      <task>Так как в формате SVG примитивы попросту перечисляются, а затем изображаются, накладываясь друг на друга, это наводит на мысль, что изображения образуют моноид с операцией наложения. Определите экземпляр класса <code>Monoid</code> для типа <code>Picture</code>. Создайте избражение, показанное на рисунке:
	<p><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>
      
      <h3>Преобразования изображений</h3>

      <p>
	Воспользуемся тем, что мы научились перемножать матрицы для преобразования изображений. Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги и повороты, и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг, а вектор <eq>\vec v</eq> -- параллельный перенос. Преобразование можно выразить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преоьразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т.п.) используется именно такая реализация афинных преобразований. 
      </p>

      <task>Опрелите три основные вида преобразований:
	<ul>
	  <li> масштабирование осей: <code>scaleT a b</code>
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос: <code>translateT x y</code>
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на заданный угол: <code>rotateT alpha</code>
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </task>

      <task>Напишите функцию 
	<p>
	  <code>affine :: M Float -> Primitive -> Primitive</code>
	</p>, применяющую афинные преобразования к графическим примитивам, и преобразователи изображений:
	<p>
	  <code>transform :: M Float -> Picture -> Picture</code><br/>
	  <code>scale :: Float -> Float -> Picture -> Picture</code><br/>
	  <code>shift :: Float -> Float -> Picture -> Picture</code><br/>
	  <code>rotate :: Float -> Picture -> Picture</code>
	</p>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><ghci>let s = square 50
s <> rotate (pi/2) s
s <> shift 10 30 s
s <> scale 2 3 s
s <> (scale 2 3 . rotate (pi/3)) s
(shift 20 30 <> rotate (pi/3)) s </ghci></pre></task>      
      
      <task>Преобразователи позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига позволяет не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании квадрата и прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, с помощью которого можно было бы описать окружность со вписанным в неё квадратом, расположеные в координатах (100, 100) так:
	<pre><hs>(circle 50 <> rectangle 50 50) `at` (100,100)</hs></pre></task>
     
      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат. Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат.</task>

      <task>Постройте картинку, задаваемую выражением:
      	<pre>mconcat $ take 48 $ iterate (rotate (pi/24)) $ square 50 `at` (25,25)</pre>
	<p align='center'><img src="img/wheel.png"/></p>
      </task>
      
      <task>Имея в своём распоряжении композицию изображений и операцию сдвига несложно определить ещё два полезных комбинатора, располагающих изображения рядом вертикально и горизонтально: <code>above</code> и <code>beside</code>. Напишите их определение так, чтобы при результаты были тками, как показано на рисунке:
	<pre>circle 30 `beside` square 40</pre>
	<p align='center'><img src="img/beside.png"/></p>
	<pre>circle 30 `above` square 40</pre>
	<p align='center'><img src="img/above.png"/></p>
      </task>

      <task>Напишите две функции <code>row</code> и <code>column</code>, которые располагали бы список изображений в виде ряда или колонки. Например так:
	<pre>row $ circle <$> [20,40,80,160,80,40,20]</pre>
	<p align='center'><img src="img/row1.png"/></p>
            </task>

      <task>Напишите функцию <code>chart :: Picture -> [Int] -> Picture</code>, которая строила бы диаграммы для списков целочисленных значений, как показано на примере:

	<pre>chart (square 10) [1,2,1,2,3,2,1,4,2,3,6,5,4,3,4,3,1,2,1]</pre>
	<p align='center'><img src="img/chart1.png"/></p>
      
      </task>

      <task>Напишите функцию <code>barChart :: Double -> [Double] -> Picture</code>, которая строила бы столбчатую диаграмму для числовых списков, используя указанную ширину столбца:
	<pre>scale 1 10 $ barChart 10 [1,2,3,2,3,4,5,4,3,2]</pre>
	<p align='center'><img src="img/chart2.png"/></p>
            </task>

      <h3>Атрибуты изображений</h3>
      
      <task>Нашим картинкам не хватает цвета. Добавьте в тип <code>Primitive</code> новый конструктор <code>Group Attribute [Primitive]</code>, задающий группу примитивов и атрибут, такой как цвет линии, заливки и т.д. для этой группы. Тип <code>Attribute</code> зададим так:
      <pre><hs>data Attribute = Color String
               | Fill String
               | LineWidth Float
               | Opacity Float
   deriving Show</hs></pre>
      Для этого типа определите экземпляр класса <code>toSVG</code>. Перечисленные нами атрибуты в SVG задаются следующим образом:
      <ul>
	<li> цвет линии -- <tt>stroke='цвет'</tt>
	<li> цвет заливки -- <tt>fill='цвет'</tt>
	<li> толщина линии -- <tt>stroke-width='число'</tt>
	<li> прозрачность -- <tt>stroke-opacity='число' fill-opacity='число'</tt>
      </ul>

      Создайте функции, задающие атрибуты для изображений:
      <pre><hs>color :: String -> Picture -> Picture
fill :: String -> Picture -> Picture
lineWidth :: Float -> Picture -> Picture
opacity :: Float -> Picture -> Picture</hs></pre>
      </task>

      <task>Постройте две диаграммы
	<pre><hs>charts = opacity 0.5 (fill "blue" chart1 <> fill "red" chart2)
  where 
    chart1 = barChart 10 [10,20,30,20,30,40,50,40,30,20]
    chart2 = barChart 10 [30,10,35,50,10,45,60,20,10,5]</hs></pre>
	<p align='center'><img src="img/charts.png"/></p>

	<task>Объясните какие свойства моноидов позволяют построить следующее изображение:
	<pre><hs>fractal :: Foldable t => t (M Float) -> Int -> Picture -> Picture
fractal model n = mconcat . take n . iterate (foldMap transform model) 

tree = fractal model 7 $ line [(0,0), (0,100)]
  where model = [ shiftT 0 100 <> scaleT 0.6 0.6 <> rotateT (-pi/6)
                , shiftT 0 100 <> scaleT 0.7 0.7
                , shiftT 0 100 <> scaleT 0.5 0.5 <> rotateT (pi/6)]</hs></pre>
	  <p align='center'><img src="img/tree.png"/></p>
	  Постройте ряд, показывающий рост "дерева" по мере увеличения числа поколений.
	</task>

	<task>Постройте фрактальные структуры по другим моделям:
	  <pre><hs>circles = fractal model 8 $ circle 150
  where model = [ shiftT 0 75 <> scaleT 0.5 0.5 <> rotateT (pi/3)
                , shiftT 0 (-75) <> scaleT 0.5 0.5 <> rotateT (-pi/3) ]

pithagor = fractal model 10 $ square 100
  where model = [ shiftT 0 100 <> scaleT s s <> rotateT (pi/4)
                , shiftT 100 100 <> scaleT s s <> rotateT (-pi/4)]
        s = 1/sqrt 2</hs></pre>
	</task>
	
    </div>

   <p id="footer"></p>
  <script src="../lib/postprocessing.js"></script>
 </body>
</html>

