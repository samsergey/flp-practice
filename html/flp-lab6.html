<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>fmap {
      content: "hello&lt;$&gt;";
    }</style>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в функциональном программировании — это больше чем описание данных. Это, в первую очередь, описание структуры образуемой данными, в виде математических законов, справедливых для этой структуры. Мы видели это на примере типов для электрических сопротивлений, разнообразных моноидов, изображений и т.д. Типы могут обладать структурой, которая позволяет не только комбинировать вычисления, но и управлять потоком вычислений. Для управления потоком в императивном программировании используются ветвление, циклы или исключения, в функциональном подходе часть и этой работы берут на себя типы.</p>
      
      <task>Простой и часто встречающийся пример — тип <code>Maybe a</code>, говорящий о&nbsp;том, что величина значения типа <code>a</code> может быть неопределена. Посмотрите информацию о типе <code>Maybe</code> с помощью команды <tt>:i</tt>.</task>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите функции <code>listToMaybe :: [a] -> Maybe a</code> и <code>maybeToList :: Maybe a -> [a]</code>.</task>

      <p>Оператор <code>(&lt;$&gt;)</code> имеет своё имя: <code>fmap</code>  и он определён для всех типов, являющихся <strong>функторами</strong>. Самое общее определение для функтора — это <strong>контекст, в котором производятся вычисления</strong>.</p>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <tt>:t</tt>. Посмотрите (с&nbsp;помощью команды <tt>:i</tt> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <h2>Аппликативные функторы</h2>
    
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с функторами. Посмотрите на то, как действуют операторы <code>&lt;|&gt;</code> и <code><*></code>, вычислив в <sl>GHCi</sl> следующие выражения.
      <pre><hs> Nothing &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Just 5
 Just 3 &lt;|&gt; Nothing
 Nothing &lt;|&gt; Nothing
 Nothing &lt;*&gt; Just 5
 Just (4*) &lt;*&gt; Just 5
 Just (2*) &lt;*&gt; Nothing
 (+) &lt;$&gt; Just 3 &lt;*&gt; Just 7
 (+) &lt;$&gt; Nothing &lt;*&gt; Just 7
 (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing</hs></pre>
      Объясните своими словами, для чего нужны операторы <code>&lt;$&gt;</code> (<code>fmap</code>), <code>&lt;|&gt;</code>, <code>&lt;*&gt;</code>, применительно к функтору <code>Maybe</code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните действие выражений:
	<pre><hs>(+2) &lt;$&gt; find (< 2) [2,3,1,4]
(*) &lt;$&gt; find odd [2,3,1,4] &lt;*&gt; find even [2,3,1,4]
(*) &lt;$&gt; find odd [2,6,10,4] &lt;*&gt; find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) &lt;$&gt; lookup "x" vars &lt;*&gt; lookup "a" vars</hs></pre>
 </task>

      <task>Посмотрите на определение функтора <code>Either</code>, и объясните его функториальные свойства, судя по примерам:
	<pre><hs>(*2) &lt;$&gt; Right 4
(*2) &lt;$&gt; Left 4
(*2) &lt;$&gt; Left "hello"
(+) &lt;$&gt; Right 8 &lt;*&gt; Right 5
(+) &lt;$&gt; Left "No!" &lt;*&gt; Right 5	</hs></pre>
      </task>			  

      <task>Напишите функцию <code>sqrtE</code>, которая вычисляет квадратный корень вещественного числа, и для отрицательных чисел возвращает сообщение об ошибке, в виде значения <code>Left "sqrt: got negative argument!"</code>. Вычислите с её помощью  выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>
     
      <task>Поэкспериментируйте с функториальными свойствами типа <code>[]</code>:      <pre><hs>[] &lt;|&gt; [2,3]
[1,2,3] &lt;|&gt; [4,5]
[2] &lt;|&gt; []
[] &lt;|&gt; []
[] &lt;*&gt; [2,3,4]
[(4*)] &lt;*&gt; [2,3,4]
[(4*), (3+)] &lt;*&gt; [2,3,4]
(+) &lt;$&gt; [2,3] &lt;*&gt; [4,5,6]
(+) &lt;$&gt; [] &lt;*&gt; [2,3]
(+) &lt;$&gt; [1,2,3] &lt;*&gt; []</hs></pre>
</task>

      <task>Напишите функцию <code>sqrtL</code>, которая вычисляет квадратный корень вещественного числа, причём, для положительных аргументов она должна возвращать как положительное, так и отрицательное значение корня, для нулевого — только ноль, а для отрицательных значений — ни одного значения. Вычислите с её помощью выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Посмотрите на определение типа <code>IO</code> и объясните как он действует, в&nbsp;качестве функтора:
	<pre><hs>("Hello, " ++) &lt;$&gt; getLine
let readNum = read &lt;$&gt; getLine 
(+) &lt;$&gt; readNum &lt;*&gt; readNum
print 6 &lt;|&gt; error "!!"	</hs></pre>
      </task>			  
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В&nbsp;определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>strongpty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code> (они образуют моноид). </task>

      <task>Напишите универсальную функцию <code>sqrtA</code>, обобщающую функции <code>sqrtM</code> и <code>sqrtL</code> так, чтобы она работала c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code>, причём, для списков, возвращала несколько корней.</task>

      <task>Напишите, используя альтернативные функторы, функцию <code>bisectionA</code>, отыскивающую точку смены заданного условия методом бисекции: <pre><hs><def>bisectionA :: (Alternative f, Eq a)
  => (Double -> a) -> Double -> Double -> f Double
</def></hs></pre></task>

      
<!--       <h2>Управление сообщениями об ошибках</h2> -->
      
<!--       <p>Тип <code>Either</code> похож на тип <code>Maybe</code> тем, что у него есть одно "верное" значение — правое, и "неверное" — левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p> -->

<!--       <p>Однако тип <code>Either</code> не является альтернативным функтором. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>strongpty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>strongpty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p> -->

<!--       <pre><hs>instance Monoid m =&gt; Alternative (Either m) where -->
<!--   strongpty = Left mstrongpty -->
<!--   Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно -->
<!--   Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения -->
<!--   Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения</hs></pre> -->

<!--       <task>Убедитесь на следующих примерах, что приведённое определение работает корректно: -->

<!--       <pre><code>Left "fail" &lt;|&gt; Right 42 -->
<!-- Right 42 &lt;|&gt; Left "fail" -->
<!-- Left "I am " &lt;|&gt; Left "a fail" -->
<!-- </code></pre> -->
<!--       </task> -->

<!-- <p>Для типа <code>Either String</code> определим специальный тип:<pre><hs>type Messaged = Either String</hs></pre></p> -->
      
<!--       <p>Теперь нужно научиться вводить в программу сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали их. Эта возможность должна быть определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>sqrtA</code> для разных контестов, а это уже не DRY (Don't Repeat Yourself — один из универсальных принципов программирования).</p> -->

<!--       <p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в&nbsp;нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию — <code>message</code>.</p> -->

<!--       <pre><hs>class Alternative f =&gt; Failable f where -->
<!--   message :: String -&gt; f a -->
<!--   -- определение, используемое по умолчанию -->
<!--   message _ = strongpty -->
<!-- </hs></pre> -->

<!--       <p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Messaged</code> и <code>IO</code> — специфические:</p> -->

<!--       <pre><hs>instance Failable Maybe -->
<!-- instance Failable [] -->
<!-- instance Failable Messaged where message = Left -->
<!-- instance Failable IO where message = error -->
<!-- </hs></pre> -->

<!--       <task>Внесите в определение функции <code>sqrtA</code> изменения, позволяющие использовать её в четырёх различных контекстах: -->
<!-- 	<pre><hs> sqrtA 16 :: [Double] -->
<!--  sqrtA 16 :: Maybe Double -->
<!--  sqrtA 16 :: Messaged Double -->
<!--  sqrtA 16 -->
<!--  sqrtA (-1) :: [Double] -->
<!--  sqrtA (-1) :: Maybe Double -->
<!--  sqrtA (-1) :: Messaged Double -->
<!--  sqrtA (-1)</hs></pre> -->
<!--       </task> -->
<!--       <p> -->
<!-- 	Нам в дальнейшей работе пригодится класс <code>Failable</code>, поэтому стоит выделить его и определение экземпляров для типов <code>[]</code>, <code>Maybe</code>, <code>Messaged</code> и  <code>IO</code> в отдельный модуль <tt>Failable.hs</tt> -->
<!--       </p> -->

<!--       <task>Перепишите функцию <code>bisection</code>, так, чтобы её тип стал таким: <pre><hs><def>bisection :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> Double -> Double -> f Double</def></hs></pre></task> -->


<!--       <task>Подобно тому, как мы интегрировали функцию на указанной сетке, организуйте поиск особых точек методом бисекции на произвольной сетке:<pre><hs><def>findRoot :: (Failable f, Eq a) -->
<!--   => (Double -> a) -> [Double] -> f Double</def></hs></pre> При этом для пустой сетки и сетки с единственной точкой должны возвращаться соответствующие сообшения об ошибках.</task> -->

      <h2>Монады</h2>
      
      <p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые возвращают значение в контексте? Например, как можно дважды применить функцию <code>sqrtM</code>, чтобы вычислить <eq>\sqrt{\sqrt{16}}</eq>? Иными словами, как выполнить композицию функций, возвращающих не просто значение, а значение в некотором контексте <code>m</code>?</p>
      
      <p>Попробуем начать с использования оператора <code>&lt;$&gt;</code>:
	<pre><ghci><l></l> sqrtM &lt;$&gt; sqrtM 16
<o>Just (Just 2)</o>
<l></l> sqrtM &lt;$&gt; sqrtM (-1)
<o>Just Nothing</o></ghci></pre>
      </p> 
      
      <p>
	Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just 2)</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>Just 2</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление.</p>

      <task> Определите функцию <code>join :: Maybe (Maybe a) -&gt; Maybe a</code>, которая занималась бы "соединением" контекстов так, чтобы можно было получить такие результаты: <pre><ghci><l></l> join $ sqrtM &lt;$&gt; sqrtM 16
<o>Just 4</o>
<l></l> join $ sqrtM &lt;$&gt; sqrtM (-1)
<o>Nothing</o></ghci></pre>
      </task>

      <p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в&nbsp;цепочки любые вычисления с контекстом. Для неё есть особое обозначение: <code>=&lt;&lt;</code></p>

<p align='center'><tt>f =&lt;&lt; x  ≡  join $ f &lt;$&gt; x</tt></p>


      <p>Мы определили для типа <code>Maybe</code> функцию <code>join</code> и сразу повысили его "ранг", позволяя объединять в цепочку функции, возвращающие значения в контексте <code>Maybe</code>. Функторы (аппликативные) для которых определено соединение <code>join</code> называются <strong>монадами</strong>. </p>
      
      <task>Сравните типы операторов <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> и <code>=&lt;&lt;</code> и объясните своими словами их действие в контекстах.</task>

      <p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

      <pre><hs><def>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</def></hs></pre>

      <task>Вычислите следующие выражения в интерпретаторе и объясните как происходят вычисления:
	<pre><hs>[-1,0,1,16] &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Just 64 &gt;&gt;= sqrtA &gt;&gt;= sqrtA
Right 16 &gt;&gt;= sqrtA
Right (-16) &gt;&gt;= sqrtA
(read &lt;$&gt; getLine) &gt;&gt;= sqrtA &gt;&gt;= print</hs></pre></task>

      <hr/>

      <p>Подведём итоги. </p>

      <p><strong>Функтор</strong> — это тип для которого определена операция <code>fmap</code> (<code>&lt;$&gt;</code>).</p>

      <pre><hs>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</hs></pre>

      <p><strong>Аппликативный функтор</strong> — это функтор, для которого определены функции <code>pure</code> и <code>&lt;*&gt;</code></p>

      <pre><hs>class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  &lt;*&gt;  :: f (a -&gt; b) -&gt; f a -&gt; f b</hs></pre>

      <p><strong>Монада</strong> — это аппликативный функтор, для которого определена функция <code>&gt;&gt;=</code></p>

      <pre><hs>class Applicative f =&gt; Monad f where
   (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</hs></pre>

      <p>
	Оператор <code>>>=</code> выражается через функцию <code>join</code> и наоборот.</p>
      <div class='equation' style='width:40%'><tt>x >>= f  ≡  join $ f <$> x<br/>
&nbsp;join x  ≡  x >>= id</tt> </div>

      <p>
	Если тип является монадой, то для полного определения всех его функториальных свойств достаточно определить две функции: <code>pure</code> и <code>&gt;&gt;=</code>. Остальные можно выразить через следующие тождества:</p>

      <div class='equation' style='width:45%'><tt>f <$> x  ≡  x >>= (pure . f)<br/>
f <*> x  ≡  f >>= (<$> x)</tt> </div>

      

    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
</body>
</html>

