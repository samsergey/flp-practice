<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в Haskell — это больше чем описание данных. Это и описание логической или математической структуры образуемой данными. Мы увидели это на примере типа для чисел, которые могут иметь особые нечисловые значения. Такой подход универсален и наиболее часто встречающийся пример — тип <code>Maybe a</code>, говорящий о том, что величина значения типа <code>a</code> может быть неопределена.</p>
      <task>Посмотрите информацию о типе <code>Maybe</code>  с помощью команды <tt>:i</tt>.</task>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите функции <code>listToMaybe :: [a] -> Maybe a</code> и <code>maybeToList :: Maybe a -> [a]</code>.</task>

      <task>Выясните тип оператора <code>(&lt;$&gt;)</code> с помощью команды <code>:t (&lt;$&gt;)</code>. Посмотрите (с помощью команды <code>:i</code> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <h2>Аппликативные функторы</h2>
      
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с типами <code>Maybe a</code>  и <code>[a]</code>. Посмотрите на то, как действуют операторы <code><|></code> и <code><*></code>, вычислив в GHCi следующие выражения.
      <pre><ghci>Nothing <|> Just 5
Just 3 <|> Just 5
Just 3 <|> Nothing
Nothing <|> Nothing
Nothing <*> Just 5
Just (4*) <*> Just 5
Just (2*) <*> Nothing
(+) <&> Just 3 <*> Just 7
(+) <&> Nothing <*> Just 7
(+) <&> Just 3 <*> Nothing</ghci></pre>
      Используйте вместо <code>Maybe a</code> тип <code>[a]</code>. Объясните своими словами, для чего нужны операторы <code><$></code>, <code><|></code>, <code><*></code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\ \sqrt {-4},\ 2\sqrt 5,\ \sqrt 4 < \sqrt 9,\ \sqrt 4 \times \sqrt{-9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните что происходит:
	<pre><hs>(+2) <$> find (< 2) [2,3,1,4]
(*) <$> find odd [2,3,1,4] <*> find even [2,3,1,4]
(*) <$> find odd [2,6,10,4] <*> find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) <$> lookup "x" vars <*> lookup "a" vars
 ("Hello, " ++) <$> getLine
let readNum = read <$> getLine				  
(+) <$> readNum <*> readNum</hs></pre>
      </task>
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>empty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code>. Замените в определении <code>bisection</code> функцию <code>Just</code> на <code>pure</code>, а значение <code>Nothing</code> на <code>empty</code>. Убедитесь в том, что функция работает верно c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code> и т.д. 
      
      <task>Выясните тип функции <code>traverse</code>. Вычислите в интерпретаторе следующие выражения и объясните, что эта функция делает:
	<pre><hs>traverse sqtrM [1,4,9,16]
traverse sqtrM [1,4,-9,16]
traverse (\x -> [-x,x]) [1,2,3]</hs></pre>
      </task>

      <h2>Чтение таблиц CSV</h2>
      
      <p>В качестве ещё одного развёрнутого примера использования функторов рассмотрим задачу чтения таблиц, записанных в формате CSV (Comma-separated values). Пусть в некотором файле хранятся числовые данные:
	<pre>1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20 </pre>
	Задача состоит в том, чтобы прочесть эти данные и сохранить их в виде двумерного списка чисел типа <code>Int</code>.</p>

      <task>Напишите функцию <code>splitBy sep str</code>, разбивающую строку <code>str</code> на список подстрок, используя разделяющий символ <code>sep</code>. Для решения воспользуйтесь функциями <code>unfoldr</code> из библиотеки <code>Data.List</code> и <code>break</code> из стандартной библиотеки. Внимательно изучите типы этих функций, посмотрите как они действуют на нескольких простых примерах перед тем как приступать к решению.</task>

      <task>Напишите функцию <code>readCSV :: String -> [[String]]</code> которая читает строку, содержащую СSV-таблицу, возвращая двумерную таблицу строк.</task>

<task>Воспользуйтесь функцией <code>read</code> для преобразования содержимой таблицы в числа.</task>

<task>Если данные в таблицу не являются числовыми, функция <code>read</code> вызывает ошибку. Это не очень хорошо. Подгрузите библиотеку <code>Safe</code> и воспользуйтесь функцией <code>readMay</code> для безопасного чтения таблицы. Подумайте как преобразовать таблицу типа <code>[[Maybe Int]]</code> в тип <code>Maybe [[Int]]</code>.</task>

    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

