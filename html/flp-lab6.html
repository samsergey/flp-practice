<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Функторы</h2>

      <p>Типы в Haskell — это больше чем описание данных. Это и описание логической или математической структуры образуемой данными. Мы увидели это на примере типа для чисел, которые могут иметь особые нечисловые значения. Такой подход универсален и наиболее часто встречающийся пример — тип <code>Maybe a</code>, говорящий о том, что величина значения типа <code>a</code> может быть неопределена.</p>
      <task>Посмотрите информацию о типе <code>Maybe</code>  с помощью команды <tt>:i</tt>.</task>

      <task>Ранее мы использовали оператор <code>(&lt;$&gt;)</code> для обработки множества значений в списке. Примените этот оператор к значениям типа <code>Maybe</code>. Можно ли сказать, что типы <code>[a]</code> и <code>Maybe a</code> имеют сходную структуру? Определите функции <code>listToMaybe :: [a] -> Maybe a</code> и <code>maybeToList :: Maybe a -> [a]</code>.</task>

      <task>Оператор <code>(&lt;$&gt;)</code> имеет своё имя: <code>fmap</code>. Выясните его тип с помощью команды <code>:t (&lt;$&gt;)</code>. Посмотрите (с помощью команды <code>:i</code> в интерпретаторе) какие ещё знакомые вам типы принадлежат к классу <code>Functor</code>.</task>

      <h2>Аппликативные функторы</h2>
    
      <task>Подгрузите модуль <code>Control.Applicative</code>. Теперь нам доступны новые возможности для работы с функторами. Посмотрите на то, как действуют операторы <code><|></code> и <code><*></code>, вычислив в GHCi следующие выражения.
      <pre><ghci>Nothing <|> Just 5
Just 3 <|> Just 5
Just 3 <|> Nothing
Nothing <|> Nothing
Nothing <*> Just 5
Just (4*) <*> Just 5
Just (2*) <*> Nothing
(+) <&> Just 3 <*> Just 7
(+) <&> Nothing <*> Just 7
(+) <&> Just 3 <*> Nothing</ghci></pre>
      Объясните своими словами, для чего нужны операторы <code><$></code> (<code>fmap</code>), <code><|></code>, <code><*></code>, применительно к функтору <code>Maybe</code>.</task>

      <task>Напишите функцию <code>sqrtM</code>, которая вычисляет квадратный корень вещественного числа и для отрицательных чисел возвращает <code>Nothing</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Вычислите  в интерпретаторе и объясните действие выражений:
	<pre><hs>(+2) <$> find (< 2) [2,3,1,4]
(*) <$> find odd [2,3,1,4] <*> find even [2,3,1,4]
(*) <$> find odd [2,6,10,4] <*> find even [2,3,1,4]
let vars = [("a",45),("x",7),("z",32)]
(*) <$> lookup "x" vars <*> lookup "a" vars</hs></pre>
 </task>

      <task>Посмотрите на определение функтора <code>Either</code>, и объясните его функториальные свойства, судя по примерам:
	<pre><hs>(*2) <$> Right 4
(*2) <$> Left 4
(*2) <$> Left "hello"
(+) <$> Right 8 <*> Right 5
(+) <$> Left "No!" <*> Right 5	</hs></pre>
      </task>			  

      <task>Напишите функцию <code>sqrtE</code>, которая вычисляет квадратный корень вещественного числа, и для отрицательных чисел возвращает сообщение об ошибке, в виде значения <code>Left "The argument is negative"</code>. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>
     
      <task>Поэкспериментируйте с функториальными свойствами типа <code>[]</code>:      <pre><hs>[] <|> [2,3]
[1,2,3] <|> [4,5]
[2] <|> []
[] <|> []
[] <*> [2,3,4]
[4*] <*> [2,3,4]
[4*,2+,^2] <*> [2,3,4]
(+) <&> [2,3] <*> [4,5,6]
(+) <&> [] <*> [2,3]
(+) <&> [1,2,3] <*> []</hs></pre>
</task>

      <task>Напишите функцию <code>sqrtL</code>, которая вычисляет квадратный корень вещественного числа, причём, для положительных аргументов оа возвращает как положительное, так и отрицательное значение корня, для нулевого -- только ноль, а для отрицательных значений -- ни одного значения. Вычислите с её помощью следующие выражения:
	<eqn>\sqrt 4,\quad \sqrt {-4},\quad 2\sqrt 5,\quad \sqrt 4 < \sqrt 9,\quad \sqrt 4 \cdot \sqrt{9}\,\quad \sqrt {-4} \cdot \sqrt{9}</eqn>
      </task>

      <task>Посмотрите на определение типа <code>IO</code> и объясните как он действует, в качестве функтора:
	<pre><hs>("Hello, " ++) <$> getLine
let readNum = read <$> getLine 
(+) <$> readNum <*> readNum
print 6 <|> error "!!"	</hs></pre>
      </task>			  
          
      <task>Посмотрите информацию о классах <code>Applicative</code> и <code>Alternative</code>. В определении класса <code>Applicative</code> присутствует полиморфная функция <code>pure</code>, которая позволяет ввести любое значение в функтор. Для экземпляров класса <code>Alternative</code> определено универсальное значение <code>empty</code>, соответствующее нейтральному значению по отношению к оператору <code>(&lt;|&gt;)</code> (да-да, они образуют моноид). </task>

      <task>Напишите универсальную функцию <code>sqrtA</code>, обобщающую функции <code>sqrtM</code> и <code>sqrtL</code> так, чтобы она работала c любыми альтернативными функторами: <code>Maybe</code>, <code>[]</code>, <code>IO</code>, причём, для списков, возвращала несколько корней.</task>

      <h2>Управление сообщениями об ошибках</h2>
      
      <p>Тип <code>Either</code> похож на тип <code>Maybe</code> тем, что у него есть одно "верное" значение -- правое, и "неверное" -- левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p>

      <p>Однако тип <code>Either</code> не является альтернативным. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>empty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>empty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p>

      <pre><hs>instance Monoid m =&gt; Alternative (Either m) where
  empty = Left mempty
  Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно
  Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения
  Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения</hs></pre>

      <p>Посмотрим, как это работает:</p>

      <pre><code>&gt; Left "fail" &lt;|&gt; Right 42
Right 42
&gt; Right 42 &lt;|&gt; Left "fail"
Right 42    
&gt; Left "I am " &lt;|&gt; Left "a fail"
Left "I am a fail"
</code></pre>


      <p>Как управлять сообщениями об ошибках, например, в функции <code>sqrtA</code>? Ведь в нашей программе мы используем только <code>empty</code>? А если мы перепишем всё на контекст <code>Either</code>, то потеряем возможность лёгкого переключения между частично-определёнными и многозначными вычислениями, что было довольно удобно...</p>

      <p>Итак, формулируем проблему. Нужно научиться вводить в программу сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали их. И надо чтобы эта возможность была определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>sqrtA</code> для разных контестов, а это уже не DRY (Don't Repeat Yourself).</p>

      <p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию -- <code>message</code>.</p>

      <pre><hs>class (Alternative f) =&gt; Failable f where
  message :: String -&gt; f a
  message _ = empty   -- определение, используемое по умолчанию
</hs></pre>

      <p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Either String</code> и <code>IO</code> -- специфические:</p>

      <pre><hs>instance Failable Maybe
instance Failable []
instance Failable (Either String) where message = Left
instance Failable IO where message = error
</hs></pre>

      <task>Внесите в определение функции <code>sqrtA</code> изменения, позволяющие использовать её в четырёх различных контекстах:
	<pre><ghci>*Main&gt; sqrtA 16 :: [Double]
[4,-4]
*Main&gt; sqrtA 16 :: Maybe Double
Just 4
*Main&gt; sqrtA 16 :: Either String Double
Right 4
*Main&gt; sqrtA 16
4
*Main&gt; sqrtA (-1) :: [Double]
[]
*Main&gt; sqrtA (-1) :: Maybe Double
Nothing
*Main&gt; sqrtA (-1) :: Either String Double
Left "Negative argument!"
*Main&gt; sqrtA (-1)
*** Exception: Negative argument!</ghci></pre></task>

      <p>
	Нам в дальнейшей работе пригодится класс <code>Failable</code>, поэтому стоит выделить его и определение экземпляров <code>Failable []</code>, <code>Failable Maybe</code> <code>Failable (Either String)</code> и  <code>Failable IO</code> в отдельный модуль <tt>Failable.hs</tt>
      </p>

      <h2>Монады</h2>
      
      <p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые сами возвращают функтор? Например, как можно дважды применить функцию <code>sqrtM</code>, чтобы вычислить <eq>\sqrt{\sqrt{16}}</eq>? Иными словами, как выполнить композицию функций, возвращающих не просто значение, а значение в некотором контексте <code>m</code>?</p>
      
      <p>Попробуем начать с использования оператора <code>&lt;$&gt;</code>:
	<pre><hs>*Main&gt; sqrtM <$> sqrtM 16
Just (Just 2)
*Main&gt; sqrtM <$> sqrtM (-1)
Just (Nothing)</hs></pre>
      </p> 

      <task>Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just 2))</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>(Just 2)</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление. Определите функцию <code>join</code>, которая занималась бы "соединением" контекстов так, чтобы можно было получить такие результаты:
	<pre><hs>*Main&gt; join $ sqrtM <$> sqrtM 16
Just 4
*Main&gt; join $ sqrtM <$> sqrtM (-1)
Nothing</hs></pre>
      </task>

      <p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в цепочки любые вычисления с контекстом. Для неё есть определённое в языке обозначение:</p>

      <pre><code>f =&lt;&lt; x   ≡   join $ f &lt;$&gt; x</code></pre>


      <p>Мы определили для функтора <code>Maybe</code> функцию <code>join</code> и сразу повысили её "ранг", позволяя объединять в цепочку функции возвращающие частичные значения. Функторы для которых определено соединение <code>join</code> называются <em>монадами</em>. </p>
      
      <task>Сравните типы операторов <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> и <code>=&lt;&lt;</code> и объясните своими словами их действие.</task>

      <p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

      <pre><hs><def>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</def></hs></pre>

      <task>Вычислите следующие выражения в интерпретаторе и объясните как происходят вычисления:
	<pre><hs>[-1,0,1,16] >>= sqrtA >>= sqrtA
Just 64 >>= sqrtA >>= sqrtA
Right 16 >>= sqrtA
Right (-16) >>= sqrtA
(read <$> getLine) >>= sqrtA >>= print</hs></pre></task>

      <p>Получается, что вычисления с помощью типов, являющихся монадами можно организовать не только безопасно, но и эффективно. Они работают как исключения, прекращая вычислительный процесс!</p>

<p>Подведём итоги и классы типов для рассмотренных нами объектов: </p>

<p><em>Функтор</em> -- это тип для которого оперелена операция <code>fmap</code> (<code>&lt;$&gt;</code>).</p>

<pre><code>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p><em>Аппликативный функтор</em> -- это функтор, для которого определены функции <code>pure</code> и <code>&lt;*&gt;</code></p>

<pre><code>class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  &lt;*&gt;  :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p><em>Монада</em> -- это аппликативный функтор, для которого определена функция <code>&gt;&gt;=</code></p>

<pre><code>class Applicative f =&gt; Monad f where
   (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>

<p>Для определения оператора <code>&gt;&gt;=</code> удобно использовать функцию <code>join</code>:</p>

<pre><code> x &gt;&gt;= f = join $ f &lt;$&gt; x
</code></pre>

      
    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

