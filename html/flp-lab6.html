<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>
      
      <p>Вооружившись знаниями о функторах и моноидах построим гибкую и расширяемую систему для вывода графической информации в формате SVG (Scalable Vector Graphics).</p>

      <h4>Типы для графических примитивов</h4>
      <p>Определим типы для представления двух (для начала) графических примитивов: точек и ломаных линий</p>
      <pre><hs>type Pt = (Float, Float)

data Primitive = Point Pt
               | Line [Pt]
  deriving Show</hs></pre>

      <h4>Представление примитивов в формате SVG</h4>

      <p>В формате SVG наши примитивы представляются в виде строк:<ul>
	  <li> точка с координатами <eq>(x, y)</eq> <pre>"&lt;circle rx='x' ry='y' r='1'/&gt;"</pre>
	  <li> ломаная линия с координатами <eq>(x_1, y_1), (x_2, y_2),...</eq> <pre>"&lt;polyline points='x1,y1 x2,y2 ...'/&gt;"</pre>
	</ul>
      </p>

      <task>Для того, чтобы упростить генерацию SVG напишите функцию <code>format</code> для форматирования строк по шаблону, последовательно заменяя символ <tt>'_'</tt> строками из списка. Например:
	<pre><ghci> Main> format "_ said: '_!'" ["John", "Hello"]
"John said: 'Hello!'"</ghci></pre>
	<em>Подсказка: воспользуйтесь функцией <code>splitOn</code> из модуля <code>Data.List.Split</code> для того, чтобы разбить форматируемую строку на части, а потом с помощью функции <code>zipWith</code> перемешайте эти части со строками из списка.</em>
      </task>

      <p>Определим собственный класс для того, что может быть экспортировано в SVG:
	<pre><hs>class SVG a where
    toSVG :: a -> String</hs></pre></p>

      <task>Определите экземпляр этого класса для типа <code>Primitive</code>:
	<pre><hs>instance SVG Primitive where
  toSVG (Point (x,y)) = _
  toSVG (Line pts) = _</hs></pre>
      </task>

      
      <p>Сами примитивы ещё не образуют полноценного изображения. Для того, чтобы можно было увидеть картинку, нужно объединить примитивы в такую структуру:
	<pre>"&lt;svg width='_' height='_' fill='none' stroke='black'&gt;
  примитив
  примитив
  ...
&lt;/svg&gt;"</pre>
	Здесь аттрибуты <tt>width</tt> и <tt>height</tt> задают размеры изображения. Сохранив этот текст в файл с расширением <tt>.html</tt> можно будет увидеть изображение в веб-браузере.</p>

      <p>
	Для представления картинки определим новый тип <code>Picture</code>:
	<pre><hs>data Picture = Picture BoundingBox [Primitive]
   deriving Show

type Box = ( Min Float, Max Float
            , Min Float, Max Float )

instance Bounded Float where
  minBound = 0
  maxBound = 1000</hs></pre>
	Здесь <code>Box</code> хранит координаты "рамки", обрамляющей изображения. Чтобы сделать тип <code>Box</code> моноидом, определим минимальное и максимальное допустимое значение координат, соответственно, 0 и 1000 используя экземпляр класса <code>Bounded</code> для типа <code>Float</code>.
      </p>

      <task>Определите фукцию <code>getBox :: Primitive -> Box</code>, вычисляющую обрамляющие координаты для примитивов.</task>
      
      <task>Определите экземпляр класса <code>SVG</code> для типа <code>Picture</code> и два конструктора <code>line :: [Pt] -> Picture</code> и <code>point :: Pt -> Picture</code>, которые бы вычисляли обрамляющие координаты для примитивов.</p>
      </task>

      <task>Запишите какое-либо несложное SVG-выражение в файл <tt>test.html</tt> с помощью функции <code>writeFile</code> и убедитесь в том, что  изображение открывается в браузере. Сознайте вспомогательную функцию <code>writeSVG :: SVG a => FileName -> a -> IO ()</code>.</task>
      
      <task>Напишите конструктор <code>polygon</code>для правильных многоугольников заданного размера (размер задаётся радусом описанной окружности).</task>

      <task>Добавьте конструктор <code>circle</code> для окружности, представляемой двадцатигранником.</task>

      <task>Добавьте конструктор <code>rectangle</code> для прямогугольника.</task>
      
      <h3>Композиция изображений</h3>
      <task>Так как в формате SVG примитивы попросту перечисляются, а затем изображаются, накладываясь друг на друга, это наводит на мысль, что изображения образуют моноид с операцией наложения. Определите экземпляр класса <code>Monoid</code> для типа <code>Picture</code>. Создайте избражение, показанное на рисунке:
	<p><svg width='185.0' height='185.0' fill='none' stroke='blue'><circle cx='100.0' cy='100.0' r='80.0'/><circle fill='blue' cx='100.0' cy='100.0' r='1'/><polyline points=' 180.0,100.0 124.72136,176.08453 35.278633,147.02281 35.27864,52.977173 124.721375,23.915482 180.0,100.000015'/></svg></p></task>
      
      <h3>Преобразования изображений</h3>

      <p>
	Воспользуемся тем, что мы научились перемножать матрицы для преобразования изображений. Существует класс преобразований плоскости, называемый <em>афинными</em>, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся в пересекающиеся, скрещивающиеся в скрещивающиеся. К ним относятся движения: сдвиги и повороты, и преобразования подобия.</p>
      
      <p>
	Любое афинное преобразование вектора <eq>\vec x</eq> можно представить в виде
	<eqn>\mathbf{T}\,\vec{x} =\mathbf{M}\,\vec{x} + \vec{v}</eqn>
	Матрица <eq>\mathbf{M}</eq> определяет поворот, масштабирование или сдвиг, а вектор <eq>\vec v</eq> -- параллельный перенос. Преобразование можно выразить в виде дополненной матрицы:
	<eqn>
	  \mathbf{T} = \begin{pmatrix}
	  M & v\\
	  0 & 1
	  \end{pmatrix}
	</eqn>
	При этом преобразуется вектор, дополненный справа единицей. Такое представление сразу говорит нам о том, что афинные преоьразования образуют моноид с операцией композиции.  
	 В компьютерной графике (системы OpenGL, DirectX, SVG, PostScript и т.п.) используется именно такая реализация афинных преобразований. 
      </p>

      <task>Опрелите три основные вида преобразований:
	<ul>
	  <li> масштабирование осей: <code>scaleT a b</code>
	    <eqn>\begin{pmatrix}
	      a & 0 & 0\\
	      0 & b & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> параллельный перенос: <code>translateT x y</code>
	    <eqn>\begin{pmatrix}
	      1 & 0 & x\\
	      0 & 1 & y\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	  <li> поворот на заданный угол: <code>rotateT alpha</code>
	    <eqn>\begin{pmatrix}
	      \cos \alpha & -\sin \alpha & 0\\
	      \sin \alpha & \cos \alpha & 0\\
	      0 & 0 & 1
	  \end{pmatrix}</eqn>
	</ul>
      </task>

      <task>Напишите функцию 
	<p>
	  <code>affine :: M Float -> Primitive -> Primitive</code>
	</p>, применяющую афинные преобразования к графическим примитивам, и преобразователи изображений:
	<p>
	  <code>transform :: M Float -> Picture -> Picture</code><br/>
	  <code>scale :: Float -> Float -> Picture -> Picture</code><br/>
	  <code>shift :: Float -> Float -> Picture -> Picture</code><br/>
	  <code>rotate :: Float -> Picture -> Picture</code>
	</p>
      </task>

      <task>Проверьте на примере квадрата как работают преобразователи и их композиция:
	<pre><ghci>let square = polygon 4 25
square <> rotate (pi/2) square
square <> shift 10 30 square
square <> scale 2 3 square
square <> (scale 2 3 . rotate (pi/3)) square
(shift 20 30 <> rotate (pi/3)) square </ghci></pre></task>      

      <task>Преобразователи позволяют отделить построение фигур от их расположения в пространстве. Наличие сдвига позволяет не задавать координаты центра конструкторам <code>polygon</code> и <code>circle</code>, а также ограничиться только размерами при конструировании прямоугольника. Упростите определения этих конструкторов и введите простой оператор <code>at</code>, с помощью которого можно было бы описать окружность со вписанным в неё квадратом, расположеные в координатах (100, 100) так:
	<pre><hs>(circle 50 <> rectangle 50 50) `at` (100,100)</hs></pre></task>

      <task>То, что начало координат области изображения SVG расположено в левом верхнем углу и ось ординат направлена вниз традиционно для компьютерной графики, но неудобно. Удобнее было бы вообще не думать о том, где находится центр координат, показывая всё, что содержит в себе изображение, даже если координаты объектов отрицательны. Тип <code>Picture</code> содержит в себе информацию об области, обрамляющей изображение, и эту информацию можно использовать для приведения всех координат изображения в видимую область положительных координат. Измените определение функции <code>toSVG</code> для типа <code>Picture</code> так, чтобы перед выводом ось ординат направлялась вверх, а минимальные координаты изображения перемещались в начало координат.</task>

</div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

