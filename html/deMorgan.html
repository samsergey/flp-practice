<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>

      <p>
	Для того, чтобы воспользоваться специальными возможностями компилятора <sl>GHC</sl>  в самом начале программы на Haskell укажем несколько директив:
	<pre><hs>{-# LANGUAGE
  FlexibleInstances,
  DeriveFunctor,
  GeneralizedNewtypeDeriving #-}</hs></pre>	
      </p>   

      <p>Совпадение структуры булевой алгебры и алгебры сопротивлений наводит на мысль, что можно абстрагировать саму структуру. То есть описать её в самом общем смысле, а потом создавать экземпляры алгебр для различных типов. Это даёт возможность писать универсальные функции, использующие свойства структуры и строить гомоморфизмы -- отображения одной алгебры в другую, сохраняющие структуры.
      
      <h2>Алгебры де Моргана</h2>

      <p>
	Алгеброй де Моргана называется структура, состоящая из множества на котором определены две бинарные операции <eq>+</eq> и <eq>\times</eq>, условно, называющиеся сложением и умножением, а также операция инволюции <eq>'</eq>, для которых выполняются следующие условия:<ul>
	  <li> операция <eq>+</eq> образует моноид с нейтральным элементом <eq>0</eq>: <eqns>a + 0 = 0 + a = a,\\ a + (b + c) = (a + b) + c;</eqns>
	  <li> операция <eq>\times</eq> образует моноид с нейтральным элементом <eq>1</eq>: <eqns>a \times 1 = 1 \times a = a,\\ a \times (b \times c) = (a \times b) \times c;</eqns>
	  <li> выполняется мультипликативное свойство нуля: <eqns>0\times x = x \times 0 = 0;</eqns>
	  <li> идемподентность инволюции: <eqns>(x')' = x;</eqns>
	  <li> дуальность нуля и единицы тносительно инволюции: <eqns>0' = 1,\\ 1' = 0;</eqns>
	  <li> законы де Моргана: <eqns>(A + B)' = A' \times B',\\ (A \times B)' = A' + B'.</eqns>
	</ul>
      </p>
      
      <p>
	Строго говоря, умножение ещё должно быть дистрибутивно по отношению к сложению, но в некоторых осмысленных приложениях таких алгебр (например в случае электрических сопротивлений) это может не выполняться. Зато если выполняется, то можно сложное выражение, состоящее из комбинации сложений и умножений привести к форме суммы одночленов, раскрыв все скобки, или, наоборот, упростить выражение, вынося за скобки общие множители.
      </p>

      <p>Иногда инволюция выполняет роль инверсии, то есть, порождает обратный элемент для операции умножения. Тогда выполняется следующее тождество: <eqns>x \times x' = x' \times x = 1.</eqns> Как мы увидим, существуют полезные алгебры де Моргана, в которых инволюция не являетс инверсией.</p>
      
      <p>Примеры алгебр де Моргана:
	<ul>
	  <li> Булева алгебра с операциями конъюнкции, дизъюнкции и отрицанием в качестве инволюции (инверсии).
	  <li> Алгебра множеств с пересечением, объединением и дополнением до некоторого множества, включающего в себя множества-операнды.
	  <li> Многозначные логические системы и нечёткие логики.	    
	  <li> сети сосредоточенных (эквивалентных) элементов к с операциями параллельного и последовательного соединений:<ul>
	      <li> электрические цепи двухполюсников,
	      <li> гидравлические сети и трубопроводы,
	      <li> механические системы с пружинами и демпферами,
	      <li> теплотехнические модели теплоизоляции,
	    </ul>
	    роль нуля тут играет разрыв сети, а едницу представляет короткое замыкание. Инволюция в задаче расчёта сетей относится не к самим элементам, а к величинам с ними связанным: сопротивлениям, ёмкостям, жёсткости, теплопровоности и т.д.
	  <li> прямоугольные таблицы с операциями объединения колонок и строк и транспозицией, в качестве инволюции (не инверсии);
	  <li> изображения на плоскости с операциями относительного позиционирования, например, по горизонтали, по вертикали и поворотом на 90 градусов, в качестве инволюции (не инверсии).
	</ul>
      </p>

      <p>
	Определим класс для алгебр де Моргана и ряд полезных функций:
<pre><hs>class DeMorgan a where
  {-# MINIMAL inv,((<-->)|(<||>)),(zero|one) #-}
  inv :: a -> a

  zero :: a
  zero = inv one

  one :: a
  one = inv zero

  (<-->) :: a -> a -> a
  a <--> b = inv (inv a <||> inv b)

  (<||>) :: a -> a -> a
  a <||> b = inv (inv a <--> inv b)</hs></pre>
      при этом мы воспользовались законом де Моргана для того, чтобы упростить работу с этим классом. Для определения экземпляра достаточно определить только одну их двух моноидальных операций, её нейтральный элемент и инволюцию.
      </p>

      <p>Создадим первый экземпляр класса <code>DeMorgan</code> для логических данных:
      <pre><hs>instance DeMorgan Bool where
  zero = False
  inv = not
  (<-->) = (&&)</hs></pre></p>

      <p>
	Убедимся в том, что три данные нами определения в полной мере задают алгебру для типа <code>Bool</code>:
	<pre><ghci><l></l> True <||> False
<o>True</o>
<l></l> one :: Bool
<o>True</o></ghci></pre>
      </p>

      
<p>Определим алгебру де Моргана для таблиц, представленных вложенными списками:
      <pre><hs>instance DeMorgan [[a]] where
  zero = [[]]
  (<||>) = (++)
  inv = transpose</hs></pre>
      Вот как эта алгебра работает:
	<pre><ghci><l></l> inv [[1,2],[3,4]]
<o>[[1,3],[2,4]]</o>
<l></l> [[1,2],[3,4]] <--> [[5],[6]]
<o>[[1,2,5],[3,4,6]]</o>
<l></l> [[1,2],[3,4]] <||> [[5,6]]
<o>[[1,2],[3,4],[5,6]]</o></ghci></pre>

<p>Так можно построить табулирующую функцию <code>table</code>
<pre><hs>table f vals = ([[" "]] <--> h) <||> (inv h <--> c)
  where
    h = [show <$> vals]
    c = [show <$> [ f x y | x <- vals] | y <- vals]

showTable tbl = putStrLn . unlines $ concat <$> tbl</hs></pre>

   <pre><ghci><l></l> showTable $ table mod [1..6]
<o>  1 2 3 4 5 6</o>
<o>1 0 0 0 0 0 0</o>
<o>2 1 0 1 0 1 0</o>
<o>3 1 2 0 1 2 0</o>
<o>4 1 2 3 0 1 2</o>
<o>5 1 2 3 4 0 1</o>
<o>6 1 2 3 4 5 0</o></ghci></pre>
 </p>

 <p> Из соображений эффективности стоило бы явно определить оператор <code><--></code> для типа <code>[[a]]</code>:
 <pre><hs>  (<-->) = zipWith (++)</hs></pre></p>				     
							
 <hr/>
		
      <p>Построим алгебру де Моргана для чисел, а конкретнее, для числовых типов для которых определена операция деления. Для этого определим тип-обёртку <code>Frac</code> и потребуем у компилятора вывести для него числовые, функториальные и прочие свойства:
<pre><hs>newtype Frac a = Frac {getFrac :: a}
  deriving (Show, Num, Fractional, Eq, Ord, Functor)

instance Fractional a => DeMorgan (Frac a) where
  zero = 0
  inv = (1/)
  (<-->) = (+)</hs></pre>
      </p>
      <p>Очень удобно, что  тип <code>Frac</code> наделён числовыми совйствами. Для него автоматически определены арифметические операции и представление в виде чисел. Последнее особенно удобно для записи небольших выражений:</p>

      <pre><ghci><l></l> getFrac $ 2 <||> 6
<o>1.5</o>
<l></l> getFrac $ 2 <--> 6 :: Frac Float
<o>8.0</o></ghci></pre>      

      <p>Таким образом складываются электрические и термические сопротивления. Например, выразим эффективное сопротивление цепи, показанной на рисунке 
      <p align='center'><img src="img/circ1.png" alt="" width='40%'/><br/><code>(3 <--> 7) <||> (11 <--> (12 <||> (1 <--> 5)))</code></p>
      
      <p>А вычислить силу тока при напряжении <eq>12\,V</eq> можно так:</p>
<pre><ghci><l></l> getFrac $ 12 / (3 <--> 7) <||> (11 <--> (12 <||> (1 <--> 5)))
<o>2.0</o></ghci></pre>		
      </p>

      <p>
	Для расчёта эффективной жёсткости сложной системы пружин, или же ёмкости батареи конденсаторов, тоже годится тип <code>Frac</code>, но для этих расчётов нужно поменять местами операторы <code><||></code> и <code><--></code>, а также элементы <code>zero</code> и <code>one</code>. Математики с радостью узнают в этом преобразовании переход к дуальной алгебре. Звучит красиво, но не хотелось бы писать <code>2&nbsp;<-->&nbsp;3</code> имея в виду параллельное соединение пружин.</p>
      
      <p>Тут математика даёт нам возможность воспользоваться её плодами. Для любой алгебры де Моргана определена дуальная ей алгебра, в которой "всё наоборот". Опишем это обстоятельство на языке Haskell. Создадим новый тип-обёртку  <code>Dual</code> для дуальных алгебр и сообщим, что если алгебра <code>a</code> является алгеброй де Моргана, то и дуальная ей тоже будет алгеброй де Моргана. Определение экземпляра класса <code>DeMorgan</code> для типа <code>Dual a</code> является доказательством этого утверждения по построению.

	    <pre><hs>newtype Dual a = Dual {getDual :: a}
  deriving (Show, Num, Fractional, Eq, Ord, Functor)

instance DeMorgan a => DeMorgan (Dual a) where
  zero = Dual one
  one = Dual zero
  inv x = inv <$> x
  Dual a <||> Dual b = Dual $ a <--> b
  Dual a <--> Dual b = Dual $ a <||> b
</hs></pre>

Теперь можно рассчитать эффективную жёсткость системы из трёх пружин, одна из которых последовательно соединяется с парой пружин, соединёных параллельно:
<pre><ghci><l></l> getFrac . getDual $ 600 <--> (200 <||> 300)
<o>450.0</o></ghci></pre>

 <p>Вывод типов позволяет указывать какую именно алгебру мы используем только "на выходе" из вычислений. Так мы можем явно и, в то же время, просто можем изменять способ вычисления выражения.</p>

					  
				      
      <h2>Цепи эквивалентных элементов</h2>

 <p>А что если мы захотим представлять и расчитывать цепи, содержащие не только сопротивления, но и ключи, конденсаторы, катушки и т.д? Для построения сетей эквивалентных элементов построим более предметно-ориентированный тип <code>Lumped</code>, который позволит нам  кроме значений <code>Value a</code>, представить короткое замыкание <code>Short</code> и разрыв цепи <code>Break</code>:

    <pre><hs>data Lumped a = Short
              | Value a
              | Break
  deriving (Show, Functor)</hs></pre>

<p>Определим алгебру де Моргана для этого типа, при условии, что значения элементов тоже образуют такую алгебру:</p>
    
    <pre><hs>instance DeMorgan s => DeMorgan (Lumped s) where
  zero = Break

  Value r1 <--> Value r2 = Value $ r1 <--> r2
  Short <--> r = r
  r <--> Short = r
  _ <--> Break = Break
  Break <--> _ = Break

  inv Short = Break
  inv Break = Short
  inv (Value r) = Value (inv r)</hs></pre>

	   <p>Объединение элементов в цепь сделаем свободным, то есть, разделим описание структуры и её интерпретацию. Цепь будет представлена некоторой структурой данных, ничего не вычисляющей, но отражающей алгебраическую структуру цепи. Более того, этот тип сам образует алгебру де Моргана. Интерпретация свободной алгебры -- это преобразование типа (множества) с сохранением структуры. Такие преобразования называются гомоморфизмами.</p>
	   
	   <p>Итак, вот тип для свободной цепи:
<pre><hs>data Circuit a = Zero
               | One
               | Elem a
               | Inv (Circuit a)
               | Par (Circuit a) (Circuit a)
               | Seq (Circuit a) (Circuit a)
  deriving (Show, Functor)</hs></pre>
</p>
	   <p>А вот определение алгебры де Моргана для этого типа:
	     <pre><hs>instance DeMorgan (Circuit a) where
  zero = Zero
  one = One
  (<-->) = Seq
  (<||>) = Par
  inv = Inv
</hs></pre> Инволюция или инверсия для элемента цепи имеет не очень много смысла, но для корректности мы включим её в описание типа.</p>

      <p>Самый первый и естественный гомоморфизм -- это преобразование типа <code>Circuit</code> в произвольный тип, для которого определена алгебра де Моргана:
<pre><hs>reduce :: DeMorgan a => Circuit a -> a
reduce circ = case circ of
  Zero -> zero
  One -> one
  Elem b -> b
  Inv a -> inv (reduce a)
  Par a b -> reduce a <||> reduce b
  Seq a b -> reduce a <--> reduce b</hs></pre>
			 Функция <code>reduce</code> подобна функции <code>fold</code>, которая сворачивает свободный моноид (список моноидов) в произвольный моноид:
 <pre><hs><def>fold :: (Foldable t, Monoid m) => t m -> m</def></hs></pre>
 От функции <code>fold</code> для функуторов  можно произвести полезнейшую функцию <code>foldMap</code>:
 <pre><hs><def>foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m</def>
foldMap = fold . fmap f </hs></pre></pre> Таким же образом можно образоватть функцию <code>reduceMap</code>:
 <pre><hs><def>reduceMap :: DeMorgan b => (a -> b) -> Circuit a -> b</def>
reduceMap = reduce . fmap f </hs></pre></pre> Эта функция позволяет явно указать какую именно алгебру де Моргана следует использовать при интерпретации цепи.</p>

      <p>Для построения собственно, цепей введём тип для элементов: сопротивления, ёмкости и интуктивности:
      <pre><hs>data Element = R Double
             | C Double
             | L Double
             deriving Show </hs></pre> а также конструкторы элементов цепи:
      <pre><hs>res = Elem . R
cap = Elem . C
coil = Elem . L
key True = Zero
key False = One</hs></pre></p>
      
      <p>Определим простенькую цепь, показанную на рисунке:
	<pre><hs><def>s :: Bool -> Circuit Element</def>
s k = res 10 <--> ((res 2 <--> coil 5e-3 <--> key k) <||> cap 10e-9)</hs></pre>
      </p>
      
      <p>Теперь построим различные примеры интерпретации. Для этого нужно описать интерпретацию отдельных элементов и указать используемую алгебру.</p>

 <p>Функция <code>connect</code> определяет является ли цепь замкнутой, используя булеву алгебру:
 <pre><hs><def>connected :: Circuit Element -> Bool</def>
connected = reduceMap f
  where
    f el = case el of
      R _ -> True
      C _ -> False
      L _ -> True</hs></pre></p>

<pre><ghci><l></l> connected (s True)
<o>True</o>
<l></l> connected (s False)
<o>False</o></ghci></pre>

<p>Функция <code>resistance</code> определяет эффективное сопротивление цепи для постоянного тока, используя алгебру для дробных чисел:
 <pre><hs><def>resistance :: Circuit Element -> Lumped Double
resistance = fmap getFrac . reduceMap (fmap Frac . f)
  where
    f el = case el of
      R r -> Value r
      C _ -> Break
      L _ -> Short</hs></pre> Здесь вычислительная работа производится внутри типа <code>Lumped</code>, Который мы объявили функтором.</p>

<pre><ghci><l></l> resistance (s True)
<o>Value 12</o>
<l></l> resistance (s False)
<o>Break</o></ghci></pre>

<p>Вот расчёт импеданса цепи:<pre><hs><def>impedance :: Double -> Circuit Element -> Lumped (Complex Double)</def>
impedance w = fmap getFrac . reduceMap (fmap Frac . f)
  where
    f el = Value $ case el of
      R r -> r :+ 0
      C c -> 1 / (0 :+ w*c)
      L l -> 0 :+ w*l</hs></pre>

<pre><ghci><l></l> impedance 1e3 (s False)
<o>Value (10.0 :+ (-99999.99999999997))</o>
<l></l>  impedance 1e3 (s True)
<o>Value (12.00020001420084 :+ 5.0002100065000405)</o>
<l></l>  impedance 1e6 (s False)
<o>Value (10.0 :+ (-100.0))</o>
<l></l>  impedance 1e6 (s True)
<o>Value (10.000832986116954 :+ (-102.04081598653629))</o></ghci></pre>

 <p>Если речь идёт о расчёте батареи конденсаторов, то нужно поменять агебру на дуальную:<pre><hs><def>capacity :: Circuit Element -> Lumped Double</def>
capacity = fmap (getFrac . getDual) . reduceMap (fmap (Dual . Frac) . f)
  where
    f el = case el of
      R _ -> Short
      C c -> Value c
      L _ -> Short</hs></pre></p>
							
      <h2>Полукольца</h2>
  
      <p>Алгебры де Моргана относятся к <strong>полукольцам</strong>.
	Полукольцом с единицей называется алгебраическая структура, определяющая две бинарные операции <eq>+</eq> и <eq>\times</eq>, условно, называющиеся сложением и умножением. Для которых выполняются следующие условия:<ul>
	  <li> операция <eq>+</eq> образует коммутативный моноид с нейтральным элементом <eq>0</eq>;
	  <li> операция <eq>\times</eq> образует моноид с нейтральным элементом <eq>1</eq>;
	  <li> выполняется мультипликативное свойство нуля: <eq>0\times x = x \times 0 = 0</eq>;
	  <li> умножение дистрибутивно по отношению к сложению.
	</ul>
      </p>
      <p>Полукольца образуют:
	<ul>
	  <li> числа и матрицы;
	  <li> графы с операциями объединения и связывания;
	  <li> алгебраические типы данных;
	  <li> регулярные и КС-грамматики;
 	  <li> и многие другие полезные структуры.
      </ul></p>    
   
      <p>
	Как видно, полукольца широко встречаются в задачах построения сложных систем с помощью комбинирования простых, а это и есть основы функционального (и не только) программирования.</p> 

 <p> Заголовок звучит страшно, но </p>
	   

 <p>Ещё один полезный пример: расчёт тепловой мощности, тряемой через теплоизолированную стену здания с окном:</p> 
Для описания слоёв теплоизоляторов и их границ определим тип <code>Layer</code>
 <pre><hs>data Layer = Insulation { coefficient :: Double
                        , thickness :: Double
                        , area :: Double }
           | Surface    { coefficient :: Double
                        , area :: Double } deriving Show</hs></pre>

 и способ вычисления термического сопротивления для этих слоёв:

 <pre><hs><def>layerRes :: </def>
layerRes el = case el of
  Insulation h l s -> l/(s*h)
  Surface a s -> 1/(s*a)
</hs></pre>
 
Для простоты описания теплотехничекой системы определим два "умных" конструктора, которые подготавливают типы для соединения слоёв в цепь:
 <pre><hs><def>insulation :: Double -> Double -> Double -> Circuit Layer</def>
insulation h = fmap Elem . Insulation h

<def>surface :: Double -> Double -> Circuit Layer</def>
surface = fmap Elem . Surface</hs></pre>

 Наконец, перечислим некоторые материалы, задавая для них коэффициент теплопроводности:
 <pre><hs>concrete, glass, air, stf :: Double -> Double -> Circuit Layer
-- бетон
concrete = insulation 0.5
-- стекло
glass = insulation 1.05
-- воздух (неподвижный)
air = insulation 0.024
-- пенопласт
stf = insulation 0.07
</hs></pre>
Все эти конструкторы представляют собой функции от толщины слоя и его площади.

 Теперь можно описывать теплотехническую систему:
 <pre><hs><def>system :: Circuit Layer</def>
system = surface 1.5 3 <--> (wall 2 <||> window 1) <--> surface 6 3
  where
    wall s = concrete 0.5 s <--> stf 0.1 s
    window s = glass 0.005 s <--> air 0.01 s <--> glass 0.005 s</hs></pre>

 и вычислить её термическое сопротивление:
						
 <pre><hs><def>thermalResistance :: Circuit Layer -> Double</def>
thermalResistance = getFrac . reduceMap (Frac . layerRes)</hs></pre>

<pre><ghci><l></l> thermalResistance system
<o>0.5932453290943858</o></ghci></pre>
<pre><ghci><l></l> 40 / thermalResistance system
<o>67.42573103957128</o></ghci></pre>

У моноидов есть одно чрезвычайно полезное свойство: функции, возвращающие моноид, сами обращуют моноид. То же самое можно доказать и для аглебр де Моргана:
<pre><hs>instance DeMorgan b => DeMorgan (a -> b) where
  zero = const zero
  one = const one
  inv f = inv . f
  f <||> g = \x -> f x <||> g x
  f <--> g = \x -> f x <--> g x</hs></pre> Здесь мы моглм бы использовать аппликативные свойства типа <code>(->)</code>, но для наглядности "доказательства" определили всё явно. 

Это свойство алгебры даёт нам возможность упростить описание теплотехничекой схемы, "вынеся за скобки" общий аргумент -- площадь слоя:
 <pre><hs><def>system :: Circuit Layer</def>
system = surface 1.5 3 <--> (wall 2 <||> window 1) <--> surface 6 3
  where
    wall = concrete 0.5 <--> stf 0.1
    window = glass 0.005 <--> air 0.01 <--> glass 0.005</hs></pre>
		      
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

