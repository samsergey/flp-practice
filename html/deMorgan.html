<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>

      <p>
	Для того, чтобы воспользоваться специальными возможностями компилятора <sl>GHC</sl>  в самом начале программы на Haskell укажем несколько директив:
	<pre><hs>{-# LANGUAGE
  FlexibleInstances,
  DeriveFunctor,
  GeneralizedNewtypeDeriving #-}</hs></pre>	
      </p>   

      <p>Совпадение структуры булевой алгебры и алгебры сопротивлений наводит на мысль, что можно абстрагировать саму структуру. То есть описать её в самом общем смысле, а потом создавать экземпляры алгебр для различных типов. Это даёт возможность писать универсальные функции, использующие свойства структуры и строить гомоморфизмы -- отображения одной алгебры в другую, сохраняющие структуры.
      
      <h2>Алгебры де Моргана</h2>

      <p>
	Алгеброй де Моргана называется структура, состоящая из множества на котором определены две бинарные операции <eq>+</eq> и <eq>\cdot</eq>, условно, называющиеся сложением и умножением, а также операция инволюции <eq>\neg</eq>, для которых выполняются следующие условия:<ul>
	  <li> операция <eq>+</eq> образует моноид с нейтральным элементом <eq>0</eq>;
	  <li> операция <eq>\cdot</eq> образует моноид с нейтральным элементом <eq>1</eq>;
	  <li> выполняется мультипликативное свойство нуля: <eq>0\cdot x = x \cdot 0 = 0</eq>;
	  <li> <eq>\neg (\neg x) = x</eq>
	  <li><eq>\neg 0 = 1,\quad \neg 1 = 0</eq>
	  <li><eq>\neg (A + B) = \neg A \cdot \neg B,\quad \neg (A \cdot B) = \neg A + \neg B.</eq>
	</ul>
      </p>
      
      <p>
	Строго говоря, умножение должно быть дистрибутивно по отношению к сложению, но в некоторых осмысленных приложениях таких алгебр (например в случае электрических сопротивлений) это может не выполняться. Зато если выполняется, то можно сложное выражение, состоящее из комбинации сложений и умножений привести к форме суммы одночленов, раскрыв все скобки, или, наоборот, упростить выражение, вынося за скобки общие множители.
      </p>

      <p>Иногда инволюция выполняет роль инверсии, то есть, порождает обратный элемент для операции умножения. Тогда выполняется следующее тождество: <eq>x \times \neg x = \neg x \times x = 1</eq>. Как мы увидим, существуют полезные алгебры де Моргана, в которых инволюция не являетс инверсией.</p>
      
      <p>Примеры алгебр де Моргана:
	<ul>
	  <li> Булева алгебра с операциями конъюнкции, дизъюнкции и отрицанием в качестве инволюции (инверсии).
	  <li> Алгебра множеств с пересечением, объединением и дополнением до некоторого множества, включающего в себя множества-операнды.
	  <li> Многозначные логические системы и нечёткие логики.	    
	  <li> сети сосредоточенных (эквивалентных) элементов к с операциями параллельного и последовательного соединений:<ul>
	      <li> электрические цепи двухполюсников,
	      <li> гидравлические сети и трубопроводы,
	      <li> механические системы с пружинами и демпферами,
	      <li> теплотехнические модели теплоизоляции,
	    </ul>
	    роль нуля тут играет разрыв сети, а едницу представляет короткое замыкание. Инволюция в задаче расчёта сетей относится не к самим элементам, а к величинам с ними связанным: сопротивлениям, ёмкостям, жёсткости, теплопровоности и т.д.
	  <li> прямоугольные таблицы с операциями объединения колонок и строк и транспозицией, в качестве инволюции (не инверсии);
	  <li> изображения на плоскости с операциями относительного позиционирования, например, по горизонтали, по вертикали и поворотом на 90 градусов, в качестве инволюции (не инверсии).
	</ul>
      </p>

      <p>
	Определим класс для алгебр де Моргана и ряд полезных функций:
<pre><hs>class DeMorgan a where
  zero :: a
  one :: a
  inv :: a -> a
  (<-->) :: a -> a -> a
  (<||>) :: a -> a -> a

  a <--> b = inv (inv a <||> inv b)
  a <||> b = inv (inv a <--> inv b)
  one = inv zero
  zero = inv one

  row :: Foldable t => t a -> a
  row = foldl1 (<-->)
  col :: Foldable t => t a -> a
  col = foldl1 (<||>)
  {-# MINIMAL inv,((<-->)|(<||>)),(zero|one) #-}</hs></pre>
      при этом мы воспользовались законом де Моргана для того, чтобы упростить работу с этим классом. Для определения экземпляра достаточно определить только одну их двух моноидальных операций, её нейтральный элемент и инволюцию.
      </p>

      <p>Создадим первый экземпляр класса <code>DeMorgan</code> для логических данных:
      <pre><hs>instance DeMorgan Bool where
  zero = False
  inv = not
  (<-->) = (&&)</hs></pre></p>

      <p>
	Убедимся в том, что три данные нами определения в полной мере задают алгебру для типа <code>Bool</code>:
	<pre><ghci><l></l> True <||> False
<o>True</o>
<l></l> one :: Bool
<o>True</o></ghci></pre>
      </p>

      
<p>Определим алгебру де Моргана для таблиц, представленных вложенными списками:
      <pre><hs>instance DeMorgan [[a]] where
  zero = [[]]
  (<||>) = (++)
  inv = transpose</hs></pre>
      Вот как эта алгебра работает:
	<pre><ghci><l></l> inv [[1,2],[3,4]]
<o>[[1,3],[2,4]]</o>
<l></l> [[1,2],[3,4]] <--> [[5],[6]]
<o>[[1,2,5],[3,4,6]]</o>
<l></l> [[1,2],[3,4]] <||> [[5,6]]
<o>[[1,2],[3,4],[5,6]]</o></ghci></pre>

<p>Так можно построить табулирующую функцию <code>table</code>
<pre><hs>table f vals = ([[" "]] <--> h) <||> (inv h <--> c)
  where
    h = [show <$> vals]
    c = [show <$> [ f x y | x <- vals] | y <- vals]

showTable tbl = putStrLn . unlines $ concat <$> tbl</hs></pre>

   <pre><ghci><l></l> showTable $ table mod [1..6]
<o>  1 2 3 4 5 6</o>
<o>1 0 0 0 0 0 0</o>
<o>2 1 0 1 0 1 0</o>
<o>3 1 2 0 1 2 0</o>
<o>4 1 2 3 0 1 2</o>
<o>5 1 2 3 4 0 1</o>
<o>6 1 2 3 4 5 0</o></ghci></pre>
 </p>

<hr/>
      <p>Построим алгебру де Моргана для чисел, а конкретнее, для числовых типов для которых определена операция деления. Для этого определим тип-обёртку <code>Frac</code> и потребуем у компилятора вывести для него числовые, функториальные и прочие свойства:
<pre><hs>newtype Frac a = Frac {getFrac :: a}
  deriving (Show, Num, Fractional, Eq, Ord, Functor)

instance Fractional a => DeMorgan (Frac a) where
  zero = 0
  inv = (1/)
  (<-->) = (+)</hs></pre>
      </p>
      <p>Очень удобно, что  тип <code>Frac</code> наделён числовыми совйствами. Для него автоматически определены арифметические операции и представление в виде чисел. Последнее особенно удобно для записи небольших выражений:</p>

      <pre><ghci><l></l> getFrac $ 2 <||> 6
<o>1.5</o>
<l></l> getFrac $ 2 <--> 6 :: Frac Float
<o>8.0</o></ghci></pre>      

      <p>Таким образом складываются электрические и термические сопротивления. Например, выразим эффективное сопротивление цепи, показанной на рисунке 
      <p align='center'><img src="img/circ1.png" alt="" width='40%'/><br/><code>(3 <--> 7) <||> (11 <--> (12 <||> (1 <--> 5)))</code></p>
      
      <p>А вычислить силу тока при напряжении <eq>12\,V</eq> можно так:</p>
<pre><ghci><l></l> getFrac $ 12 / (3 <--> 7) <||> (11 <--> (12 <||> (1 <--> 5)))
<o>2.0</o></ghci></pre>		
      </p>

      <p>
	Для расчёта эффективной жёсткости сложной системы пружин, или же ёмкости батареи конденсаторов, тоже годится тип <code>Frac</code>, но для этих расчётов нужно поменять местами операторы <code><||></code> и <code><--></code>, а также элементы <code>zero</code> и <code>one</code>. Математики с радостью узнают в этом преобразовании переход к дуальной алгебре. Звучит красиво, но не хотелось бы писать <code>2&nbsp;<-->&nbsp;3</code> имея в виду параллельное соединение пружин.</p>
      
      <p>Тут математика даёт нам возможность воспользоваться её плодами. Для любой алгебры де Моргана определена дуальная ей алгебра, в которой "всё наоборот". Опишем это обстоятельство на языке Haskell. Создадим новый тип-обёртку  <code>Dual</code> для дуальных алгебр и сообщим, что если алгебра <code>a</code> является алгеброй де Моргана, то и дуальная ей тоже будет алгеброй де Моргана. Определение экземпляра класса <code>DeMorgan</code> для типа <code>Dual a</code> является доказательством этого утверждения по построению.

	    <pre><hs>newtype Dual a = Dual {getDual :: a}
  deriving (Show, Num, Fractional, Eq, Ord, Functor)

instance DeMorgan a => DeMorgan (Dual a) where
  zero = Dual one
  one = Dual zero
  inv x = inv <$> x
  Dual a <||> Dual b = Dual $ a <--> b
  Dual a <--> Dual b = Dual $ a <||> b
</hs></pre>

Теперь можно рассчитать эффективную жёсткость системы из трёх пружин, одна из которых последовательно соединяется с парой пружин, соединёных параллельно:
<pre><ghci><l></l> getFrac . getDual $ 600 <--> (200 <||> 300)
<o>450.0</o></ghci></pre>

 <p>Вывод типов позволяет указывать какую именно алгебру мы используем только "на выходе" из вычислений. Так мы можем явно и, в то же время, просто можем изменять способ вычисления выражения.</p>

					  
				      
      <h2>Сети эквивалентных элементов</h2>
 <p>А если мы захотим представлять и расчитывать сети, содержащие не только сопротивления, но и ключи, конденсаторы, катушки и т.д. Для построения сетей эквивалентных элементов построим более предметно-ориентированный тип <code>Lamped</code>, который позволит нам представить короткое замыкание <code>Short</code> и разрыв <code>Break</code>:

    <pre><hs>data Lumped a = Short
              | Value a
              | Break
  deriving (Show,Eq,Functor)

instance DeMorgan s => DeMorgan (Lumped s) where
  zero = Short

  Value r1 <--> Value r2 = Value $ r1 <--> r2
  Short <--> r = r
  r <--> Short = r
  _ <--> Break = Break
  Break <--> _ = Break

  inv Short = Break
  inv Break = Short
  inv (Value r) = Value (inv r)</hs></pre>

      <h2>Полукольца</h2>
  
      <p>Алгебры де Моргана относятся к <strong>полукольцам</strong>.
	Полукольцом с единицей называется алгебраическая структура, определяющая две бинарные операции <eq>+</eq> и <eq>\times</eq>, условно, называющиеся сложением и умножением. Для которых выполняются следующие условия:<ul>
	  <li> операция <eq>+</eq> образует коммутативный моноид с нейтральным элементом <eq>0</eq>;
	  <li> операция <eq>\times</eq> образует моноид с нейтральным элементом <eq>1</eq>;
	  <li> выполняется мультипликативное свойство нуля: <eq>0\times x = x \times 0 = 0</eq>;
	  <li> умножение дистрибутивно по отношению к сложению.
	</ul>
      </p>
      <p>Полукольца образуют:
	<ul>
	  <li> числа и матрицы;
	  <li> графы с операциями объединения и связывания;
	  <li> алгебраические типы данных;
	  <li> регулярные и КС-грамматики;
 	  <li> и многие другие полезные структуры.
      </ul></p>    
   
      <p>
	Как видно, полукольца широко встречаются в задачах построения сложных систем с помощью комбинирования простых, а это и есть основы функционального (и не только) программирования.</p> 

 <p> Заголовок звучит страшно, но </p>
	   

 <p>Ещё один полезный пример: расчёт тепловой мощности, тряемой через теплоизолированную стену здания с окном:</p> 

 
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

