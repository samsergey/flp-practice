<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>

      <p>
	Для того, чтобы воспользоваться специальными возможностями компилятора <sl>GHC</sl>  в самом начале программы на Haskell укажем несколько директив:
	<pre><hs>{-# LANGUAGE
  FlexibleInstances,
  DeriveFunctor,
  GeneralizedNewtypeDeriving #-}</hs></pre>	
      </p>   
      

<p>Совпадение структуры булевой алгебры и алгебры сопротивлений наводит на мысль, что можно абстрагировать саму структуру. То есть описать её в самом общем смысле, а потом создавать экземпляры алгебр для различных типов. Это даёт возможность писать универсальные функции, использующие свойства структуры и строить гомоморфизмы -- отображения одной алгебры в другую, с сохранением структуры.
      
      <h2>Алгебры де Моргана</h2>

      <p>
	Алгеброй де Моргана называется структура, состоящая из множества на котором определены две бинарные операции <eq>+</eq> и <eq>\cdot</eq>, условно, называющиеся сложением и умножением, а также операция инверсии <eq>\neg</eq>, для которых выполняются следующие условия:<ul>
	  <li> операция <eq>+</eq> образует моноид с нейтральным элементом <eq>0</eq>;
	  <li> операция <eq>\cdot</eq> образует моноид с нейтральным элементом <eq>1</eq>;
	  <li> выполняется мультипликативное свойство нуля: <eq>0\cdot x = x \cdot 0 = 0</eq>;
	  <li> <eq>\neg (\neg x) = x</eq>
	  <li><eq>\neg 0 = 1,\quad \neg 1 = 0</eq>
	  <li><eq>\neg (A + B) = \neg A \cdot \neg B,\quad \neg (A \cdot B) = \neg A + \neg B.</eq>
	</ul>
      </p>
	  
      <p>
	Строго говоря, умножение должно быть дистрибутивно по отношению к сложению, но в некоторых осмысленных приложениях таких алгебр (например в случае электрических сопротивлений) это может не выполняться. Зато если выполняется, то можно сложное выражение, состоящее из комбинации сложений и умножений привести к форме суммы одночленов, раскрыв все скобки, или, наоборот, упростить выражение, вынося за скобки общие множители.
      </p>

      <p>Примеры алгебр де Моргана:
	<ul>
	  <li> Булева алгебра с операциями конъюнкции, дизъюнкции и отрицанием в качестве инверсии.
	  <li> Алгебра множеств с пересечением, объединением и дополнением до некоторого множества, включающего в себя множества-операнды.
	  <li> Многозначные логические системы и нечёткие логики.	    
	  <li> сети сосредоточенных (эквивалентных) элементов к с операциями параллельного и последовательного соединений:<ul>
	      <li> электрические цепи двухполюсников,
	      <li> гидравлические сети и трубопроводы,
	      <li> механические системы с пружинами и демпферами,
	      <li> теплотехнические модели теплоизоляции,
	    </ul>
	    роль нуля тут играет разрыв сети, а едницу представляет короткое замыкание;
	  <li> прямоугольные таблицы с операциями объединения колонок и строк и транспозицией, в качестве инверсии;
	  <li> изображения на плоскости с операциями относительного позиционирования, например, по горизонтали, по вертикали и поворотом на 90 градусов, в качестве инверсии.
	</ul>
      </p>

      <p>
	Определим класс для алгебр де Моргана и ряд полезных функций:
<pre><hs>class DeMorgan a where
  zero :: a
  one :: a
  inv :: a -> a
  (<->) :: a -> a -> a
  (<|>) :: a -> a -> a

  a <-> b = inv (inv a <|> inv b)
  a <|> b = inv (inv a <-> inv b)
  one = inv zero
  zero = inv one

  row :: Foldable t => t a -> a
  row = foldl1 (<->)
  col :: Foldable t => t a -> a
  col = foldl1 (<|>)
  {-# MINIMAL inv,((<->)|(<|>)),(zero|one) #-}</hs></pre>
      при этом мы воспользовались законом де Моргана для того, чтобы упростить работу с этим классом. Для определения экземпляра достаточно определить только одну их двух моноидальных операций, её нейтральный элемент и инверсию.
      </p>

      <p>Создадим первый экземпляр класса <code>DeMorgan</code> для логических данных:
      <pre><hs>instance DeMorgan Bool where
  zero = False
  inv = not
  (<->) = (&&)</hs></pre></p>

      <p>
	Убедимся в том, что три данные нами определения в полной мере задают алгебру для типа <code>Bool</code>:
	<pre><ghci><l></l> True <|> False
<o>True</o>
<l></l> one :: Bool
<o>True</o></ghci></pre>
      </p>

      
<p>Определим алгебру де Моргана на для таблиц, представленных вложенными списками:
      <pre><hs>instance DeMorgan [[a]] where
  zero = [[]]
  (<|>) = (++)
  inv = transpose</hs></pre>
      Вот как эта алгебра работает:
	<pre><ghci><l></l> inv [[1,2],[3,4]]
<o>[[1,3],[2,4]]</o>
<l></l> [[1,2],[3,4]] <-> [[5],[6]]
<o>[[1,2,5],[3,4,6]]</o>
<l></l> [[1,2],[3,4]] <|> [[5,6]]
<o>[[1,2],[3,4],[5,6]]</o></ghci></pre>

<p>Так можно построить табулирующую функцию <code>table</code>
<pre><hs>table f vals = ([[" "]] <-> h) <|> (inv h <-> c)
  where
    h = [show <$> vals]
    c = [show <$> [ f x y | x <- vals] | y <- vals]

showTable tbl = putStrLn . unlines $ concat <$> tbl</hs></pre>

   <pre><ghci><l></l> showTable $ table mod [1..6]
<o>  1 2 3 4 5 6</o>
<o>1 0 0 0 0 0 0</o>
<o>2 1 0 1 0 1 0</o>
<o>3 1 2 0 1 2 0</o>
<o>4 1 2 3 0 1 2</o>
<o>5 1 2 3 4 0 1</o>
<o>6 1 2 3 4 5 0</o></ghci></pre>
 </p>

<hr/>
      <p>Построим алгебру де Моргана для чисел. Для этого определим тип-обёртку <code>Frac</code> для которой потребуем вывести числовые, функториальные и прочие свойства
<pre><hs>newtype Frac a = Frac {getFrac :: a}
  deriving (Show, Num, Fractional, Eq, Ord, Functor)

instance Fractional a => DeMorgan (Frac a) where
  zero = 0
  inv = (1/)
  (<->) = (+)</hs></pre>
      </p>
      <p>Директива <code>deriving</code> наделяет тип <code>Frac</code> числовыми совйствами, так что для него определены арифметические операции и представление в виде чисел:</p>

      <pre><ghci><l></l> 2 <|> 6 :: Frac Float
<o>Frac {getFrac = 1.5}</o>
<l></l> 2 <-> 6 :: Frac Float
<o>Frac {getFrac = 8.0}</o></ghci></pre>      

      <p>Таким образом складываются электрические и термические сопротивления. Например, так можно выразить эффективное сопротивление цепи, показанной на рисунке 
      <p align='center'><img src="img/circ1.png" alt="" width='40%'/><br/><code>(3 <-> 7) <|> (11 <-> (12 <|> (1 <-> 5)))</code></p>
      
      <p>А вычислить силу тока при напряжении <eq>12\,V</eq> можно так:</p>
<pre><ghci><l></l> 12 / (3 <-> 7) <|> (11 <-> (12 <|> (1 <-> 5))) :: Frac Float
<o>Frac {getFrac = 2.0}</o></ghci></pre>		
      </p>
      <!-- <hr/> -->
      <!-- <p>Рассмотрим задачу расчёта теплового потока через стену дома. Стена бетонная толщиной 40 см, со слоем внешнего пенопропиленового утеплителя толщиной 10 см. Стена имеет общую площадь 2 м². В стене есть окно из двуслойного стеклопакета площадью 0.8 м².</p> -->
      <!-- <p>Тепловой поток можно рассчитать, зная перепад температур <eq>\Delta T</eq> и эффективное тепловое сопротивление <eq>r</eq>: <eqn>Q = \frac{\Delta T}{r}.</eqn></p> -->
      
      <!-- <p>Термическое сопротивление слоя теплопроводностью <eq>h</eq>, толщиной <eq>d</eq> и площадью <eq>S</eq> вычисляется по формуле: <eqn>r = \frac{d}{S h}.</eqn> Для конвективного слоя тепловое сопротивление рассчитывается исходя из площади <code>S</code> и коэффициента теплообмена <eq>\alpha</eq>: <eqn>r = \frac{1}{S \alpha}.</eqn></p> -->

	
      <!-- <p> -->
      <!-- 	Теплопроводность материалов (в  <eq>W/K\cdot m</eq>) приведена в таблице: -->
      <!-- 	<table> -->
      <!-- 	  <tr><td>Бетон</td><td><eq>0.5</eq></td></tr> -->
      <!-- 	  <tr><td>Стекло</td><td><eq>1.05</eq></td></tr> -->
      <!-- 	  <tr><td>Воздух статичный</td><td><eq>0.024</eq></td></tr> -->
      <!-- 	  <tr><td>Теплоизолятор</td><td><eq>0.07</eq></td></tr> -->
      <!-- </table></p> -->

      <!-- <p>Коэффициент конвективного теплообмена стены с воздухом равен <eq>5 W/K</eq>.</p> -->

      <h2>Полукольца</h2>
  
      <p>Алгебры, подобные булевой или алгебре электрических цепей встречаются очень часто и относятся к <strong>полукольцам</strong>.
	Полукольцом с единицей называется алгебраическая структура, определяющая две бинарные операции <eq>+</eq> и <eq>\cdot</eq>, условно, называющиеся сложением и умножением. Для которых выполняются следующие условия:<ul>
	  <li> операция <eq>+</eq> образует коммутативный моноид с нейтральным элементом <eq>0</eq>;
	  <li> операция <eq>\cdot</eq> образует моноид с нейтральным элементом <eq>1</eq>;
	  <li> выполняется мультипликативное свойство нуля: <eq>0\cdot x = x \cdot 0 = 0</eq>;
	  <li> умножение дистрибутивно по отношению к сложению.
	</ul>
      </p>
      <p>Полукольца образуют:
	<ul>
	  <li> числа и матрицы;
	  <li> графы с операциями объединения и связывания;
	  <li> алгебраические типы;
	  <li> регулярные и КС-грамматики;
	  <li> сети сосредоточенных (эквивалентных) элементов к с операциями параллельного и последовательного соединений:<ul>
	      <li> электрические цепи двухполюсников,
	      <li> гидравлические сети и трубопроводы,
	      <li> механические системы с пружинами и демпферами,
	      <li> теплотехнические модели теплоизоляции,
	      <li> разветвлённые вычислительные процессы;
	    </ul>
 	  <li> и многие другие полезные структуры.
      </ul></p>    
   
      <p>
	Как видно, полукольца широко встречаются в задачах построения сложных систем с помощью комбинирования простых, а это и есть основы функционального (и не только) программирования.</p> 

      
      <h2>Свободная алгебра для полуколец</h2>

Заголовок звучит страшно, но 
      
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

