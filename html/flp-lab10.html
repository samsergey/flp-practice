<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
    <style>
      .logo {
      display: inline-block;
      float: left;
      margin: 0 1ex 1ex 0;
      }
    </style>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <h2>Чтение данных в формате CSV</h2>
    
      <p><img  class='logo' src='img/csv.png' width=15%/>Хранение данных в виде текстовых таблиц удобно как для человека, так и для машины. Среди табулированных данных часто встречается формат значений, разделяемых запятыми — CSV (Comma Separated Values), он используется такими программами как <sl>MS Excell</sl>, почтовыми клиентами для хранения адресов и т.п.</p>

      <p>
	Упрощённая спецификация формата:
	<ul>
	  <li> Каждая строка файла — это одна строка таблицы.
	  <li> Разделителем значений колонок является символ запятой (<tt>,</tt>). Однако на практике часто используются другие разделители, например в русифицированном <sl>MS Excell</sl> используется символ "точка с запятой" (<tt>;</tt>)
	  <li> Значения, содержащие строки, обрамляются двойными кавычками (<tt>&quot;</tt>).
	</ul>
      </p>
  
<p>
  Приведём пример простой "базы данных", хранящей информацию о некотрых персонах:

  <pre>"James Mitchell", 32, "golf, beer",     yes
"Garry Potter",   14, "magic"
"Mary Kay",       25, "James Mitchell", no
"Goofy",          85, "troubles",       yes</pre>

	Эти данные будут соответствовать списку записей данных типа <code>Person</code>:

	<pre><hs>data Person { name :: String
            , age :: Int
            , hobby :: String
	    , married :: Maybe Bool } deriving Show</hs></pre>
	Обратите внимание на то, что последнего поля в таблице может и не быть.</p>
      
      <p>Транслятор отражает структуру типа данных. Типу-произведению соответствует аппликативная последовательность:
      <pre><hs>person = Person <$> string_
                <*> number_
                <*> string_
		<*> optional bool_</hs></pre>
      </p>

      <task>Определите трансляторы для элементов:
	<pre><hs>number_ = _
string_ = _
bool_ = _</hs></pre>
      </task>

      <task>Напишите функцию <code>parse</code>, которая возвращает только результат (в случае успешной трансляции).<pre><hs><def>parse :: Parser String a -> String -> Maybe a</def></hs></pre></task>
      
      <task>Напишите функцию <code>clean</code>, которая убирала бы в таблицк лишние пробелы и знаки табуляции  (оставляя их в строковых полях).
	<pre><ghci><l></l> cleanJSON "'James Mitchell', 32, 'golf'"
<o>Just "'James Mitchell',32,'golf'"</o></hs></pre></task>

      <task>Напишите функцию <code>readCSV</code> которая читает строку, содержащую СSV-таблицу, возвращая список объектов, считываемых указанным транслятором.<pre><hs><def>readCSV :: Parser String a -> String -> [a]</def></hs></pre></task>

      <h2>Чтение данных в формате JSON</h2>

      <p><img  class='logo' src='img/json.jpg' width=15%/>Продолжим разбор стандартных форм хранения данных. Рассмотрим ещё один крайне популярный формат JSON. Этот формат широко используется для сериализации и передачи в виде потока, сложных иерархических структур: произвольных объектов, массивов и элементарных данных.</p>

      <p> Вот, что написано на официальном сайте <tt>http://www.json.org/json-ru.html</tt>
	<disclaim>JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Он включает в себя следующие структуры:

	  <ul>
	    <li/><em>Объект</em> -- неупорядоченный набор пар ключ/значение. Объект начинается с открывающей фигурной скобки и заканчивается закрывающей фигурной скобкой. Каждое имя сопровождается двоеточием, пары ключ/значение разделяются запятой.

	    <pre><tt>{'name':'Jane','age':22}</tt></pre>
      
	    <li/><em>Массив</em> -- упорядоченная коллекция значений. Массив начинается с открывающей квадратной скобки и заканчивается закрывающей квадратной скобкой. Значения разделены запятой.

	    <pre><tt>[23,45,6,23]
['cat','dog']</tt></pre>
      
	    <li/><em>Значение</em> может быть строкой в кавычках, числом, <tt>true</tt>, <tt>false</tt>, объектом или массивом. Эти структуры могут быть вложенными.

	    <li/> Пробелы могут использоваться между любыми лексемами.
	  </ul>
	</disclaim>
      </p>

      <p>Приведём пример выражения JSON (мы пользуемся стандартом JSON5, допускающим одинарные кавычки):</p>

      <pre><tt>{
    'workers' :
    [
	{
	    'name' : 'James Mitchell',
	    'age'  : 32,
	    'hobby': ['golf', 'eating pizza']
	},
	{
	    'name' : 'Mary Kay',
	    'hobby': ['James Mitchell']
	},
	{
	    'name': 'Garry Potter',
	    'age' : 14
	}    
    ]
}</tt></pre>

      <p>Чтение JSON означает интерпретацию строки и создание соответствующей структуры данных.</p>

      <p>Для представления данных определим тип <code>JSON</code>:
	<pre><hs>data JSON = N Int
          | S String
          | B Bool
          | A [JSON]
          | O [(String, JSON)]
          deriving Show</hs></pre></p>
      
      <p>
	Транслятор отражает структуру типа:

      <pre><hs>json = N <$> number_ <|>
       S <$> string_ <|>
       B <$> bool_ <|>
       A <$> listOf json `between` "[]" <|>
       O <$> listOf (pairOf string_ json) `between` "{}"</hs></pre>
      </p>

      <task>Определите трансляторы для элементов:

	<pre><hs>listOf p = _
pairOf p1 p2 = _
between p [s1,s2] = _</hs></pre>
      </task>

 <task> Напишите функцию <code>readJSON</code>:
   <pre><hs>readJSON :: String -> Maybe JSON</hs></pre></task>


<h2>Транслятор регулярных выражений</h2>

      <p><img  class='logo' src='img/regexp.jpg' width=15%/>Рассмотрим достаточно серьёзную задачу разбора и трансляции регулярных выражений. Транслятор регулярных выражений должен превращать строку в транслятор, соответствующий регулярному выражению. Например, из строки <code>"a.b+"</code> он должен сделать транслятор,

  <pre><hs> only (term 'a') <> only next <> msome (term 'b')</hs></pre>

<p>То есть, это трансляция строки в транслятор. Такой процесс называется суперкомпилированием.</p>

 <p>Мы не будем здесь реализовывать полный набор функций, реализованных в стандартах POSIX или Perl, остановимся на основных элементах и их комбинаторах:</p>
					
 <p>Регулярное выражение может быть:</p>
   <ul>
     <li/> <em>символом-литералом</em>, которые представляют сами себя;
     <li/> метасимволом <code>.</code> (точка), представляющим <em>любой символ</em>;
     <li/> <em>символьным классом</em>  -- набором символов в квадратных скобках <code>[&nbsp;]</code>, представляющим множество возможных символов (<code>[cat]</code> означает <code>c</code> или <code>a</code> или <code>t</code>); если требуется указать символы, которые не входят в указанный набор, то используют символ <code>^</code> внутри квадратных скобок (<code>[^cat]</code> -- любой символ, кроме <code>c</code>, <code>a</code> или <code>t</code>); возможно указание диапазонов символов с помощью тире, например <code>[0-9]</code> -- означает любой цифровой символ;
     <li/> <em>группой</em> -- регулярным выражением, окружённым круглыми скобками;
     <li/> <em>последовательностью</em> регулярных выражений;
     <li/> <em>объединением</em> (перечислением) регулярных выражений;
     <li/> регулярным выражением с модификаторами повторения.
   </ul>

 <p>Приведём формальное описание грамматики регулярных выражений, трансляцию которых мы реализуем:</p>


<pre><nt>R</nt> = a     <ht>символ-литерал</ht>
    .     <ht>любой символ</ht>
    [<nt>C</nt>]   <ht>символьный класс</ht>
    (<nt>R</nt>)   <ht>группа</ht>
    <nt>R</nt>|<nt>R</nt>   <ht>объединение</ht>
    <nt>R</nt><nt>R</nt>    <ht>конкатенация (последовательность)</ht>
    <nt>R</nt><nt>M</nt>    <ht>модификация</ht>

символьный класс
<nt>С</nt> = a     <ht>символ-литерал</ht>
    a-b   <ht>диапазон символов</ht>
    ^<nt>C</nt>    <ht>отрицание класса</ht>

модификаторы повторения 
<nt>M</nt> = *     <ht>повторение элемента ноль или много раз</ht>
    +     <ht>повторение элемента один или много раз</ht>
    ?     <ht>повторение элемента ноль или один раз</ht></pre> 
</p>

 <p>Подобно арифметическим выражениям, регулярные выражения "собираются" с помощью трёх операций -- объединения, конкатенации и модификации, причём приоритет объединения ниже чем у конкатенации, а у конкатенации -- ниже чем у модификаторов. Объединение можно определить функциональной свёрткой <code>foldP</code>, а конкатенацию осуществить функцией <code>msome</code>:</p>

<pre><hs>_R = foldP (msome element) alt
   where alt = (<|>) <$ term '|'
         element = (group <|> (only <$> symbol)) <**> modifier
         group = between '(' ')' _R
         symbol = anychar <|> charClass <|> literal </hs></pre>

<p>Теперь определим элементы их интерпретацию. (Сейчас будет немного сюрреализма, но смысл в этом всё же есть.) Все элементы после распознавания транслируются в трансляторы, которые, в свою очередь свои результаты комбинируют в строку.</p>

 <p>Символ-литерал интерпретируется, как транслятор <code>term</code>.</p>
<pre><hs>literal = term <$> term `except` "?+*()[]|."</hs></pre>

 <p>Метасимвол <code>.</code> (точка) транслируется в транслятор <code>next</code></p>
<pre><hs>anychar = next <$ term '.'</hs></pre>

 <p>Определение для символьных классов выглядит более сложным, но устроено достаточно прямолинейно:</p>

 <pre><hs>charClass = between '[' ']' c
   where c = oneof term <$> chars
         <|> except term <$> (term '^' *> chars)

         chars = msome (range <|> only char)
         char = term `except` "]"
         range = enumFromTo <$> char <*> (term '-' *> char)</hs></pre>

 <p>Модификаторы сделаем функциями, наподобие арифметических операций:</p>				

 <pre><hs>modifier = option <|> repeat0 <|> repeat1 <|> pure id
   where option = mopt <$ term '?'
         repeat1 = msome <$ term '+'
         repeat0 = mmany <$ term '*'</hs></pre>

 <p>Наконец, сам транслятор регулярных выражений превратим в полноценный транслятор:</p>
						
<pre><hs>regexp s = case run _R s of
  Ok "" p -> p
  _ -> empty</hs></pre>


 <p>Вот как можно им пользоваться:</p>

 <pre><ghci>λ> run (search (regexp "c.(t|p)")) "the cat has a cup"
Ok "" ["cat","cup"] </ghci></pre>

					
<p>Вот более полезный пример. Пусть нам нужно из извлечь параметры из URL:</p>
<pre>www.site.org?day=7&name=adam&fruit=apple</pre>
Мы можем сделать это с помощью регулярного выражения так:

 <pre><hs>params = search (regex "[a-z]+=[^&]+")</hs></pre>

 <pre><ghci>λ> run params "www.site.org?day=7&name=adam&fruit=apple"
Ok "" ["day=7","name=adam","fruit=apple"]</ghci></pre>
 
 А так -- транслировать в словарь:
 
 <pre><hs>params = search ((,) <$> regex "[a-z]+" <*> (term '=' *> regex "[^&]+"))</hs></pre>

 <pre><ghci>λ> run params "www.site.org?day=7&name=adam&fruit=apple"
Ok "" [("day","7"),("name","adam"),("fruit","apple")]</ghci></pre>
 
 <task>Проверьте правильность работы транслятора регулярных выражений на нескольких примерах:
<ul>
  <li> число с плавающей точкой
  <li> простой e-mail адрес
  <li> дата в формате DD.MM.YYYY
  <li> слова типа "тум-там-тум", "там-там-там-тарарам", "трам-тарарам-там-там" и т.д.
</ul>
		       </task>


      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>
