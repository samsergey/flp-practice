<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>
    <div class='tasks'>
      <!-- ------------------------------------------------------------ -->

      <h2>Чтение данных в формате CSV</h2>

      
      <h2>Чтение данных в формате JSON</h2>

      <p>Замечательный примером использования нашей системы трансляции будет разбор и чтение данных в формате JSON. Этот формат широко используется для сериализации и передачи в виде потока, сложных иерархических структур: произвольных объектов, массивов и элементарных данных.</p>

      <p> Вот, что написано на официальном сайте <tt>http://www.json.org/json-ru.html</tt>
	<disclaim>JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Он включает в себя следующие структуры:

	  <ul>
	    <li/><em>Объект</em> -- неупорядоченный набор пар ключ/значение. Объект начинается с открывающей фигурной скобки и заканчивается закрывающей фигурной скобкой. Каждое имя сопровождается двоеточием, пары ключ/значение разделяются запятой.

	    <pre><tt>{'name':'Jane','age':22}</tt></pre>
      
	    <li/><em>Массив</em> -- упорядоченная коллекция значений. Массив начинается с открывающей квадратной скобки и заканчивается закрывающей квадратной скобкой. Значения разделены запятой.

	    <pre><tt>[23,45,6,23]
['cat','dog']</tt></pre>
      
	    <li/><em>Значение</em> может быть строкой в кавычках, числом, <tt>true</tt>, <tt>false</tt>, объектом или массивом. Эти структуры могут быть вложенными.

	    <li/> Пробелы могут использоваться между любыми лексемами.
	  </ul>
	</disclaim>
      </p>

<p>Приведём пример выражения JSON (мы пользуемся стандартом JSON5, допускающим одинарные кавычки):</p>

<pre><tt>{
    'workers' :
    [
	{
	    'name' : 'James Mitchell',
	    'age'  : 32,
	    'hobby': ['golf', 'eating pizza']
	},
	{
	    'name' : 'Mary Kay',
	    'age'  : 25,
	    'hobby': ['cats','BMW','James Mitchell']
	},
	{
	    'name': 'Garry Potter',
	    'age' : 14
	}    
    ]
}</tt></pre>

      <p>Чтение JSON означает интерпретацию строки и создание соответствующей структуры данных. Приведённый выше пример в программе на языке Хаскелл, должен быть прочтён как-то так:</p>

      <pre><hs>Workers
  [ Person "James Mitchell" 32 ["golf", "eating pizza" ]
  , Person "Mary Kay" 25 ["cats", "BMW", "James Mitchell"]
  , Person "Garry Potter" 14 [] ]</hs></pre>

      Мы легко создадим трансляторы, соответствующие объекту и массиву:

      <pre><hs>object p = term '{' *> p <* term '}'
arrayOf p = term '[' *> (p `sepBy` term ',' <|> pure []) <* term ']'</hs></pre>

      А для пары напишем специальный комбинатор:

<pre><hs>infix 5 .:
key .: p  = string (show key) *> term ':' *> p <* opt (term ',')</hs></pre>

Осталось определить трансляторы для строк и чисел:

<pre><hs>string_ = term '\'' *> many (term `except` "'") <* term '\''
number_ = integer</hs></pre>

 <p> Вот, собственно, и всё! Остальную работу для нас выполнят операторы <code><$></code> и <code><*></code>:</p>

 <pre><hs>data Person = Person String Integer [String]
       deriving Show

person = object $
  Person <$> "name"  .: string_
         <*> "age"   .: integer_
         <*> "hobby" .: arrayOf string_</hs></pre>

Проверяем на примере без пробелов:

 <pre><ghci><l></l> run person "{'name':'James','age':15,'hobby':['golf','pizza']}"
<o>Ok (Person "James Mitchell" 15 ["golf","eating pizza"]) ""</o></ghci></pre>

 <task>Напишите функцию <code>cleanJSON</code>, которая убирала бы лишние пробелы из JSON (оставляя их в строках).
 <pre><ghci><l></l> cleanJSON "{ 'name': 'James Mitchell', 'age': 15, 'hobby': ['golf', 'eating pizza']}"
<o>"{'name':'James Mitchell','age':15,'hobby':['golf','eating pizza']}"</o></hs></pre></task>

 <task> Так в Хаскеле можно прочитать текст в виде строки из файла с указанным именем, а потом обработав, вывести результат:
					       
 <pre><hs>import System.IO  
  
main = do text <- readFile "test.json"
          print $ readJSON workers text</hs></pre>

 <p> Напишите функцию <code>readJSON</code>, принимающую транслятор и строку, а возвращающую результат разбора. </p>

 <pre><hs>readJSON :: Parser String a -> String -> Maybe a</hs></pre>
 
<p>Определите транслятор JSON выражения, для объекта <tt>"workers"</tt> (как в примере выше).
 </task>

<task>Добавьте каждому объекту <code>Person</code> поле <tt>"best friend"</tt>, содержащее информацию о лучшем друге в виде структуры <code>Person</code>. Причём, друга может и не быть.</task>


<h2>Транслятор регулярных выражений</h2>

<p>Рассмотрим достаточно серьёзную задачу разбора и трансляции регулярных выражений.</p>

 <p>Транслятор регулярных выражений должен превращать строку в транслятор, соответствующий регулярному выражению. Например, из строки <code>"a.b+"</code> он должен сделать транслятор,

  <pre><hs> only (term 'a') <> only next <> msome (term 'b')</hs></pre>

<p>То есть, это трансляция строки в транслятор. Такой процесс называется суперкомпилированием.</p>

 <p>Мы не будем здесь реализовывать полный набор функции, реализованных в стандартах POSIX или Perl, остановимся на основных элементах и их комбинаторах:</p>
					
 <p>Регулярное выражение может быть:</p>
   <ul>
     <li/> <em>символом-литералом</em>, которые представляют сами себя;
     <li/> метасимволом <code>.</code> (точка), представляющим <em>любой символ</em>;
     <li/> <em>символьным классом</em>  -- набором символов в квадратных скобках <code>[&nbsp;]</code>, представляющим множество возможных символов (<code>[cat]</code> означает <code>c</code> или <code>a</code> или <code>t</code>); если требуется указать символы, которые не входят в указанный набор, то используют символ <code>^</code> внутри квадратных скобок (<code>[^cat]</code> -- любой символ, кроме <code>c</code>, <code>a</code> или <code>t</code>); возможно указание диапазонов символов с помощью тире, например <code>[0-9]</code> -- означает любой цифровой символ;
     <li/> <em>группой</em> -- регулярным выражением, окружённым круглыми скобками;
     <li/> <em>последовательностью</em> регулярных выражений;
     <li/> <em>объединением</em> (перечислением) регулярных выражений;
     <li/> регулярным выражением с модификаторами повторения.
   </ul>

 <p>Приведём формальное описание грамматики регулярных выражений, трансляцию которых мы реализуем:</p>


<pre><nt>R</nt> = a     <ht>символ-литерал</ht>
    .     <ht>любой символ</ht>
    [<nt>C</nt>]   <ht>символьный класс</ht>
    (<nt>R</nt>)   <ht>группа</ht>
    <nt>R</nt>|<nt>R</nt>   <ht>объединение</ht>
    <nt>R</nt><nt>R</nt>    <ht>конкатенация (последовательность)</ht>
    <nt>R</nt><nt>M</nt>    <ht>модификация</ht>

символьный класс
<nt>С</nt> = a     <ht>символ-литерал</ht>
    a-b   <ht>диапазон символов</ht>
    ^<nt>C</nt>    <ht>отрицание класса</ht>

модификаторы повторения 
<nt>M</nt> = *     <ht>повторение элемента ноль или много раз</ht>
    +     <ht>повторение элемента один или много раз</ht>
    ?     <ht>повторение элемента ноль или один раз</ht></pre> 
</p>

 <p>Подобно арифметическим выражениям, регулярные выражения "собираются" с помощью трёх операций -- объединения, конкатенации и модификации, причём приоритет объединения ниже чем у конкатенации, а у конкатенации -- ниже чем у модификаторов. Объединение можно определить функциональной свёрткой <code>foldP</code>, а конкатенацию осуществить функцией <code>msome</code>:</p>

<pre><hs>_R = foldP (msome element) alt
   where alt = (<|>) <$ term '|'
         element = (group <|> (only <$> symbol)) <**> modifier
         group = between '(' ')' _R
         symbol = anychar <|> charClass <|> literal </hs></pre>

<p>Теперь определим элементы их интерпретацию. (Сейчас будет немного сюрреализма, но смысл в этом всё же есть.) Все элементы после распознавания транслируются в трансляторы, которые, в свою очередь свои результаты комбинируют в строку.</p>

 <p>Символ-литерал интерпретируется, как транслятор <code>term</code>.</p>
<pre><hs>literal = term <$> term `except` "?+*()[]|."</hs></pre>

 <p>Метасимвол <code>.</code> (точка) транслируется в транслятор <code>next</code></p>
<pre><hs>anychar = next <$ term '.'</hs></pre>

 <p>Определение для символьных классов выглядит более сложным, но устроено достаточно прямолинейно:</p>

 <pre><hs>charClass = between '[' ']' c
   where c = oneof term <$> chars
         <|> except term <$> (term '^' *> chars)

         chars = msome (range <|> only char)
         char = term `except` "]"
         range = enumFromTo <$> char <*> (term '-' *> char)</hs></pre>

 <p>Модификаторы сделаем функциями, наподобие арифметических операций:</p>				

 <pre><hs>modifier = option <|> repeat0 <|> repeat1 <|> pure id
   where option = mopt <$ term '?'
         repeat1 = msome <$ term '+'
         repeat0 = mmany <$ term '*'</hs></pre>

 <p>Наконец, сам транслятор регулярных выражений превратим в полноценный транслятор:</p>
						
<pre><hs>regexp s = case run _R s of
  Ok "" p -> p
  _ -> empty</hs></pre>


 <p>Вот как можно им пользоваться:</p>

 <pre><ghci>λ> run (search (regexp "c.(t|p)")) "the cat has a cup"
Ok "" ["cat","cup"] </ghci></pre>

					
<p>Вот более полезный пример. Пусть нам нужно из извлечь параметры из URL:</p>
<pre>www.site.org?day=7&name=adam&fruit=apple</pre>
Мы можем сделать это с помощью регулярного выражения так:

 <pre><hs>params = search (regex "[a-z]+=[^&]+")</hs></pre>

 <pre><ghci>λ> run params "www.site.org?day=7&name=adam&fruit=apple"
Ok "" ["day=7","name=adam","fruit=apple"]</ghci></pre>
 
 А так -- транслировать в словарь:
 
 <pre><hs>params = search ((,) <$> regex "[a-z]+" <*> (term '=' *> regex "[^&]+"))</hs></pre>

 <pre><ghci>λ> run params "www.site.org?day=7&name=adam&fruit=apple"
Ok "" [("day","7"),("name","adam"),("fruit","apple")]</ghci></pre>
 
 <task>Проверьте правильность работы транслятора регулярных выражений на нескольких примерах:
<ul>
  <li> число с плавающей точкой
  <li> простой e-mail адрес
  <li> дата в формате DD.MM.YYYY
  <li> слова типа "тум-там-тум", "там-там-там-тарарам", "трам-тарарам-там-там" и т.д.
</ul>
		       </task>


      <!-- ------------------------------------------------------------ -->
    </div>
    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

