<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Вычисления арифметических выражений в ОПН</h2>

      
      <p>Обратной польской нотацией (ОПН) называется способ записи арифметических и логических выражений, который совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН -- плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr><hr/>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек. Алгоритм вычисления для стековой машины:<ul>
	  <li>Обработка входного символа
	  <li>Если на вход подан операнд, он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	  <li>Если входной набор символов обработан не полностью, перейти к шагу 1.
	</ul>
	После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.</p>

      <p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

      <p>Начнём с описания интерпретации отдельных команд:</p>

      <pre>
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s</pre>

<p>Как видно, мы оперируем стеком, содержащим числа и строковыми командами, которые управляют состоянием стека. Определим для них типы:</p>

<pre><hs>type Command = String
type Stack = [Double]
</hs></pre>

<p>Таблицу команд легко описать как определение функции <code>interprete</code>:</p>

<pre><hs><def>interprete :: Command -&gt; Stack -&gt; Stack</def>
interprete (x:y:s) "+" = (x+y):s
interprete (x:y:s) "*" = (x*y):s
interprete (x:y:s) "-" = (y-x):s
interprete (x:y:s) "/" = (y/x):s
interprete s n = (read n):s
</hs></pre>

<p>С её помощью выражение <code>"2 3 +"</code> можно вычислить так:</p>

<pre>interprete (interprete (interprete [] "2") "3") "+"</pre>

<p>Это же левая свёртка! Замечательно. Значит, наш калькулятор можно описать так:</p>

<pre><hs><def>calculate :: String -&gt; Double</def>
calculate = head . foldl interprete [] . words</hs></pre>

<p>Функция <code>words</code> разделяет строку на лексемы (числа и операторы), а свёртка осуществляет вычисления. </p>

<task>Убедитесь в том, что калькулятор правильно производит вычисления для корректных выражений.</task>

<p>Однако выражения могут быть и не корректными.</p>

<pre><ghci>&gt; calculate "2 3 * +"
*** Exception: Prelude.read: no parse
&gt; calculate "2 x *"
*** Exception: Prelude.read: no parse
&gt; calculate ""
*** Exception: Prelude.head: empty list
</ghci></pre>

<p>В первом случае для операции <code>"+"</code> не хватило аргументов, правда из сообщения об ошибке это совершенно не следует! Это очень нехорошо. Ошибки "лезут" изнутри программы и совершенно неинформативны. Немного усовершенствуем нашу функцию, заодно облегчив её синтаксис:</p>

<pre><hs><def>interprete :: Command -&gt; Stack -&gt; Stack</def>
interprete s op = case op of
  "+" -&gt; binop (+)
  "*" -&gt; binop (*)
  "-" -&gt; binop (-)
  "/" -&gt; binop (/)
  n   -&gt; case readMay n of
           Just x -&gt; x : s
           Nothing -&gt; error ("unknown command " ++ n)
  where
    binop f = case s of
      x:y:s -&gt; f x y : s
      [_]   -&gt; error "got only one argument"
      []    -&gt; error "got no arguments"
</hs></pre>

<p>Здесь для контроля работы функции <code>read</code> мы воспользовались тотальной функцией <code>readMay</code> из библиотеки <code>Safe</code>, она идёт по правильному пути -- возвращает частично-определённое значение.</p>

<p>Ну, и функцию <code>calculate</code> надо немного подправить, чтобы ошибка соответствовала исключительной ситуации.</p>

<pre><hs><def>calculate :: String -&gt; Double</def>
calculate = head' . foldl interprete [] . words
  where head' [] = error "stack is empty"
        head' (x:_) = x
</hs></pre>

<p>Теперь хотя бы сообщения об ошибках будут осмысленными, </p>

<pre><ghci>&gt; calculate "2 3 * +"
*** Exception: got only one argument
&gt; calculate "2 x *"
*** Exception: unknown command x
&gt; calculate ""
*** Exception: stack is empty
</ghci></pre>

<task>Функция <code>calculate</code> работает ожидаемо, но она осталась нетотальной. Это значит, что она может привести в остановке исполнения программы. Дополните определение функции <code>interpreteM</code>:

<pre><hs><def>interpreteM :: Failable f =&gt; Stack -&gt; Command -&gt; f Stack</def>
interpreteM s op = case op of
  "+" -&gt; binop (+)
  "*" -&gt; binop (*)
  "-" -&gt; binop (-)
  "/" -&gt; binop (/)
  n   -&gt; (: s) <$> readF n
  where
    readF s = _

    binop f = _
</hs></pre>
</task>

<p>Увы, для функции <code>interpreteM</code> не работает свёртка! Цепочка</p>

<pre>interprete (interprete (interprete [] "2") "3") "+"</pre>

<p>больше не выполняется. Зато её можно посчитать так:</p>

<pre>pure [] &gt;&gt;= (`interprete` "2") &gt;&gt;= (`interprete` "3") &gt;&gt;= (`interprete` "+")</pre>

<p>такую цепочку выполняет монадическая свёртка <code>foldM</code>:</p>

<pre><hs>foldM f x = foldl (\res el -&gt; res &gt;&gt;= (`f` el)) (pure x)</hs></pre>

<p>Теперь можно переопределять функцию <code>calculate</code>, уточнив, что она работает с монадами, являющимися и альтернативными функторами:</p>

<pre><hs><def>calculate :: (Failable f, Monad f) =&gt; String -&gt; f Stack</def>
calculate = foldM interpreteM [] . words</hs></pre>

<task></task>

<task>Добавьте в калькулятор возможность вычислять квадратные корни.</task>


    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

