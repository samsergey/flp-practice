<!DOCTYPE html>
<html lang="ru">
  <title></title>
  <head>
    <meta charset = "UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../css/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">    

    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>
    <p id="header"></p>

    <div class='tasks'>

      <h2>Обратная польская нотация</h2>

     
      <p>Обратной польской нотацией (ОПН) называется способ записи арифметических и логических выражений, который совмещает в себе простоту интерпретации с компактностью записи. Единственный недостаток ОПН -- плохая читаемость выражений человеком. Однако, так как эта форма используется, чаще всего, как внутреннее представление вычислений на одном из промежуточных этапов трансляции программ, человеку писать и читать ОПН не приходится.</p>

      <p>Отличительной особенностью ОПН является то, что все аргументы расположены перед знаком операции. В общем виде запись состоит из линейной последовательности операндов и знаков операций:
	<table>
	  <tr><td>выражение</td><td>запись в ОПН</td></tr><hr/>
	  <tr><td><eq>1+2</eq></td><td><code>1 2 +</code></td></tr>
	  <tr><td><eq>1+2\times 3</eq></td><td><code>1 2 3 * +</code></td></tr>
	  <tr><td><eq>(1+2)\times 3</eq></td><td><code>1 2 + 3 *</code></td></tr>
	  <tr><td><eq>(1+2)\times (3 - 4)</eq></td><td><code>1 2 + 3 4 - *</code></td></tr>
	</table>
      </p>

      <p>Вычисление выражений в обратной польской нотации использует стек. Приведём алгоритм вычисления для стековой машины:<ul>
	  <li>Обработка входного символа
	  <li>Если на вход подан операнд, он помещается на вершину стека.
	  <li>Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
	  <li>Если входной набор символов обработан не полностью, перейти к шагу 1.
	</ul>
	После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.</p>

      <h2>Простейшая реализация вычислителя ОПН</h2>
      
      <p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

      <p>Начнём с описания интерпретации отдельных команд:</p>

      <pre>
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s</pre>

<p>Как видно, мы оперируем стеком, содержащим числа и строковыми командами, которые управляют состоянием стека. Определим для них типы:</p>

<pre><hs>type Command = String
type Stack = [Double]
</hs></pre>

<p>Таблицу команд легко описать как определение функции <code>interprete</code>:</p>

<pre><hs><def>interprete :: Stack -> Command -> Stack</def>
interprete (x:y:s) "+" = (x+y):s
interprete (x:y:s) "*" = (x*y):s
interprete (x:y:s) "-" = (y-x):s
interprete (x:y:s) "/" = (y/x):s
interprete s n = (read n):s
</hs></pre>

<p>С её помощью выражение <code>"2 3 +"</code> можно вычислить так:</p>

<pre>interprete (interprete (interprete [] "2") "3") "+"</pre>

<p>Это же левая свёртка! Замечательно. Значит, наш калькулятор можно описать в виде свёртки:</p>

<pre><hs><def>calculate :: String -> Stack</def>
calculate = foldl interprete [] . words</hs></pre>

<p>Функция <code>words</code> разделяет строку на лексемы (числа и операторы), а свёртка осуществляет вычисления. </p>

<task>Убедитесь в том, что калькулятор правильно производит вычисления для корректных выражений.</task>

<h2>Обработка некорректных ситуаций</h2>

<p>Однако выражения могут быть и не корректными.</p>

<pre><ghci>&gt; calculate "2 3 * +"
*** Exception: Prelude.read: no parse
&gt; calculate "2 x *"
*** Exception: Prelude.read: no parse
</ghci></pre>

<p>В первом случае для операции <code>"+"</code> не хватило аргументов, правда из сообщения об ошибке это совершенно не следует! Это очень нехорошо. Ошибки "лезут" изнутри программы и совершенно неинформативны. Немного усовершенствуем нашу функцию, заодно облегчив её синтаксис:</p>

<pre><hs><def>interprete :: Stack -> Command -> Either String Stack</def>
interprete s op = case op of
  "+" -> binop (+)
  "*" -> binop (*)
  "-" -> binop (-)
  "/" -> binop (/)
  n   -> case readMay n of
           Just x  -> Right (x : s)
           Nothing -> Left ("unknown command " ++ n)
  where
    binop f = case s of
      x:y:s -> Right $ f x y : s
      [_]   -> Left "got only one argument"
      []    -> Left "got no arguments"
</hs></pre>

<p>Здесь для контроля работы функции <code>read</code> мы воспользовались тотальной функцией <code>readMay</code> из библиотеки <code>Safe</code>, она идёт по правильному пути -- возвращает частично-определённое значение.</p>

<p>Увы, для нового варианта функции <code>interprete</code> не работает свёртка! Цепочка</p>

<pre>interprete (interprete (interprete [] "2") "3") "+"</pre>

<p>больше не выполняется. Зато её можно посчитать так:</p>

<pre>pure [] &gt;&gt;= (`interprete` "2") &gt;&gt;= (`interprete` "3") &gt;&gt;= (`interprete` "+")</pre>

<p>такую цепочку выполняет монадическая свёртка <code>foldM</code>:</p>

<pre><hs>foldM f x = foldl (\res el -> res &gt;&gt;= (`f` el)) (pure x)</hs></pre>

<p>Теперь можно переопределять функцию <code>calculate</code>:</p>

<pre><hs><def>calculate :: String -> Either String Stack</def>
calculate = foldM interpreteM [] . words</hs></pre>

<task>Добавьте в калькулятор операцию "унарный минус" и возможность вычислять квадратные корни от положительного аргумента.</task>

<task>Добавьте в калькулятор операции управляющие стеком: <code>dup</code> и <code>swap</code>.</task>

    </div>

    <p id="footer"></p>
    <script src="../lib/postprocessing.js"></script>
  </body>
</html>

