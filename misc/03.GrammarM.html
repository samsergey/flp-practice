<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta set="UTF-8"/>
    <link rel="stylesheet" href="../css/TPLBook.css">
    <link rel="stylesheet" href="../lib/styles/obsidian.css">
    <link rel="stylesheet" href="../lib/katex/katex.min.css">
    
    <script src="../lib/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="../lib/katex/katex.min.js"></script>
  </head>
  <body>

    <h1>Грамматический анализ</h1>

    <div class='tasks'>

      <!-- <p>Трансляция -- это чтение, интерпретация или перевод текста. При этом текст это не просто последовательность символов или знаков, он имеет внутреннюю структуру, которую мы назовём грамматикой. Таким образом, трансляция, это чтение и интерпретация текстов, подчинённых какой-то грамматике.</p> -->

      <!-- <p>Например, транслятор арифметических выражений может переводить их в последовательность инструкций для компьютера, или на какой-либо язык программирования; транслятор языка C# читая текст, являющийся программой, генерирует другую программу -- на языке CIL, и т.д.</p> -->

      
      <h3> Определение для транслятора</h3>
      
      <p>Транслятор&nbsp;— это функция, которая преобразует входную последовательность символов (строку, или поток лексем) в некий результат. Результатом может быть логическое значение, если нас интересует только соответствие текста заданной грамматике, последовательность выходных значений, синтаксическое дерево, или даже число. То есть, тип транслятора, в самом общем случае, может быть каким-то таким:</p>

      <pre><hs>data Parser i a = Parser (i -> a)</hs></pre>
      
      <p>где <tt>i</tt>  тип входного потока, а <tt>a</tt>&nbsp;— тип результата. Например, лексический анализатор, читающий программу в виде строки, и возвращающий список лексем может иметь тип <tt>Parser String [Token]</tt>.</p>
      
      <p>Для того, чтобы нам было легче применять спрятанную в тип <tt>Parser</tt> функцию-преобразователь, дадим ей имя:</p>

      <pre><hs>data Parser i a = Parser { run :: i -> a }</hs></pre>

      
      <p>Определим какой-нибудь самый простой транслятор. Очень простой. </p>

      <pre><hs>next = Parser $ \(x:_) -> x</hs></pre>

     
      <p>  Он работает со списками (или строками) и просто возвращает первый элемент разбираемой последовательности, каким бы он ни был:</p>

      <pre><ghci>λ> run next "abab"
'a'
λ> run next "bab"
'b'</ghci></pre>

      <p> Транслятор работает, но он практически бесполезен, ведь мы потеряли информацию о разбираемой строке и не сможем продолжить разбор. Это приводит к мысли, что возвращаемый результат должен каким-то образом содержать в себе разбираемую строку. Объединим их в типе <tt>Result</tt>, на который можно посмотреть и сравнить с чем-нибудь:</p>

      <pre><hs>data Parser i a = Parser { run :: i -> Result i a}

data Result i a = Result i a
  deriving (Show, Eq)
	  
next = Parser $ \(x:xs) -> Result xs x</hs></pre>

      <pre><ghci>λ> run next "abab"
Result "bab" 'a'</ghci></pre>

      <p> Теперь работа транслятора стала более осмысленной, он вернул первый элемент и сократил разбираемую строку.</p>
    
      <p>А что дальше? Как нам снова применить функцию <tt>next</tt> к полученному результату?</p>

      <h3>Последовательное выполнение трансляторов</h3>
      
      <p>Определим комбинатор <tt>>></tt>, "соединяющий" трансляторы в цепочку: </p>

      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Result r' _ -> run t2 r'  </hs></pre>

      <p>Форма <tt>case</tt> потребовалась нам для того, чтобы "разобрать" результат работы транслятора <tt>t1</tt> и добыть остаток строки. Можно было воспользоваться формой <tt>let</tt> или <tt>where</tt>, но, во-первых, она читается более естественно: от <tt>t1</tt> к <tt>t2</tt>, а во-вторых, скоро мы добавим другие альтернативы.</p>
    
      <p>  Комбинатор <tt>>></tt> возвращает новый транслятор, так что его тоже можно применить к разбираемой строке с помощью функции <tt>run</tt>. Попробуем его использовать и... получим сообщение об ошибке!</p>

      <pre><ghci>λ> run (next >> next) "abab"

Ambiguous occurrence ‘>>’
It could refer to either ‘Main.>>’,
                         defined at parserM.hs:7:4
                      or ‘Prelude.>>’,
                         imported from ‘Prelude’ at parserM.hs:1:1
                         (and originally defined in ‘GHC.Base’)</ghci></pre>

      <details><summary>Учите английский!!</summary>
	<pre><ghci>Неоднозначное использование ‘>>’
Оно может относиться как к ‘Main.>>’,
                         определённому в parserM.hs:7:4
                     так и к ‘Prelude.>>’,
                         импортированному из ‘Prelude’ в parserM.hs:1:1
                         (изначально определённому в ‘GHC.Base’)</ghci></pre>
      </details>
      
      <p>Ой! Кажется, кто-то занял это имя. Оказывается, мы неявно импортировали его вместе с модулем <tt>Prelude</tt>, который входит в библиотеку <tt>GHC.Base</tt>. Что же, не беда! Haskell&nbsp;— язык для выбирающих свободу и тех, кто знает, что с нею делать. Не будем импортировать этот символ и, всё-таки, будем настаивать на своём определении. Для этого добавим в самом начале программы строчку</p>

      <pre><hs>import Prelude hiding ((>>))</hs></pre>

      <p>Теперь всё в порядке:</p>

      <pre><ghci>λ> run (next >> next) "abab"
Ok "ab" 'b'
λ> run (next >> next >> next) "abab"
Ok "b" 'a'</ghci></pre>
      
      <p>Переходя ко второму транслятору и далее мы потеряли информацию о первом встреченном символе, но пока она и не нужна: транслятор <tt>next</tt> её всё равно не использует. И мы тоже пока об этом думать не будем.</p>

      <h3>Право на ошибку</h3>

      <p> Пора научится задавать для разбираемой последовательности какие-либо правила. Например, можно потребовать, чтобы первым символом был символ <tt>'a'</tt>, и если это так, продолжить разбор. А если не так? В этом случае надо прекратить разбор выражения и как-то показать, что трансляция завершилась неудачно.</p>
    
      <p> Расширим тип для результата трансляции, разделив его на успешную трансляцию и неудачную:</p>

      <pre><hs>data Result i a = Ok i a
                | Fail i
  deriving (Show, Eq)</hs></pre>

      <p> В случае неудачи, тип содержит неразобранную часть строки. На всякий случай.</p>
 
      <p>Раз мы изменили описание типа <tt>Result</tt>, нужно поменять и определение комбинатора <tt>>></tt>, чтобы он учитывал возможные исходы разбора и в случае неудачи, постигшей первый транслятор, не пытался вызывать следующий:</p>
      
      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Ok r' _ -> run t2 r'
  Fail r' -> Fail r'</hs></pre>

      <p> Кроме того, транслятор <tt>next</tt> может стать несколько "умнее"&nbsp;— если строка пуста, никакого следующего символа в ней нет, а это означает неудачу в разборе:</p>

      <pre><hs>next = Parser $ \r -> case r of
  [] -> Fail r
  x:xs -> Ok xs x</hs></pre>
          
      <p>Напишем теперь транслятор, который будет требовать, чтобы анализируемая строка начиналась с конкретного символа. Опять же, сначала для этого нужно удоствериться в том, что разбираемая строка не пуста:</p>

      <pre><hs>term c = Parser $ \r -> case r of
  [] -> Fail r
  x:xs -> if x == c
          then Ok xs x
          else Fail r </hs></pre>

      <p>Посмотрим, как он работает:</p>

      <pre><ghci>λ> run (term 'a') "abab"
Ok "bab" 'a'
λ> run (term 'b') "abab"
Fail "abab"
λ> run (term 'a' >> term 'b') "abab"
Ok "ab" 'b'
λ> run (term 'b' >> term 'b') "abab"
Fail "abab"
λ> run (term 'a' >> next >> term 'a') "abab"
Ok "b" 'a'
</ghci></pre>

      <p> Очень хорошо! Но сразу же хочется сделать ещё лучше. А когда делаешь лучше главное&nbsp;— не сделать хуже. В этом нам поможет тестирование.</p>
    
      <p>Напишем функцию-тестировщик.</p>

      <pre><hs>test (p, inp, outp) =
  if res' /= outp
  then concat ["Fail."
              , "\n input:    " ++ show inp
              , "\n expected: " ++ show outp
              , "\n got:      " ++ show res'
              , "\n"]
  else ""
  where res' = run p inp</hs></pre>

      <p>Здесь нам понадобилась функция <tt>concat</tt>, "склеивающая" список строк (или любых других списков).  Применять тестировщик можно к списку трансляторов, входных и ожидаемых выходных значений таким образом:</p>
    
    <pre><hs>runTests lst = putStr $ concat $ map test lst
	
tests = runTests	
  [ (term 'a',             "abab", Ok "bab" 'a')
   ,(term 'a',             "bbab", Fail "bbab")
   ,(term 'a' >> term 'b', "abab", Ok "ab" 'b')
   ,(term 'b' >> term 'b', "abab", Fail "abab") ]</hs></pre>

      <p> Запускаем тесты...</p>
      <pre><ghci>λ> tests</ghci></pre>
      <p> и видим, что ничего не выводится. Значит, у нас всё хорошо. Испортите какой-нибудь из тестов и посмотрите, что будет.</p>

      <p>Теперь можно смело двигаться дальше!</p>


      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok i a | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: i -> Result i a }</p></basic>

<part>комбинаторы</part>
<p><basic>>></basic></p>

<part>трансляторы для коллекций</part>
<p><basic>next  term</basic></p>
</sinopsys>
      </details>
      
    <h3>Повышение модульности</h3>

      <p> Один из принципов Unix (и Haskell, кстати, тоже) гласит: <disclaim>"Одна функция должна делать только одно дело,<br/> но делать его хорошо."</disclaim> Наши трансляторы <tt>next</tt> и <tt>term</tt> работают хорошо, но делают по два дела каждая: проверяют не пуста ли строка и, собственно, выполняют свои задачи. Не поручить ли проверку на пустоту специальному транслятору? Назовём его, например, <tt>notEnd</tt>:</p>

      <pre><hs>notEnd = Parser $ \r -> case r of
  [] -> Fail r
  _ -> Ok r ()</hs></pre>

      <p>Здесь мы в качестве результата разбора, в случае не пустой строки, возвращаем пустое значение. То есть, всё получилось, но возвращать нам нечего. Такие трансляторы, которые не возвращают какого-либо значения, а только проверяют строку на соответствие будем называть <our>анализаторами</em>.</p>

      <p>Теперь мы можем переопределить наши трансляторы <tt>next</tt> и <tt>term</tt> попроще:    </p>

      <pre><hs>next = notEnd >> (Parser $ \(x:xs) -> Ok xs x)
    
term c = notEnd >> Parser $ \(x:xs) -> if x == c
                                       then Ok xs x
                                       else Fail (x:xs)</hs></pre>

      <p>Запускаем тесты...
	<pre><ghci>λ> tests</ghci></pre>
	мы ничего не поломали!</p>
    

      <hr/><task> Нет предела совершенству, но стремление к нему похвально.

	<p> Функция <tt>term</tt> длинная, и всё ещё делает два дела: задаёт вопрос первому символу и сокращает строку. Было бы лучше определить его как-нибудь по-понятнее. Скажем, так:</p>

	<pre><hs>term c = check (== c) >> next</hs></pre>	
      
	<p>Напишите анализатор <tt>check</tt>, который продолжает разбор в случае, если выполняется некоторое условие на первый символ. Разбираемую строку он при этом не сокращает.</p>    
      </task>

      <hr/><task> С помощью анализатора <tt>check</tt> определите транслятор <tt>digit</tt>, ожидающий вначале строки цифру. Для него должны выполняться, например, такие тесты:
	<pre><hs>(digit, "23x", Ok "3x" '2')
(digit, "abc", Fail "abc")
(digit >> digit, "23x", Ok "x" '3')</hs></pre>
      </task>

      <hr/><task>Продолжим заманчивый путь абстракции. Напишите анализатор <tt>end</tt>, ожидающий окончания строки. А чтобы не было скучно, добавьте универсальный комбинатор <tt>neg</tt>, который возвращал бы отрицание указанного транслятора <tt>p</tt>: "что угодно, только не <tt>p</tt>". Так, например, с его помощью можно будет определить транслятор <tt>notEnd</tt>:
      <pre><hs>notEnd = neg end</hs></pre>

	<p> Тут нам и должно пригодиться то, что неудачный результат хранит в себе неразобранную строку. На всякий случай.</p>

	<p> Добавим в список тестов такие проверки:</p>

	<pre><hs>runTests 
  [ (neg end, "abc", Ok "abc" ())
  , (term 'a' >> end, "a", Ok "" ())
  , (neg digit, "abc", Ok "abc" ())
  , (neg digit, "2bc", Fail "2bc") ]</hs></pre>

	<p> Для этого надо сделать так, что бы функция <tt>tests</tt> выполнила первый блок проверок, а затем&nbsp;— второй. Это делается с помощью специальной формы <tt>do</tt></p>

      <pre><hs>tests = do runTests 
             [ ... ]
           runTests 
             [ ... ]</hs></pre>

	<p>Об этой форме мы ещё обязательно поговорим, но позже</p>
	
      </task><hr>

      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok i a | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: i -> Result i a }</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic></p>

<part>комбинаторы</part>
<p><basic>>></basic></p>

<part>трансляторы для коллекций</part>
<p><basic>end  next</basic>  term</p>

<part>трансляторы для строк</part>
<p>digit</p>
</sinopsys>
      </details>
      
      <h3>Альтернативное выполнение трансляторов</h3>

      <p> В формальных грамматиках есть цепочки элементов грамматики и альтернативы. Цепочки мы строить умеем с помощью комбинатора <code>>></code>. Приступим к альтернативам. Если входная строчка не соответствует одному транслятору, то может быть она подойдёт другому?</p>

      <pre><hs>t1 <|> t2 = Parser $ \r -> case run t1 r of
  Fail _ -> run t2 r
  Ok r' x -> Ok r' x</hs></pre>

      <p> Теперь у нас появился выбор!!</p>
      <pre><ghci>λ> run (term 'a' <|> term 'b') "abab"
Ok "bab" 'a'
λ> run (term 'a' <|> term 'b') "bbab"
Ok "bab" 'b'  </ghci></pre>

      <p> Наличие свободного выбора и умение им пользоваться&nbsp;— это поистине великая вещь! Теперь мы можем определить транслятор для любой контекстно-свободной грамматики, ведь они описываются правилами такого рода:</p>
    <eqn>
A \rightarrow \alpha ~|~ \beta ~|~ \gamma ~|~ ...
    </eqn>
      <p>где <eq>\alpha, \beta, \gamma...</eq>&nbsp;— цепочки элементов грамматики: терминалов и нетерминалов. Цепочки мы создавать умеем и альтернативы определять можем, а сами правила соответствуют определениям функций. То есть, определяя функцию, мы определяем нетерминальный символ, и задание анализатора для КС-грамматики&nbsp;— это последовательность определений функций-нетерминалов через комбинации цепочек и альтернатив.</p>

    <p> Сделаем маленькое дополнение. В стандартной математической записи приоритет у операции последовательности в цепочке выше, чем у оператора альтернативы. В языке Haskell тоже можно определять приоритет инфиксных операторов. Сделаем приоритет операции <code>>></code> выше чем у операции <code><|></code>.</p>
    <pre><hs>infixl 0 <|>
infixl 1 >></hs></pre>

      <p>Заодно, мы объявили, что эти операции левоассоциативны. Это значит, что <pre><code>  a >> b >> c = (a >> b) >> c
a <|> b <|> c = (a <|> b) <|> c</code></pre></p>

      <p>Построенная нами система трансляции называется <em>"трансляцией методом рекурсивного спуска"</em>. Она начинает разбор с самого общего нетерминала и далее, вызывая функции-нетерминалы, которые используются в правых частях определений, спускается вниз по синтаксическому дереву.</p>

      <p> У этого метода есть серьёзное ограничение на допустимые грамматики&nbsp;— они не должны быть <em>лево-рекурсивными</em>.</p>

      <details>

	<p>Лево-рекурсивной называется грамматика, которая содержит правила вида:</p>

	<eqns>A \rightarrow A \alpha ~|~ \alpha'</eqns>

	<p> Метод рекурсивного спуска, встретив левую рекурсию, "проваливается" в бесконечный цикл. Это существенное ограничение, но любое лево-рекурсивное правило можно преобразовать в эквивалентное не лево-рекурсивное:</p>

	<eqns>A \rightarrow \alpha' A'\\
	  A' \rightarrow  \alpha A' ~|~ \varepsilon
	</eqns>

<p>Например, грамматика для левоассоциативного вычитания лево-рекурсивна (что естественно):
	<eqns>E \rightarrow E - T | T</eqns>
	но её можно преобразовать, исключив левую рекурсию:
	<eqns>E \rightarrow T E'\\
	  E' \rightarrow  - T E' ~|~ \varepsilon
	</eqns>

	<p>Это можно сделать автоматически, но обычно об этом заботится тот, кто пишет грамматику для конкретного анализатора.</p>

      </details>

      <p>Давайте же определим анализатор для какой-нибудь простой нерегулярной грамматики! Например, для такой, которая порождает цепочки вида <eq>(ab)^nba^n</eq>:</p>

    <eqns>
      A \rightarrow \text{'a'}~\text{'b'}~A~\text{'a'} ~|~ \text{'b'} 
    </eqns>
    <pre><hs>_A = term 'a' >> term 'b' >> _A >> term 'a' 
     <|> term 'b'</hs></pre>

    <pre><hs>runTestsFor p tst = runTests tst'
  where tst' = map (\(i,o) -> (p,i,o)) tst

testA = runTestsFor _A
    [ ("abba", Ok "" 'a')
    , ("ababbaa", Ok "" 'a')
    , ("abababbaaa", Ok "" 'a')
    , ("aba", Fail "aba")
    , ("ababa", Fail "ababa")] </hs></pre>

    
    <pre><ghci>λ> testA</ghci></pre>

    
    <p>Что же, похоже анализатор работает и его определение в программе замечательно соответствует описанию грамматики.</p>

    
    <p>Как насчёт более сложной грамматики для арифметических выражений с целыми числами, правоассоциативной операцией сложения и скобками?</p>

    <eqns>
      E \rightarrow T ~\text{'+'}~ E ~|~ T\\
      T  \rightarrow \text{'('}~E~\text{')'} ~|~ N\\
      N \rightarrow d ~(N ~|~ \varepsilon)
    </eqns>

    <p>    Первым делом, возникает потребность в пустом символе <eq>\varepsilon</eq>. Определим его так:</p>

    <pre><hs>epsilon = Parser $ \r -> Ok r ()</hs></pre>

    <p>Теперь можно определять грамматику:</p>

   <pre><hs>_E = _T >> term '+' >> _E <|> _T
_T = term '(' >> _E >> term ')' <|> _N
_N = digit >> (_N <|> epsilon)</hs></pre>

    <p>Выглядит неплохо. Но не компилируется!</p>

    <pre><ghci>parserM.hs:83:37-38: Couldn't match type ‘()’ with ‘Char’ …
    Expected type: Parser [Char] Char
      Actual type: Parser [Char] ()
    In the second argument of ‘(<|>)’, namely ‘_N’
    In the expression: term '(' >> _E >> term ')' <|> _N
Compilation failed.</ghci></pre>

    <details><summary>Учите английский!!</summary>
    <pre><ghci>parserM.hs:83:37-38: Не смог сопоставить тип ‘()’ с ‘Char’ …
     Ожидаемый тип: Parser [Char] Char
    Полученный тип: Parser [Char] ()
    Во втором аргументе ‘(<|>)’, а именно ‘_N’
    В выражении: term '(' >> _E >> term ')' <|> _N
Компиляция не удалась.</ghci></pre></details>
    
    <p>Компилятор даёт исчерпывающее объяснение, что именно ему не понравилось. Вот бы все компиляторы так внятно изъяснялись! То есть, транслятор <code>term</code> возвращает тип <code>Char</code>, а анализатор <code>_N</code>&nbsp;— <code>()</code>, и их нельзя комбинировать оператором <code><|></code>. Вот его тип:</p>

    <pre><ghci>λ> :t (<|>)
(<|>) :: Parser i a -> Parser i a -> Parser i a</ghci></pre>

    <p>Значит, надо привести типы комбинируемых выражений к одному. Проще всего это сделать так:</p>

   <pre><hs>_T = term '(' >> _E >> term ')' >> epsilon <|> _N</hs></pre>

    <p> Добавление пустого элемента ничего не изменяет в цепочке. А оператор <code>>></code> вернёт тип своего второго операнда. Это, конечно, неуниверсальный временный "костыль", но теперь всё компилируется и можно проверять работу анализатора:</p>
    <pre><hs>testG1 = runTestsFor _E
  [ ("12",            Ok "" ())
  , ("(1+2)+3",       Ok "" ())
  , ("1+(2+3)",       Ok "" ())
  , ("1+2+3",         Ok "" ())
  , ("((123+4))",     Ok "" ())
  , ("(13+4)+6345",   Ok "" ())
  , ("(13+4)+(6+32)", Ok "" ()) ]</hs></pre>

    <pre><ghci>λ> testsG1</ghci></pre>

    <p>Мы избавимся от такого простого, но некрасивого решения позже. А сейчас поупражняемся в написании анализаторов.</p>

    <hr/><task> Напишите анализатор <code>maybe p</code>, позволяющий выразить мысль, что элемент <code>p</code> может встретиться, а может и не встретиться.</task>
    
    <hr/><task> Напишите анализатор, распознающий правильные скобочные выражения с круглыми и квадратными скобками. </task>
    
    <hr/><task> Определите анализатор строк, представляющих простой e-mail адрес.</task><hr>

    <p>Прежде чем двигаться дальше, окинем общим взглядом, то что уже нами написано:</p>

      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok i a | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: i -> Result i a }</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic></p>

<part>комбинаторы</part>
<p><basic><|>  >></basic></p>

<part>элементарные трансляторы</part>
<p><basic>epsilon</basic></p>

<part>трансляторы для коллекций</part>
<p><basic>end  next  check</basic>  term</p>

<part>трансляторы для строк</part>
<p>digit</p>
</sinopsys>
</details>

    <h3>От анализа к трансляции</h3>

<p>Наконец, пора заняться серьёзным делом&nbsp;— трансляцией. Читаемые символы хочется как-то понимать, как-то обрабатывать. А для этого их нужно каким-то образом передавать по цепочке трансляторов.</p>

<p> Давайте рассуждать, глядя на определение комбинатора <code>>></code>. 
    
      <pre><hs>t1 >> t2 = Parser $ \r -> case run t1 r of
  Ok r' _ -> run t2 r'
  Fail r' -> Fail r'</hs></pre>

   Его тип: </p>

    <p><code>(>>) :: Parser i a -> Parser i b -> Parser i b</code></p>
      
   <p> Транслятор <code>t2</code> для своей работы не требует значения, возвращаемого транслятором <code>t1</code>. А если бы требовал, то как бы он смог его получить? Самое естественное для функционального языка решение&nbsp;— передать это значение, как аргумент функции, которая принимая и используя его, возвращает новый транслятор. Назовём эту функцию <code>f</code>. Вот каким должен быть её тип:</p>
      <p><code>f :: a -> Parser i b</code></p>
<p>Получается, нам нужен комбинатор, соединяющий в цепочку транслятор <code>Parser i a</code> и эту функцию. Назовём его <code>>>=</code>.
      <pre><hs>t1 >>= f = Parser $ \r -> case run t1 r of
  Ok r' x -> run (f x) r'
  Fail r' -> Fail r'</hs></pre>

Тип этого комбинатора:
    <p><code>(>>=) :: Parser i a -> (a -> Parser i b) -> Parser i b</code></p>

    
    <p>Признаюсь сразу, этот оператор тоже уже определён в модуле <code>Prelude</code>, поэтому добавим его в первую строчку программы:</p>

    <pre><hs>import Prelude hiding ((>>), (>>=))</hs></pre>
      
    <p>Ну, что же, попробуем? Напишем транслятор, определяющий два <em>одинаковых</em> символа подряд, причём неважно каких. Раньше это нам было сделать невозможно:</p>

<pre><hs>double = next >>= (\x -> term x)</hs></pre>
    
<pre><ghci>λ> run double "aab"
Ok "b" 'a'
λ> run double "aba"
Fail "ba" </ghci></pre>

      <p> Можно записать и короче:</p>

      <pre><hs>double = next >>= term</hs></pre>
      
<p>Осталась одна важная деталь: как можно вернуть в качестве результата разбора какую-нибудь комбинацию из предыдущих результатов?</p>

<p>Для этого определим функцию <code>return</code> (да, она тоже определена в модуле <code>Prelude</code>):</p>

  <pre><hs>return x = Parser $ \r -> Ok r x</hs></pre>

      <p>Теперь, например, можно прочитать цифру и тут же превратить её в однозначное число с помощью вспомогательной функции <code>readInt</code>:</p>

      <pre><hs>num1 = digit >>= (\x -> return (digitToInt x))
digitToInt x = read [x] :: Int</hs></pre>

      <p>Или ещё проще:</p>

      <pre><hs>num1 = digit >>= (return . digitToInt)</hs></pre>

      <p>А так&nbsp;— определить выражение для инфиксного сложения двух однозначных чисел:</p>

      <pre><hs>add = num1 >>= (\x -> term '+' >> num1 >>= (\y -> return (x+y)))</hs></pre>

      <pre><ghci>λ> run num1 "2"
Ok "" 2
λ> run add "3+2"
Ok "" 5
</ghci></pre>

      <p>Работает!! Но. Если вам кажется, что этот кошмар из значков и скобок&nbsp;— это абсолютно неудачный способ записывать трансляторы, то я вас поздравляю: вам так не кажется! Потерпите ещё совсем немного, скоро всё станет существенно лучше.</p>

    <h3>Мы придумали монаду!</h3>

<p>    Помните, нам пришлось спрятать с помощью слова <code>hide</code> операторы <code>>></code>, <code>>>=</code> и функцию <code>return</code>. Давайте посмотрим, какой у них был тип. Для этого загрузим в интерпретаторе модуль <code>Prelude</code>:</p>

    <pre><ghci>λ> :m Prelude
λ> :t (>>)
(>>) :: Monad m => m a -> m b -> m b
λ> :t (>>=)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
λ> :t return
return :: Monad m => a -> m a </ghci></pre>

<p>Сопоставим с типами наших творений:</p>

    <pre><hs>(>>) :: Parser i a -> Parser i b -> Parser i b
(>>=) :: Parser i a -> (a -> Parser i b) -> Parser i b
return :: a -> Parser i a </hs></pre>

    
    <p>Очень похоже! Если заменить <code>Parser i</code> на букву  <code>m</code>, то мы получим

    <pre><hs>(>>) :: m a -> m b -> m b
(>>=) :: m a -> (a -> m b) -> m b
return :: a -> m a</hs></pre>
    
    <p>    Это те же самые типы, что и у операторов, импортируемых из модуля <code>Prelude</code>! Они что, знали чем мы занимаемся? А что это за дополнительная запись: <code>Monad m =></code>?</p>

      <p> Это значит, что операторы <code>>></code>, <code>>>=</code> и функция <code>return</code> работают для любого экземпляра класса <hs>Monad</hs>. И это значит, что мы придумали <em>монаду</em>&nbsp;— очень интересную и мощную концепцию в программировании! Оказывается, наш тип <code>Parser i a</code> является монадическим типом. Определение для этих типов очень простое: <em>монадическим</em> является такой параметризованный тип <code>m</code>, для которого определены следующие две функции:</p>
    
    <pre><hs>return :: a -> m a 
(>>=)  :: m a -> (a -> m b) -> m b</hs></pre>

    <details>
      <p> Чтобы тип действительно был монадическим недостаточно просто определить эти функции, для них должны выполняться определённые несложные законы:</p>
      <pre><hs> x >>= return     =   x
 return x >>= f   =   f x
 x >>= f >>= g    =   x >>= (\y -> f y >>= (\z -> g z))</hs></pre>

      <p>Для трансляторов они выполняются. Можете проверить.</p>
    </details>
    
      <p>Для типов, являющихся монадами, полагается много "бесплатных" полезных функций, определённых для любых монад: <code>liftM</code>, <code>mapM</code>, <code>ap</code>, <code>sequence</code> и т.д. Среди них, например, есть и <code>>></code>, которую нам самим определять уже не нужно.</p>
	
      <p>Больше всего это похоже на реализацию интерфейса в ООП. Мы определяем небольшой набор базовых функций и получаем всю функциональность, которую предоставляет интерфейс.</p>
    
      <p>Раз наши трансляторы образуют монаду, объявим об этом во всеуслышание. Первым делом, уберём первую строчку программы, скрывающую операторы <code>>></code>, <code>>>=</code> и функцию <code>return</code>, добавим модуль для работы с монадами
<pre><hs>import Control.Monad</hs></pre>
	сотрём (или закомментируем) наше определение оператора <code>>></code>,  а затем объявим наш тип <code>Parser i</code> монадой.</p>

      <pre><hs>instance Monad (Parser i) where
  return x = Parser $ \r -> Ok r x
  t1 >>= f = Parser $ \r -> case run t1 r of
    Ok r' x -> run (f x) r'
    Fail r' -> Fail r'</hs></pre>

<p>Этим можно было бы ограничиться до выхода версии компилятора GHC&nbsp;7.10. Начиная с этой версии, по настоянию зануд-математиков, любой монадический тип должен также быть объявлен <em>аппликативным функтором</em>. За это тоже полагаются приятные плюшки. Чтобы их получить, надо определить наш тип экземпляром классов <code>Functor</code> и <code>Applicative</code>:</p>
    <pre><hs>instance Functor (Parser i) where
  fmap f p = p >>= (return . f)

instance Applicative (Parser i) where
  pure = return
  (<*>) = ap</hs></pre>

  <p> Это стандартные определения, которые используют тот факт, что любой тип, являющийся монадой, является аппликативным функтором. Скорее всего, в следующих версиях компилятора эти строчки, одинаковые для всех монад, будут не нужны. Но благодаря этим строчкам в нашем распоряжении появилось два новых оператора: <code>fmap</code> (или <code><$></code>) и <code><*></code>. Вот их типы:

	<pre><code>(<$>) :: (a -> b) -> f a -> f b
(<*>) :: f (a -> b) -> f a -> f b</code></pre>

	Посмотрите на определение функции <code>fmap</code> и сравните его с определением функции <code>num1</code>:
	<pre><hs>fmap f p = p >>= (return . f)
num1 = digit >>= (return . digitToInt)</hs></pre>
 Это значит, что <code>num1</code> можно определить, воспользовавшись тем, что трансляторы являются функторами:
	<pre><hs>num1 = fmap digitToInt digit</hs></pre>
	или ещё компактнее:
	<pre><hs>num1 = digitToInt <$> digit</hs></pre>
  </p>
      
      <p> Теперь мы можем производить различные действия над результатами трансляции, действуя при этом на сам транслятор. Вот что имеется в виду. Допустим, мы хотим увеличить результат транслятора <code>num1</code> в два раза. Можно написать так:
      <pre><hs>num1 >>= (\x -> return (2*x))</hs></pre>
      или, пользуясь тем, что трансляторы теперь объявлены функторами, так:
      <pre><hs>(2*) <$> num1 </hs></pre>

  <p>Оператор <code><$></code> вводит функцию <code>(2*)</code> в контекст транслятора и порождает новый транслятор.</p>

  <pre><ghci>λ> run ((2*) <$> num1) "5"
Ok "" 10 </ghci></pre>
 
  А что с функциями нескольких аргументов? Если мы подействуем на транслятор функцией <code>(+)</code>, то получим транслятор, возвращающий функцию:

  <pre><ghci>λ> :t (+) <$> num1
(+) <$> num :: Parser [Char] (Int -> Int)</ghci></pre>

Мы можем применить спрятанную в контексте функцию к результату другого транслятора с помощью оператора <code><*></code>, так как транслятор является аппликативным функтором:
  <pre><ghci>λ> run ((+) <$> num1 <*> (term '+' >> num1)) "5+7"
Ok "" 12</ghci></pre>

  Это и есть наш транслятор <code>add</code>.

  <pre><hs>add = (+) <$> num1 <*> (term '+' >> num1) </hs></pre>
     
  Операторы <code><$></code> и <code><*></code> выглядят непривычно, но они здорово облегчат нам жизнь в реальных задачах. К тому же, они используются внутри других полезных функций. Например после того, как мы объявили трансляторы аппликативными функторами, нам стала доступна функция <code>sequence</code>, превращающая список трансляторов в один транслятор, возвращающий список результатов:

      <pre><ghci>λ> run (sequence [digit, digit, digit]) "1234"
Ok "4" "123"</ghci></pre>

      Вот&nbsp;— изящное определение для повторения <code>n</code> раз транслятора <code>p</code>:
      <pre><hs>repeatP n p = sequence $ replicate n p</hs></pre>

      Но для этой задачи есть функция <code>replicateM</code>, определённая для любых монад:

      <pre><ghci>λ> run (replicateM 3 digit) "1234"
Ok "4" "123"</ghci></pre>

      Очень полезна функция <code>mapM</code> -- монадический аналог функции отображения <code>map</code>. Посмотрим, что она может нам предложить:

      <pre><ghci>λ> run (mapM term "cat") "catalog"
Ok "alog" "cat"</ghci></pre>

      Из списка символов, <code>mapM term</code> произвела последовательность трансляторов <code>term</code> для этих символов, причём, получившийся транслятор возвращает список результатов этой последовательности. Теперь мы можем определить функцию, распознающую указанную строку:

      <pre><hs>string = mapM term </hs></pre>

<p>После определения комбинатора <code><*></code>, в нашем распоряжении автоматически появилась ещё пара полезных комбинаторов:
    <ul>
      <li> <code>*></code>&nbsp;— игнорирует значение первого аргумента эквивалентен оператору <code>>></code>
      <li> <code><*</code>&nbsp;— игнорирует значение второго аргумента
   </ul></p>

   
<p> Они бывают нужны когда требуется выполнить транслятор в цепочке, но его результат передаваться дальше не будет. Например, пусть нужно чтобы за целым числом следовал пробел. Простая последовательность не годится. мы потеряем прочитанное число:</p>

<pre><ghci>λ> run (num1 >> space) "123 4"
Ok "4" ' '</ghci></pre>

     <pre><ghci>λ> run (num1 <* space) "123 4"
Ok "4" 123</ghci></pre>

 <p>А вот&nbsp;— вычитание двух чисел, разделённых знаком <code>'-'</code></p>
				   
     <pre><ghci>λ> run ((-) <$> num1 <*> (term '-' *> num1)) "52-12"
Ok "" 40</ghci></pre>
</p>
      
      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok i a | Fail i<br/>
(Show, Eq)</p>

<p>Parser a = Parser { run :: i -> Result i a }<br/>
  (Functor, Applicative, Monad)</p></basic>

<part>модификаторы</part>
<p><basic>neg</basic> <der><$> <$</der></p>

<part>комбинаторы</part>
<p><basic><|>  >>=</basic>  <der>>> (*>)</der><br/>
<der><*>  <*  <**></der></p>

<part>элементарные трансляторы</part>
<p><basic>pure</basic> (<der>return</der>) epsilon</p>
	      
<part>трансляторы для коллекций</part>
<p><basic>end next  check</basic>  term<br/>
<der>sequence replicateM mapM</der> </p>

<part>трансляторы для строк</part>
<p>digit space string</p>
</sinopsys>
</details>


 <h3>Делай раз! Делай два!</h3>

      <p>Монадам полагается ещё одна привилегия: специальный синтаксис для последовательности действий.</p>

      <p> Выражение <pre><hs> expr1 >> expr2</hs></pre> можно записать так:
	<pre><hs>do expr1
   expr2</hs></pre>
	Выражение <pre><hs> expr1 >>= (\x -> expr2)</hs></pre> так:
	<pre><hs>do x &lt;- expr1
   expr2</hs></pre>
	При этом в блоке <code>do</code> может быть сколько угодно выражений, связанных с символами или нет.

<p> Давайте-ка перепишем определения для функций <code>num1</code>, и <code>add</code>  в новом виде:

  <pre><hs>num1 = do x <- digit
         return (readInt x)

add = do x <- num1
         term '+'
         y <- num1
         return (x+y)   </hs></pre>    

				   
    <p>Правда, стало похоже на императивную программу? Что-то вроде С#:</p>

    <pre><cs>int num() {
  var x = digit();
  return (Int.Parse(x.toString()));
}
	
int add() {
  var x = num();
  term('+');
  var y = num();
  return (x+y);
}</cs></pre>

      <p>В этом нет ничего удивительного. Монады нужны в очень многих приложениях, но на первый план они выступают в задачах, в которых речь идёт о последовательных вычислениях и трансляция&nbsp;— это типичный пример. Действительно, входная цепочка обрабатывается последовательно: сначала один символ, потом второй и т.д. В императивных программах это естественным образом кодируется последовательностью команд. Роль операторов <code>>>=</code> и <code>>></code> в C# играет "точка с запятой" , которой в функциональном программировании нет. Но её можно придумать и реализовать самим такой, какой нам надо. А это и есть&nbsp;— свобода.</p>

<details>
  <p>Неужели стоило городить все эти абстракции: монады, аппликативные функторы и комбинаторы для того чтобы переизобрести императивное программирование!? Почему бы сразу не писать всё на C#?</p>
  
  <p> Существенная разница состоит в том, что Haskell позволил нам построить императивное программирование <em>с нужными нам свойствами</em>. Что происходит между командами с программе на C#? Ничего. В нашей программе между строк происходит проверка того, чем завершилось выполнение предыдущей команды, и если разбор оказался неудачным вся цепочка будет прекращена, а информация о неразобранной строке передана альтернативной ветке. В программе на C# для прекращения выполнения пришлось бы пользоваться механизмом исключений, а вместо изящного оператора <code><|></code> выстраивать нагромождение из конструкций <code>try-catch</code>. Сравним цепочку альтернатив:</p>

  <pre><hs> x <- term 'a' <|> term 'b' <|> term 'c'</hs></pre>

  <p>с её реализацией с помощью исключений:</p>

  <pre><cs>var x;
try
{
  x = term('a');
}
catch ()
{
  try
  {
    x = term ('b');
  }
  catch ()
  {
    x = term ('c');
  }
}</cs></pre>

  <p>Ещё хуже дело будет обстоять, если альтернативы будут включать в себя последовательности команд, сокращающие входную строку при разборе L(k)-грамматики. В этом случае при неудачном разборе нужно будет как-то вернуть читаемую строку к первоначальному состоянию перед передачей её в альтернативную ветку, а это ещё больше запутает и загромоздит код программы. Наш оператор <code><|></code> устроен так, что каждой ветке предлагается для разбора одна и та же строка (посмотрите на его определение) и этим все сложности снимаются. Мы сразу получаем LL(k)-транслятор. </p>

  
  <p>Монады и функциональный подход позволяют сколь угодно тонко настраивать контроль над вычислениями и вычислительным потоком, оставляя видимость простого последовательного выполнения команд.</p>

  <details><summary>Ещё подробнее</summary>
    
    <p>Посмотрите, что компилятор знает о монадах:</p>
    <pre>
      <ghci>λ> :i Monad
class Applicative m => Monad (m :: * -> *) where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
  	-- Defined in ‘GHC.Base’
instance Monad (Parser i)
  -- Defined at parserM.hs:14:10
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’</ghci></pre>
После определения того, что нужно для определения монады, указано, что монадой является наш тип <code>Parser</code>, а также куча других типов, среди них есть списки (<code>[]</code>), ввод/вывод (<code>IO</code>), частичные значения (<code>Maybe</code>), и даже унарные функции <code>((->) r)</code>. Все они, к тому же, являются аппликативными функторами. Значит для всех для них определены операторы <code>>>=</code>, <code>>></code>, <code><$></code>, <code><*></code> и форма <code>do</code>.

Поэкспериментируйте, посмотрите, как они работают.

  </details>
</details>

      <hr/><task>
	Напишите транслятор <code>between t1 t2 p</code> для транслятора, окружённого терминалами t1 и t2 (например, скобками). При этом тип получившегося транслятора должен совпадать с типом <code>p</code>. С его помощью можно будет записать правило для арифметического выражения в скобках:
	<eqns>T  \rightarrow \text{'('}~E~\text{')'} ~|~ N</eqns>
	без всяких лишних "костылей" и с правильным типом как-нибудь так:
	<pre><hs>_T = between '(' ')' _E <|> _N</hs></pre>
	
      </task><hr>

<h3>Повторите, пожалуйста!</h3>


<p>Вернёмся в начало нашего пути. Мы придумали тип <code>Parser</code> для транслятора и написали для него комбинаторы: <code>>></code>, <code><|></code>  и <code>>>=</code>. Затем выяснили, что сделав наш тип экземпляром класса <code>Monad</code>, используя наше определение комбинатора <code>>>=</code>, мы получили ряд полезных инструментов. Можно ли поступить также с комбинатором <code><|></code>, и не получим ли мы новых инструментов "бесплатно"?</p>

<p> Можно! Задача с выбором одной из альтернативных веток вычислений достаточно общая и для её решения существует класс <code>Alternative</code>. Чтобы его использовать нужно импортировать модуль <code>Control.Applicative</code>.</p>

<pre><hs>import Control.Applicative</hs></pre>

<p>Реализация экземпляра этого класса состоит в определении оператора <code><|></code> и единичного элемента <code>empty</code>, такого, что</p>

<pre><code>empty <|> x =  x <|> empty = x</code></pre>

<p>Роль этого элемента в нашем случае играет функция, возвращающая <code>Fail</code>. Таким образом, получаем определение для экземпляра класса <code>Alternative</code>:</p>

<pre><hs>instance Alternative (Parser i) where
  empty = Parser $ \r -> Fail r
  t1 <|> t2 = Parser $ \r -> case run t1 r of
    Fail _ -> run t2 r
    Ok r' x -> Ok r' x</hs></pre>

<hr><task>Элемент <code>empty</code> является единичным для оператора <code><|></code>, то есть

    <pre><code>empty <|> x =  x <|> empty = x</code></pre>

    Это похоже на единичный элемент для умножения:

    <eqns>1 \cdot x =  x \cdot 1 = x</eqns>
    
    А какой элемент будет единичным для оператора <code>>></code>?

    </p> Если число умножить на ноль, то получится 0:
    <eqns>0 \cdot x =  x \cdot 0 = 0</eqns>
    А есть ли для операторов <code><|></code> и <code>>></code> нулевые элементы, в том же смысле, в котором для операции умножения является число 0?</p>

<p>Что является нулевым и единичным элементом для операций <code>$$</code>, <code>||</code>, <code>max</code>, <code>+</code>, <code>++</code>?</p>
<details><summary>Ещё одно страшное слово</summary>
  
  <p>Любой тип, для которого существует ассоциативная бинарная операция с единичным элементом называется <em>моноидом</em>. для этого в Haskell есть специальный класс типов. Но нам он пока не нужен.</p>
</details>
</task><hr/>

<p>Что же, что же мы получим за реализацию класса <code>Alternative</code>? А вот что&nbsp;— три комбинатора <code>some</code>, <code>many</code> и <code>optional</code>, обозначающие варианты повторения элементов. При конструировании регулярных выражений для этого используются модификаторы <code>+</code>, <code>*</code> и <code>?</code> , означающие следующее:</p>

  <pre>p+&nbsp;— элемент p встречается один или много раз подряд
p*&nbsp;— элемент p встречается ноль или много раз подряд
p?&nbsp;— элемент p встречается ноль или один раз</pre>

<p>Так вот, <code>some p</code> соответствует <code>p+</code>, <code>many p</code>&nbsp;— <code>p*</code>, а <code>optional p</code>&nbsp;— <code>p?</code>. Более того <code>some p</code> и <code>many p</code> сами собирают результаты повторений в список!</p>

  <pre><ghci>λ> run (many digit) "1234xse"
Ok "xse" "1234"
λ> run (many digit) "xse"
Ok "xse" ""
λ> run (some digit) "xse"
Fail "xse"
λ> run (some digit) "123xse"
Ok "xse" "123"</ghci></pre>

<p>Функция <code>optional</code> возвращает результат типа <code>Maybe</code>, наиболее точно отражающий её смысл:
<pre><ghci>λ> run (optional digit) "123"
Ok "23" (Just '1')
λ> run (optional digit) "c123"
Ok "c123" Nothing</ghci></pre>
</p>

  <details> 
    <p>У этих функций очень простые аппликативные определения:</p>
<pre><hs>some p = (:) <$> p <*> many p
many p = some p <|> pure []
optional p = Just <$> p <|> pure Nothing</hs></pre>

    <p>Помните, в определении экземпляра <code>Applicative</code> для трансляторов мы задали функцию <code>pure = return</code>. Это одно и то же, но в аппликативном стиле прилагательное <code>pure</code> (чистый) читается лучше глагола <code>return</code>. Последний стоит использовать при записи в монадическом духе:</p>
    <pre><hs>some p = do x <- p
            xs <- many p
            return (x:xs)</hs></pre>	  
  </details>


<task>Пользоваться функцией <code>optional</code> в ряду с <code>some</code> и <code>many</code> не очень удобно. Последние две возвращают списки, а <code>optional</code> -- тип <code>Maybe</code> и если нам захочется их комбинировать, это будет непросто.
  Определите функцию <code>opt</code> -- аналогичную по смыслу <code>optional</code>, но возвращающую список.

      <pre><ghci>λ> run (opt digit) "123"
Ok "23" "1"
λ> run (opt digit) "x123"
Ok "23" ""
</ghci></pre>
  
</task><hr>

<task>Для полноты картины, добавьте функцию <code>only</code>, которая просто возвращает элемент в списке. Она понадобится нам позже.
      <pre><ghci>λ> run (only digit) "123"
Ok "23" "1"
</ghci></pre>  
</task>
  
      <hr/><task> Напишите транслятор <code>integer</code> для положительного целого числа с произвольным количеством цифр, возвращающий число типа <code>Integer</code></task><hr>

      <pre><ghci>λ> run integer "1234bc"
Ok "bc" 1234
</ghci></pre>
      
      
      <hr/><task> Напишите модификатор <code>oneof p args</code> задающий множество возможных параметров транслятора <code>p</code>:

      <pre><ghci>λ> run (term `oneof` "cat") "catalog"
Ok "atalog" "c"
run (term `oneof` "cat") "dog"
Fail "dog"
λ> run (some (term `oneof` "cat")) "active"
Ok "ive" "act"
λ> run (some (term `oneof` "cat")) "xorg"
Fail "xorg"
λ> run (string `oneof` ["cat","dog","mouse"]) "dog"
Ok "" "dog"
λ> run (string `oneof` ["cat","dog","mouse"]) "bird"
Fail "bird" </ghci></pre>
      </task>

      <hr/><task> Напишите модификатор <code>except p args</code> задающий множество параметров для транслятора <code>p</code>, которые не должны встретиться. Например, <code>term `except` "cat"</code> означает любой символ, кроме <code>'c'</code>, <code>'a'</code> или <code>'t'</code>.</task>
      
      <hr/><task> Напишите транслятор <code>spaces</code> для последовательности пробельных символов: пробела, табуляции и переноса строки.</task>

      <hr/><task> Напишите транслятор <code>sepBy p s</code> для последовательности элементов, <code>p</code> разделённых элементами <code>s</code>. Он должен возвращать список элементов <code>p</code>

      <pre><ghci>λ> run ((some next) `sepBy` spaces) "a cat jumped"
Ok "" ["a", "cat", "jumped"]
λ> run (integer `sepBy` (term ',')) "12,56,4"
Ok "" [12, 56, 4]
λ> run (sum <$> (integer `sepBy` (term ','))) "12,56,4"
Ok "" 72 </ghci></pre>
</task><hr>


      <details><summary>Общий взгляд на программу</summary>

	<sinopsys>
<part>типы</part>
<p><basic>Result i a = Ok i a | Fail i<br/>
(Show, Eq)</basic></p>

<p><basic>Parser a = Parser { run :: i -> Result i a }<br/>
    (Functor, Applicative, Monad, Monoid, Alternative)</basic></p>

<part>модификаторы</part>
<p><basic>neg</basic> <der><$> <$</der></p>

<part>комбинаторы</part>
<p><basic><|>  >>=</basic>  <der>>> (*>)</der><br/>
<der><*>  <*  <**></der></p>

<part>элементарные трансляторы</part>
<p><basic>empty  pure</basic> (<der>return</der>)</p>

<part>трансляторы для коллекций</part>
<p><basic>end next  check</basic>  term<br/>
oneof  except<br/>
<der>sequence replicateM mapM</der> seqn  sepBy  between<br/>
<der>some  many optional</der>  opt only</p>

<part>трансляторы для строк</part>
<p>digit  integer  string  spaces string</p>
</sinopsys>
</details>

      <h3>Орудия к бою!</h3>

<p>Рассмотрим ряд примеров, в которых наши трансляторы покажут на что они способны.</p>

<!-- <h4>Чтение данных, записанных в виде CSV-таблицы</h4> -->

<!-- <pre><hs>readCSV p txt = run tbl txt -->
<!--   where tbl = row `sepBy` term '\n' -->
<!--         row = p `sepBy` (many space >> term ',')</hs></pre> -->

<!-- <pre><ghci>λ> readCSV integer "1, 2, 3\n 45, 56, 8" -->
<!-- Ok "" [[1,2,3],[45,56,8]] -->
<!-- λ> readCSV integer "1, 2, 3\n 45" -->
<!-- Ok "" [[1,2,3],[45]] -->
<!-- </ghci></pre> -->

<h4>Подсчёт и поиск элементов</h4>

<p>Для разминки напишем транслятор, подсчитывающий число вхождений указанного элемента во входной последовательности. Очень простой, но достаточно быстрый, заменяющий каждое вхождение элемента на 1, а прочие -- на 0, и суммирующий то, что получилось:</p>

<pre><hs>count p = do x <- p *> pure 1 <|> next *> pure 0
             xs <- count p <|> pure 0
             return $ x + xs</hs></pre>

<p>Выражение<pre><hs>p *> pure x</hs></pre> можно переписать так: <pre><hs>(const x) <$> p</hs></pre> или так: <pre> <hs>x <$ p</hs> </pre> где оператор <code><$</code> подобен по смыслу <code><*</code> -- он применяет к функтору указанную константу, игнорируя прежнее значение. Теперь перепишем определение для <code>count</code>:</p>

<pre><hs>count p = do x <- (1 <$ p <|> 0 <$ next)
             xs <- count p <|> pure 0
             return $ x + xs</hs></pre>

<pre><ghci>λ> run (count integer) "5 pigs, 12 cows, 47 cats"
Ok "" 3</ghci></pre>
		   
<p> На неё очень похожа функция, которая отыскивает все указанные элементы в строке и возвращает их список</p>

<pre><hs>search p = do x <- (only p <|> [] <$ next)
              xs <- search p <|> pure []
              return $ x ++ xs</hs></pre>

<pre><ghci>λ> run (search integer) "5 pigs, 12 cows, 47 cats"
Ok "" [5,12,47]</ghci></pre>
		    

  <p>Конечно же, то, что эти две функции похожи, неслучайно. Они делают одно и тоже действие: отыскивают элемент и добавляют его в результат -- одна с помощью операции <code>+</code>, другая -- с помощью <code>++</code>. Обе для того, чтобы пропустить ненужные элементы используют для добавления единичный элемент своей операции, одна -- <eq>0</eq>, другая -- <code>[]</code>.</p>
<p>Помните, страшное слово <em>моноид</em>? Самое время его вспомнить и применить. Для моноидов есть специальный класс типов <code>Monoid</code>, определённый в модуле <code>Data.Monoid</code>. Для его экземпляра необходимо указать операцию "сложения" -- <code>mappend</code> и единичный элемент -- <code>mempty</code>.

  <pre><hs>instance Monoid b => Monoid (Parser  i b) where
  mappend p1 p2 = mappend <$> p1 <*> p2
  mempty = pure mempty</hs></pre>
    
<p>Это позволит легко соединять результаты трансляции, просто соединяя трансляторы.</p>

<pre><ghci>run (string "a" <> next <> string "b") "axb"
Ok "" "axb"</ghci></pre>

<p>Кроме того, введём обобщенные моноидальные аналоги функциям <code>some</code>, <code>many</code> и <code>opt</code>:</p>

<pre><hs>msome p = mconcat <$> some p
mmany p = mconcat <$> many p
mopt p = mconcat <$> opt p</hs></pre>

<pre><ghci>run (string "a" <> mmany next <> string "b") "axyzb"
Ok "" "axyzb"
run (string "a" <> mmany next <> string "b") "ab"
Ok "" "ab"</ghci></pre>

<p> Ещё мы получим возможность определять свои собственные функции, универсальные для любых моноидов. Например, функцию, обобщающую <code>count</code> и <code>search</code>. Назовём её <code>collect</code>:
<pre><hs>instance Monoid b => Monoid (Parser  i b) where
  mappend p1 p2 = mappend <$> p1 <*> p2
  mempty = pure mempty</hs></pre>

<pre><hs>collect p = do x <- (p <|> mzero <$ next)
              xs <- collect p <|> pure mzero
              return $ mappend x xs</hs></pre>

<p>Для начала, сделаем наш тип <code>Parser</code> моноидом относительно операции <code>>></code>, и так, чтобы использовать моноидальные свойства возвращаемого транслятором аргумента.</p>

		    
 <p>Как же ею пользоваться, ведь мы не знаем какой именно моноид будет коллекционироваться? В этом состоит сила классов и автоматического вывода типов. Компилятор сам сообразит каким экземпляром класса <code>Monoid</code> воспользоваться из типа, возвращаемого элементом <code>p</code>:</p>

<pre><ghci>λ> :t collect
collect :: Monoid b => Parser [b1] b -> Parser [b1] b</ghci></pre>

<p>Вот как можно теперь определить функцию <code>search</code>:</p>

<pre><hs>search p = collect (only p)</hs></pre>

<pre><ghci>λ> run (search integer) "5 pigs, 12 cows, 47 cats"
Ok "" [5,12,47]</ghci></pre>
				     
 <p>Всё, что нам потребовалось сделать, это указать, что элемент <code>p</code> возвращает свой результат, "завёрнутым" в список. Список -- это моноид, а значит функция <code>collect</code> "знает" как собирать результаты и пропускать ненужные элементы.</p>

<p>Так можно определить функцию <code>count</code>:</p>

<pre><hs>count p = getSum <$> collect (Sum 1 <$ p)</hs></pre>

 <p>Существует два разных экземпляра моноидов для чисел: <code>Product</code> и <code>Sum</code>. И действительно, числа образуют моноид с операцией сложения и нулём, а также с умножением и единицей. Значит, надо подсказать функции <code>collect</code> как именно мы собираемся собирать результаты: складывать, или перемножать. С помощью функции <code>getSum</code> мы можем извлечь результат из типа <code>Sum</code></p>

<pre><ghci>λ> run (count integer) "5 pigs, 12 cows, 47 cats"
Ok "" 3</ghci></pre>

<p>А так можно не только найти все числа в строке, но и получить их сумму или произведение:</p>

<pre><ghci>λ> run (getSum <$> collect (Sum <$> integer)) "5 pigs, 12 cows, 47 cats"
Ok "" 64
run (getProduct <$> collect (Product <$> integer)) "5 pigs, 12 cows, 47 cats"
Ok "" 2820</ghci></pre>


 <p>Очень изящно. Изменяя тип, возвращаемый транслятором <code>integer</code>, мы меняем смысл функции <code>collect</code>.</p>

<p>И последнее. В модуле <code>Data.Monoid</code> определена универсальная функция <code>mconcat</code>, аналог функции <code>concat</code>, объединяющей списки. Только объединяет она их с помощью операции <code>mappend</code>. Она позволит нам переписать определение функции <code>collect</code> очень сжато:</p>

<pre><hs>collect p = mconcat <$> many (p <|> mempty <$ next)</hs></pre>

<hr><task>Реализуйте комбинатор <code>&lt;?></code>, с помощью которого, можно было бы отфильтровывать трансляторы по указанному предикату для возвращаемого значения. Так, например можно было бы отыскивать в тексте только нечётные числа:
<pre><ghci>λ> run (search (integer &lt;?> odd)) "5 pigs, 12 cows, 47 cats"
Ok "" [5,47]</ghci></pre>
</task><hr>


<!-- <h4>анализатор элементов XML</h4> -->

<!-- <pre><hs> -->
<!-- data XML = Tag String [XML] -->
<!--          | Text String -->

<!-- xml = do t <- opentag -->
<!--          x <- many (xml <|> text) -->
<!--          closetag t -->
<!--          return Tag t x -->

<!-- opentag = term '<' >> check (/= '/') >> -->
<!--           some (except " >") <* -->
<!--           (many (except ">") >> next) -->

<!-- closetag t = seqn $ term $ "&lt;&frasl;" ++ t ++ "&gt;" -->

<!-- text = Text <$> many (term `except` "<") -->
<!-- </hs></pre> -->

    
<h4>Транслятор арифметических выражений</h4>

<p>Пора написать классический транслятор, который используется, как пробный камень во всех статьях по лексическому анализу и компиляции: транслятор произвольных арифметических выражений с учётом приоритетов, ассоциативности и скобок.</p>

<p> Грамматика арифметических выражений с левоассоциативными операциями такова:
  <eqns> E \rightarrow E ~(\text{'+'}~|~ \text{'}-\text{'})~T ~|~ T\\
    T \rightarrow T ~(\text{'*'}~|~\text{'/'})~ P ~|~ P\\
    P \rightarrow \text{'('}~ E ~\text{')'} ~|~ N
  </eqns>
  где <eq>N</eq>&nbsp;— целое число.
</p>

 <p>Можно честно перевести её к виду, исключающему левую рекурсию, но мы пойдём по другому пути, который более всего соответствует духу функционального программирования. Наделим термы <code>'+'</code>, <code>'-'</code> и т.д. функциональными свойствами:</p>
  
<pre><hs>add = (+) <$ term '+'
sub = (-) <$ term '-'
mul = (*) <$ term '*'
frac = div <$ term '/' </hs></pre>

<p>Каждая из них возвращает в качестве результата соответствующую ей <em>функцию</em>. Напишем теперь свёртку для последовательности элементов <eq>A</eq>, разделённых указанным элементом-оператором <eq>op</eq>. В основе свёртки будет рассмотренное нами ранее преобразование, исключающее левую рекурсию. Пусть есть леворекурсивное правило
  <eqns> A \rightarrow A ~op~ B ~|~ B</eqns>
  Мы знаем уже, что его можно переписать без левой рекурсии так
  <eqns> A \rightarrow B~ R\\
    R \rightarrow op~ B~ R ~|~ \varepsilon</eqns>

<pre><hs>_A = _B >> _R
_R = op >> _B >> _R <|> epsilon</hs></pre>

Если трансляторы <code>_B</code> и <code>op</code> возвращают какие-либо значения, то <code>_R</code> должна быть функцией, принимающей эти значения и накапливающей результат:

<pre><hs>_A = _B >>= _R
_R x = (do f <- op
           y <- _B
           _R (f x y)) <|> pure x
</hs></pre>
Здесь мы пользуемся тем, что транслятор операции <code>op</code> возвращает ассоциированную с ним функцию. </p>

Таким образом, получаем абстракцию для левой свертки:

<pre><hs>foldP p op = p >>= rest
  where rest x = (do f <- op
                     y <- p
                     rest (f x y)) <|> pure x
</hs></pre>

<details><summary>Другой вариант</summary>

  
  <p>Цепочку <pre><code>p op p op p op p ...</code></pre> можно описать такой грамматикой:

<pre><hs> p >> many (op >> p)</hs></pre>

Если заменить <code>op >> p</code> на <code>op <*> p</code> то <code>many</code> вернёт список трансляторов, возвращающих частично применённые функции. Его можно свернуть с помощью стандартной функции <code>foldl</code>, на каждом шаге свёртки применяя очередную функцию к результату:
  
<pre><hs>foldP p op = foldl apply <$> p <*> many (op' <*> p)
  where op' = flip <$> op
        apply = flip ($)
</hs></pre>

Превратить <code>op</code> в <code>op'</code> потребовалось, чтобы функции частично применялись справа, а не слева, как обычно. Написанная нами свёртка цепочку арифметических действий "1+2-3+5" транслирует так:</p>

  <pre><hs>(+ 5) $ ((-) 3) $ (+ 2) $ 1</hs></pre>

</details>

<p>Имея такую свёртку легко напишем транслятор арифметических выражений, производящий вычисления в ходе трансляции:</p>

<pre><hs>expr = _E
  where _E  = foldP _T (add <|> sub)
        _T  = foldP _P (mul <|> frac)
        _P = between '(' ')' _E <|> integer

	add = (+) <$ term '+'
        sub = (-) <$ term '-'
        mul = (*) <$ term '*'
        frac = div <$ term '/'</hs></pre>

Проверяем:

<pre><hs>testExpr = runTestsFor expr
  [ ("23",                    Ok "" 23)
  , ("23+5",                  Ok "" 28)
  , ("23+5-13",               Ok "" 15)
  , ("23-5-13",               Ok "" 5)
  , ("23-(5-13)",             Ok "" 31)
  , ("2*3+4*5",               Ok "" 26)
  , ("2*(3+4)*5",             Ok "" 70)
  , ("32/2/2/2",              Ok "" 4)
  , ("32/(2/(2/2))",          Ok "" 16)
  , ("((((5))))",             Ok "" 5)
  , ("(2*(8-7/2)+5*8)/(2+3)", Ok "" 10)]</hs></pre>

Замечательно!

<hr><task>
  Перепишите определения <code>add</code>, <code>sub</code>, <code>mul</code>, <code>frac</code> так, чтобы транслятор <code>expr</code> переводил арифметические выражения в постфиксную форму, как в языках Fort или PostScript:

<pre><code>"23"         ==>  "23"
"23+5"       ==>  "23 5 +"
"23+5-13"    ==>  "23 5 + 13 -"
"23-5-13"    ==>  "23 5 - 13 -"
"23-(5-13)"  ==>  "23 5 13 - -"
"2*3+4*5"    ==>  "2 3 * 4 5 * +"
"2*(3+4)*5"  ==>  "2 3 4 + * 5 *"
"((((5))))"  ==>  "5"
"(2*(8-7/2)+5*8)/(2+3)"  ==>
       "2 8 7 2 / - * 5 8 * + 2 3 + /"</code></pre>
  
</task>

<hr><task>  Напишите транслятор арифметических выражений в префиксную скобочную форму, как в языке Lisp:

<pre><code>"23"         ==>  "23"
"23+5"       ==>  "(+ 23 5)"
"23+5-13"    ==>  "(- (+ 23 5) 13)"
"23-5-13"    ==>  "(- (- 23 5) 13)"
"23-(5-13)"  ==>  "(- 23 (- 5 13))"
"2*3+4*5"    ==>  "(+ (* 2 3) (* 4 5))"
"2*(3+4)*5"  ==>  "(* (* 2 (+ 3 4)) 5)"
"(2*(8-7/2)+5*8)/(2+3)"  ==>
    "(/ (+ (* 2 (- 8 (/ 7 2))) (* 5 8)) (+ 2 3))"</code></pre>
</task>

<hr><task> Добавьте в грамматику и в трансляторы унарный минус, так чтобы правильно интерпретировались такие выражения:

  <pre><code>-5
-(-5)
-3*3
3*(-3)
2+(-3)
2-(-3) </code></pre>
</task>

<hr><task> Напишите транслятор арифметических выражений в абстрактное синтаксическое дерево.</task>

<hr><task> Напишите вычислитель выражений в префиксной скобочной форме и транслятор из в префиксной скобочной формы в постфиксную.</task>

<hr><task>Напишите анализатор для условного оператора в языке C#.</task><hr/>

<h4>Чтение данных в формате JSON</h4>

<p>Замечательный примером использования нашей системы трансляции будет разбор и чтение данных в формате JSON. Этот формат широко используется для сериализации и передачи в виде потока сложных иерархических структур: произвольных объектов, массивов и элементарных данных.</p>

<p> Вот, что написано на официальном сайте <code>http://www.json.org/json-ru.html</code>
  <disclaim>JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Он включает в себя следующие структуры:

    <ul>
      <li/><em>Объект</em> -- неупорядоченный набор пар ключ/значение. Объект начинается с открывающей фигурной скобки и заканчивается закрывающей фигурной скобкой. Каждое имя сопровождается двоеточием, пары ключ/значение разделяются запятой.

      <pre>{'name':'Jane','age':22}</pre>
      
      <li/><em>Массив</em> -- упорядоченная коллекция значений. Массив начинается с открывающей квадратной скобки и заканчивается закрывающей квадратной скобкой. Значения разделены запятой.

      <pre>[23,45,6,23]
['cat','dog']</pre>
      
      <li/><em>Значение</em> может быть строкой в кавычках, числом, <code>true</code>, <code>false</code>, объектом или массивом. Эти структуры могут быть вложенными.

      <li/> Пробелы могут использоваться между любыми лексемами.
    </ul>
  </disclaim>
</p>

<p>Приведём пример выражения JSON (мы пользуемся стандартом JSON5, допускающим одинарные кавычки):</p>

<pre>{
    'workers' :
    [
	{
	    'name' : 'James Mitchell',
	    'age'  : 32,
	    'hobby': ['golf', 'eating pizza']
	},
	{
	    'name' : 'Mary Kay',
	    'age'  : 25,
	    'hobby': ['cats','BMW','James']
	},
	{
	    'name': 'Garry Potter',
	    'age' : 14
	}    
    ]
}</pre>

<p>Чтение JSON означает интерпретацию строки и создание соответствующей структуры данных. Например, приведённый выше пример в программе на языке Хаскелл должен быть прочтён как-то так:</p>

<pre><hs>Workers
  [ Person "James Mitchell" 32 ["golf", "eating pizza" ]
  , Person "Mary Kay" 25 ["cats", "BMW", "James"]
  , Person "Garry Potter" 14 [] ]</hs></pre>

Мы легко создадим трансляторы, соответствующие объекту и массиву:

<pre><hs>object p = between '{' '}' p
arrayOf p = between '[' ']' (p `sepBy` term ',' <|> pure [])</hs></pre>

А для пары напишем специальный комбинатор:

<pre><hs>infix 5 .:
key .: p  = string (show key) *> term ':' *> p <* opt (term ',')</hs></pre>

Осталось определить трансляторы для строк и чисел:

<pre><hs>string_ = between '\'' '\'' $ many (term `except` "'")
number_ = integer</hs></pre>

 <p> Вот, собственно, и всё! Остальную работу для нас выполнят операторы <code><$></code> и <code><*></code>:</p>

 <pre><hs>data Person = Person String Integer [String]
       deriving Show

person = object $
  Person <$> "name"  .: string_
         <*> "age"   .: integer_
         <*> "hobby" .: arrayOf string_</hs></pre>

Проверяем на примере без пробелов:

 <pre><ghci>λ> run person "{'name':'James','age':15,'hobby':['golf','pizza']}"
Ok "" Person "James Mitchell" 15 ["golf","eating pizza"]</ghci></pre>

 <hr/><task>Напишите транслятор <code>cleanJSON</code>, который убирал бы лишние пробелы из JSON (оставляя их в строках).
 <pre><ghci>λ> cleanJSON "{ 'name': 'James Mitchell', 'age': 15, 'hobby': ['golf', 'eating pizza']}"
"{'name':'James Mitchell','age':15,'hobby':['golf','eating pizza']}"</hs></pre></task><hr/>

 <task> Так в Хаскеле можно прочитать текст в виде строки из файла с указанным именем, а потом обработав, вывести результат:
					       
 <pre><hs>import System.IO  
  
main = do text <- readFile "test.json"
          print $ readJSON workers text</hs></pre>

 <p> Напишите функцию readJSON, принимающую транслятор и строку, а возвращающую результат разбора. </p>

 <pre><hs>readJSON :: Parser String a -> String -> Maybe a</hs></pre>
 
<p>Определите транслятор JSON выражения, для объекта "workers" (как в примере выше).
 </task><hr/>

 <task>Добавьте каждому объекту Person поле <code>"best friend</code>", содержащее информацию о лучшем друге в виде структуры <code>Person</code>. Причём, друга может и не быть.</task><hr/>
 
<h1>Транслятор регулярных выражений</h1>

<p>Рассмотрим достаточно серьёзную задачу разбора и трансляции регулярных выражений.</p>

 <p>Транслятор регулярных выражений должен превращать строку в транслятор, соответствующий регулярному выражению. Например, из строки <code>"a.b+"</code> он должен сделать транслятор,

  <pre><hs>only (term 'a') <> only next <> msome (term 'b')</hs></pre>

<p>То есть, это транслятор из строки -- в трансляторы. Такой процесс называется суперкомпилированием.</p>

 <p>Мы не будем здесь реализовывать полный набор функции, реализованных в стандартах POSIX или Perl, остановимся на основных элементах и их комбинаторах:</p>
					
 <p>Регулярное выражение может быть:</p>
   <ul>
     <li/> <em>символом-литералом</em>, которые представляют сами себя;
     <li/> метасимволом <code>.</code> (точка), представляющим <em>любой символ</em>;
     <li/> <em>символьным классом</em>  -- набором символов в квадратных скобках <code>[ ]</code>, представляющим множество возможных символов (<code>[cat]</code> означает <code>c</code> или <code>a</code> или <code>t</code>); если требуется указать символы, которые не входят в указанный набор, то используют символ <code>^</code> внутри квадратных скобок (<code>[^cat]</code> -- любой символ, кроме <code>c</code>, <code>a</code> или <code>t</code>); возможно указание диапазонов символов с помощью тире, например <code>[0-9]</code> -- означает любой цифровой символ;
     <li/> <em>группой</em> -- регулярным выражением, окружённым круглыми скобками;
     <li/> <em>последовательностью</em> регулярных выражений;
     <li/> <em>объединением</em> (перечислением) регулярных выражений;
     <li/> регулярным выражением с модификаторами повторения.
   </ul>

 <p>Приведём формальное описание грамматики регулярных выражений, трансляцию которых мы реализуем:</p>


<pre><nt>R</nt> = a     <ht>символ-литерал</ht>
    .     <ht>любой символ</ht>
    [<nt>C</nt>]   <ht>символьный класс</ht>
    (<nt>R</nt>)   <ht>группа</ht>
    <nt>R</nt>|<nt>R</nt>   <ht>объединение</ht>
    <nt>R</nt><nt>R</nt>    <ht>конкатенация (последовательность)</ht>
    <nt>R</nt><nt>M</nt>    <ht>модификация</ht>

символьный класс
<nt>С</nt> = a     <ht>символ-литерал</ht>
    a-b   <ht>диапазон символов</ht>
    ^<nt>C</nt>    <ht>отрицание класса</ht>

модификаторы повторения 
<nt>M</nt> = *     <ht>повторение элемента ноль или много раз</ht>
    +     <ht>повторение элемента один или много раз</ht>
    ?     <ht>повторение элемента ноль или один раз</ht></pre> 
</p>

 <p>Подобно арифметическим выражениям, регулярные выражения "собираются" с помощью трёх операций -- объединения, конкатенации и модификации, причём приоритет объединения ниже чем у конкатенации, а у конкатенации -- ниже чем у модификаторов. Объединение можно определить функциональной свёрткой <code>foldP</code>, а конкатенацию осуществить функцией <code>msome</code>:</p>

<pre><hs>_R = foldP (msome element) alt
   where alt = (<|>) <$ term '|'
         element = (group <|> (only <$> symbol)) <**> modifier
         group = between '(' ')' _R
         symbol = anychar <|> charClass <|> literal </hs></pre>

<p>Теперь определим элементы их интерпретацию. (Сейчас будет немного сюрреализма, но смысл в этом всё же есть.) Все элементы после распознавания транслируются в трансляторы, которые, в свою очередь свои результаты комбинируют в строку.</p>

 <p>Символ-литерал интерпретируется, как транслятор <code>term</code>.</p>
<pre><hs>literal = term <$> term `except` "?+*()[]|."</hs></pre>

 <p>Метасимвол <code>.</code> (точка) транслируется в транслятор <code>next</code></p>
<pre><hs>anychar = next <$ term '.'</hs></pre>

 <p>Определение для символьных классов выглядит более сложным, но устроено достаточно прямолинейно:</p>

 <pre><hs>charClass = between '[' ']' c
   where c = oneof term <$> chars
         <|> except term <$> (term '^' *> chars)

         chars = msome (range <|> only char)
         char = term `except` "]"
         range = enumFromTo <$> char <*> (term '-' *> char)</hs></pre>

 <p>Модификаторы сделаем функциями, наподобие арифметических операций:</p>				

 <pre><hs>modifier = option <|> repeat0 <|> repeat1 <|> pure id
   where option = mopt <$ term '?'
         repeat1 = msome <$ term '+'
         repeat0 = mmany <$ term '*'</hs></pre>

 <p>Наконец, сам транслятор регулярных выражений превратим в полноценный транслятор:</p>
						
<pre><hs>regexp s = case run _R s of
  Ok "" p -> p
  _ -> empty</hs></pre>


 <p>Вот как можно им пользоваться:</p>

 <pre><ghci>λ> run (search (regexp "c.(t|p)")) "the cat has a cup"
Ok "" ["cat","cup"] </ghci></pre>

					
<p>Вот более полезный пример. Пусть нам нужно из извлечь параметры из URL:</p>
<pre>www.site.org?day=7&name=adam&fruit=apple</pre>
Мы можем сделать это с помощью регулярного выражения так:

 <pre><hs>params = search (regex "[a-z]+=[^&]+")</hs></pre>

 <pre><ghci>λ> run params "www.site.org?day=7&name=adam&fruit=apple"
Ok "" ["day=7","name=adam","fruit=apple"]</ghci></pre>
 
 А так -- транслировать в словарь:
 
 <pre><hs>params = search ((,) <$> regex "[a-z]+" <*> (term '=' *> regex "[^&]+"))</hs></pre>

 <pre><ghci>λ> run params "www.site.org?day=7&name=adam&fruit=apple"
Ok "" [("day","7"),("name","adam"),("fruit","apple")]</ghci></pre>
 
 <hr/><task>Проверьте правильность работы транслятора регулярных выражений на нескольких примерах:
<ul>
  <li> число с плавающей точкой
  <li> простой e-mail адрес
  <li> дата в формате DD.MM.YYYY
  <li> слова типа "тум-там-тум", "там-там-там-тарарам", "трам-тарарам-там-там" и т.д.
</ul>
		       </task><hr/>
 
<h1>Лексический анализатор</h1>

<p>Лексический анализ -- это первичный этап обработки программы или текста, на котором происходит выделение и классификация основных единиц языка -- лексем.
<p>
  
<p>Например, в языке Haskell единицами языка являются не отдельные буквы, символы или цифры, а такие лексемы как
  <ul>
    <li/><em>ключевое слово</em> -- одно из списка слов <code>"module"</code>, <code>"data"</code>, <code>"where"</code> <code>"if"</code>, <code>"then"</code>, <code>"else"</code> и т.д.;
    <li/><em>идентификатор</em> -- последовательность букв или цифр, начинающихся с буквы, не являющаяся ключевым словом;
    <ul>
      <li/> <em>имя типа</em> -- идентификатор, начинающийся с заглавной буквы; 
      <li/> <em>имя функции или аргумента</em> -- идентификатор, начинающийся со строчной буквы; 
     </ul>
    <li> <em>литерал</em>
      <ul>
	<li/><em>число</em> -- последовательность цифр, и символа '.', подчинённая определённому порядку;
	<li>строка -- последовательность произвольных символов, ограниченная двойными кавычками;
	<li>символ -- произвольный символ, ограниченный одинарными кавычками;
      </ul>
    <li/><em>оператор</em> -- последовательность специальных символов <code>'-'</code>, <code>'+'</code>, <code>'='</code>, <code>'<'</code>, <code>'>'</code>, <code>'*'</code> и т.д.
    <li/><em>скобки</em> -- <code>'('</code>, <code>')'</code>, <code>'['</code>, <code>']'</code>, <code>'{'</code>, <code>'}'</code>
    <li/><em>комментарии</em> -- последовательность любых символов, начинающаяся со строки "--" и заканчивающаяся концом строки.
  </ul>

  Таким образом, лексический анализ программы:
  <pre><hs>abs :: Int -> Int
abs x = if x <= 0 then (-x) else x</hs></pre>

Породит такую последовательность лексем:

		<pre><code>ID(abs)
OP(::)
TYP(Int)
OP(->)
TYP(Int)
ID(abs)
ID(x)
OP(=)
KWD(if)
ID(x)
OP(<=)
NUM(0)
KWD(then)
LBR OP(-)
ID(x)
RBR
KWD(else)
ID(x)</code></pre>
   
Давайте напишем лексический анализатор для языка Yoda, который включает в себя такие лексемы:
  <ul>
    <li/><em>ключевое слово</em> -- одно из списка слов <code>"def"</code>, <code>"when"</code>, <code>"if"</code> <code>"dup"</code>, <code>"pop"</code>, <code>"swap"</code>, <code>"repeat"</code>;
    <li/><em>идентификатор</em> -- последовательность любых символов, кроме скобок, и кавычек, не являющаяся ключевым словом;
    <li><em>символ</em> -- идентификатор, ограниченный одинарными кавычками;
    <li/><em>число</em> -- последовательность цифр, и символа '.', подчинённая определённому порядку;
    <li/><em>скобки</em> -- <code>'{'</code>, <code>'}'</code>
    <li/><em>комментарии</em> -- последовательность любых символов, начинающаяся с символа "#" и заканчивающаяся концом строки.
  </ul>

Например, программа
    <pre><code># the norm function
'norm' {dup * swap * +} def </code></pre>
После лексического анализа превратится в последовательность
    <pre><code>CMT(the norm function) SYM(norm) LBR KWD(dup)
ID(*) KWD(swap) ID(*) ID(+) RBR KWD(def)</code></pre>

<p>Вот как можно запрограммировать этот лексический анализатор:</p>

    <pre><hs>data Token = KWD String
           | ID String
           | SYM String
           | NUM Integer
           | LBR | RBR
           | CMT String deriving (Show, Eq)
	
yodaLex = run lexer
  where lexer = many $ spaces >>
          ( CMT <$> comment <|>
            KWD <$> keyword <|>
            NUM <$> integer <|>
            SYM <$> symbol <|>
            LBR <$ term '{' <|>
            RBR <$ term '}' <|>
            ID <$> identifier)
          
        keyword = string `oneof` ["def", "when", "if"
                                 , "dup", "pop", "swap"
                                 , "repeat"] 
          
        symbol = between '\'' '\'' identifier
        
        identifier = some (term `except` " '{}#")

        comment =  between '#' '#' $ many (term `except` "#")</hs></pre>

<pre><ghci>λ> yodaLex "'x' 5 def 6 x *"
Ok "" [SYM "x",NUM 5,KWD "def",NUM 6,ID "x",ID "*"]
λ> yodaLex "'norm' {dup * swap +} def"
Ok "" [SYM "norm",LBR,KWD "dup",ID "*",KWD "swap",ID "+",RBR,KWD "def"]</ghci></pre>

	<hr><task>У построенного нами лексического анализатора есть один досадный недостаток -- он плохо различает ключевые слова и идентификаторы. Смотрите:
	  <pre><ghci>λ> yodaLex "def define"
Ok "" [ID "def",KWD "def",ID "ine"]</ghci></pre>
Правильным было бы такое разделение:
	  <pre><ghci>λ> yodaLex "def define"
Ok "" [KWD "def",ID "define"]</ghci></pre>
Исправьте этот недостаток анализатора.
		     </task><hr>
		     
<details><summary>Общий взгляд на программу</summary>
<sinopsys>
<part>типы</part><basic>
<p>Result i a = Ok i a | Fail i<br/>
  (Show, Eq)</p>

<p>Parser a = Parser { run :: i -> Result i a }<br/>
  (Functor, Applicative, Monad, Monoid, Alternative)</p>
</basic>

<part>модификаторы</part>
<p><basic>neg </basic><der><$> <$</der></p>

<part>комбинаторы</part>
<p><basic><|>  >>=</basic>  <>  <der>>> (*>)</der><br/>
<der><*>  <*  <**></der></p>

<part>элементарные трансляторы</part>
<p><basic>empty pure</basic> (<der>return</der>)  epsilon </p>

<part>трансляторы для коллекций</part>
<p><basic>end next  check</basic>  term<br/>
oneof  except<br/>
<der>sequence replicateM mapM</der> seqn  sepBy  between<br/>
<der>some  many  optional</der> opt only <br/>
<der>mconcat </der>msome  mmany  mopt  collect  search <br/>
foldP</p>

<part>трансляторы для строк</part>
<p>digit  integer  string spaces expr  regexpr</p>

</sinopsys>
</details>


    
    </div>
    <script src='../lib/postprocess.js'></script>

  </body>
</html>

