<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>functor.html</title>
<style>
  code {
  background:yellow;
  fontfamily:serif;
  }
</style>
</head>

<body>

<p>Обычно ветвление в программировании происходит в особых точках -- при условных переходах или выборе исполняемого блока (процедуры). Но часто бывает так, что поток вычислений проще описать в виде линейного кода, предоставив процесс выбора альтернатив типам и их комбинаторам. Рассмотрим в качестве примера вычисления с частично-определёнными функциями, то есть функциями, которые могут не вернуть ожидаемое значение в каких-то паталогических случаях. Типичные примеры таких функций: извлечение квадратного корня из чисел, могущих быть отрицательными; возвращение элемента с указанным индексом из списка, или словаря; поиск элемента с указанным свойством в коллекции и т.д.</p>

<p>В императивном программировании в неопределённых случаях частичные функции либо вызывают исключение, либо возвращают некоторое "пустое" значение: null или undefined, либо возвращают код ошибки в виде числа, а результат помещают в глобальную переменную либо по ссылке. При этом в благополучном случае частичные функции возвращают полагающиеся им значения различных типов: строки, числа, объекты и т.п. </p>

<p>В функциональном языке со статической типизацией такое поведение частичных функций не годится (хотя и используется, но неохотно). Функция должна возвращать значение какого-то одного определённого типа, или суммы типов, но опять же, определённых на этапе компиляции. Исключение же возбуждается и ловится во время исполнения программы, к тому же, оно является побочным эффектом нарушает логическую стройность чистых программ. Но, в свою очередь, функциональное программирование предлагает своё решение для частичных функций, которое не только решает описанную нами проблему, но и является чрезвычайно мощным и универсальным способом организации вычислений, имеющим множество приложений.
Речь идёт о функторах -- типах, описывающих не только значение, но и контекст вычислений.</p>

<p>Начнём с использования функторов для описания частичных вычислений. Итак, постановка задачи такова. Имеется функция, имеющая тип a -> b, которая "обычно" возвращает некий тип b, но в некоторых случаях она этого сделать не может и не возвращает никакого значения. Для её описания нужен такой тип, который содержал бы в себе и тип b и возможность описать отсутствие значения. С этим справляется сумма типов:</p>

<pre><code>data Maybe a = Just a | Nothing
</code></pre>

<p>В левой части нет ничего необычного -- есть конструктор типа <code>Just</code> и единичный тип <code>Nothing</code>. А вот в правой у объявления типа <code>Maybe</code> появился параметр, задающий тип для всей суммы. С его помощью мы можем определить типы <code>Maybe Int</code>, <code>Maybe String</code>, <code>Maybe (a -&gt; b)</code> и т.д. Таким образом, кроме типа возвращаемого значения можно указать что значения может не быть.</p>

<p>Приведём пример сигнатур частичных функций, определённых таким способом:</p>

<pre><code>headSafe :: [a] -&gt; Maybe a

tailSafe :: [a] -&gt; Maybe [a]

sqrtSafe :: Real a =&gt; a -&gt; Maybe a

lookup :: a -&gt; [(a, b)] -&gt; Maybe b

find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
</code></pre>

<p>Работать с результатом таких функций можно так же как с любым типом-суммой: разбирая его с помощью сопоставления c образцом в определении функций или в форме case. Но существует более удобный способ работать с величиной не выходя из её контекста. </p>

<p>Вот как можно её использовать:</p>

<pre><code>&gt; fmap (* 5) (Just 6) 
Just 30

&gt; fmap (+ 1) (find odd [2,8,11,16,32]) 
Just 12

&gt; fmap (+ 1) (find odd [2,8,16,32]) 
Nothing

&gt; lookup "name" [("id","1212"),("name","John"),("age","32")]
Just "John"
</code></pre>

<p>Для этого служит универсальная функция fmap. Вот её тип:</p>

<pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>Здесь запись "Functor f =>" означает, что функция определена для любых типов f, являющихся функторами. Maybe является функтором </p>

<hr />

<p>С помощью <code>fmap</code> можно применить любую функцию к функтору не разрушая его. А что насчёт функций, которые сами возвращают функтор? Например, как можно дважды применить частично определённую функцию? Хорошим примером является функция <code>sqrtSafe</code>:</p>

<pre><code>sqrtSafe :: Double -&gt; Maybe Double
sqrtSafe x | x &lt; 0 = Nothing
           | x &gt;= 0 = Just (sqrt x)

&gt; sqrtSafe 16
Just 4.0

&gt; sqrtSafe &lt;$&gt; Just 4
Just (Just 2.0)
</code></pre>

<p>Результат мы получили, но он оказался в контексте дважды. Какой смысл имеет выражение <code>Just (Just x))</code>? С точки зрения "успешности" вычислений это просто успешное вычисление, то есть <code>(Just x)</code>. В свою очередь выражение <code>Just Nothing</code> означает, что вложенное вычисление окончилось неудачей, а вместе с ним и всё вычисление. Определим функцию <code>join</code>, которая занималась бы "соединением" контекстов:</p>

<pre><code>join :: Maybe (Maybe a) -&gt; Maybe a
join (Just x) = x
join Nothing = Nothing

&gt; join $ sqrtSafe &lt;$&gt; Just 2
Just 2.0
</code></pre>

<p>Связка <code>join $ f &lt;$&gt; x</code> универсальна и позволяет связывать в цепочки любые вычисления с контекстом. Для неё есть определённое в языке обозначение:</p>

<pre><code>f =&lt;&lt; x = join $ f &lt;$&gt; x
</code></pre>

<p>Посмотрим на тип оператора <code>=&lt;&lt;</code>:</p>

<pre><code>(=&lt;&lt;) :: (a -&gt; m b) -&gt; m a -&gt; m b
</code></pre>

<p>Он похож на тип <code>fmap</code>:</p>

<pre><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>Мы определили для функтора <code>Maybe</code> функцию <code>join</code> и сразу повысили её "ранг", позволяя объединять в цепочку функции возвращающие частичные значения. Функторы для которых определено соединение <code>join</code> называются <em>монадами</em>. </p>

<p>Чаще чем оператор <code>=&lt;&lt;</code> используется его аналог <code>&gt;&gt;=</code>, принимающий аргументы в обратном порядке:</p>

<pre><code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b

&gt; Just 9 &gt;&gt;= sqrtSafe
Just 3.0

&gt; Just 16 &gt;&gt;= sqrtSafe &gt;&gt;= sqrtSafe
Just 2.0

&gt; Just (-16) &gt;&gt;= sqrtSafe &gt;&gt;= sqrtSafe
Nothing
</code></pre>

<p>В последнем примере вычисления прекратились как только первый вычислитель корней вернул <code>Nothing</code>. Вычисления именно прекратились, в этом можно убедиться на таком примере:</p>

<pre><code>&gt; Just (-16) &gt;&gt;= sqrtSafe &gt;&gt;= undefined
Nothing
</code></pre>

<p>Получается, что частичные вычисления можно организовать не только безопасно, но и эффективно. Они работают как исключения, прекращая вычислительный процесс!</p>

<hr />

<p>Ну, а что ещё можно делать с функторами? Мы ещё не пытались применить к значениям с контекстом функций нескольких аргументов. Например, как сложить два частично определённых числа? Применим функцию <code>(+)</code> к значению <code>Just 5</code>:</p>

<pre><code>(+) &lt;$&gt; Just 5   ==&gt;   Just (+5)
</code></pre>

<p>Получили функцию внутри функтора <code>Maybe</code>. Применить её к частично определённому аргументу с помощью <code>fmap</code> не получится -- она не является функцией. Нужен некий оператор, имеющий такой тип:</p>

<pre><code>f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>его можно "собрать" из операторов <code>&lt;$&gt;</code> и <code>=&lt;&lt;</code>:</p>

<pre><code>&gt; (&lt;$&gt; Just 3) =&lt;&lt; Just (+4)
Just 7
</code></pre>

<p>Для этого действия определён оператор <code>&lt;*&gt;</code>:</p>

<pre><code>f &lt;*&gt; x  =  (&lt;$&gt; x) =&lt;&lt; f  =  join $ (&lt;$&gt; x) &lt;$&gt; f
</code></pre>

<p>Функторы для которых определена функция &lt;<em>> называются *аппликативными функторами</em>. Любая монада является аппликативным функтором, так как мы можем определить <code>&lt;*&gt;</code> через <code>=&lt;&lt;</code>. Однако класс аппликативных функторов шире класса монад. Посмотрим на действие оператора <code>&lt;*&gt;</code>:</p>

<pre><code>&gt; Just (+4) &lt;*&gt; Just 3
Just 7
</code></pre>

<p>или так</p>

<pre><code>&gt; (+) &lt;$&gt; Just 4 &lt;*&gt; Just 3
Just 7
</code></pre>

<p>или так</p>

<pre><code>&gt; Just (+) &lt;*&gt; Just 4 &lt;*&gt; Just 3
Just 7
</code></pre>

<p>Замечательно! Осталось одно добавление. Как ввести аргумент в контекст? Для частично-определённых функций это было очевидно -- мы использовали конструктор <code>Just</code>. Но рассуждая строго, для этого должна служить специальная функция <code>pure</code>,  определенная для любого аппликативного функтора. </p>

<p>Подведём итоги и классы типов для рассмотренных нами объектов: </p>

<p><em>Функтор</em> -- это тип для которого оперелена операция <code>fmap</code>.</p>

<pre><code>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p><em>Аппликативный функтор</em> -- это функтор, для которого определены функции <code>pure</code> и <code>&lt;*&gt;</code></p>

<pre><code>class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  &lt;*&gt;  :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p><em>Монада</em> -- это аппликативный функтор, для которого определена функция <code>&gt;&gt;=</code></p>

<pre><code>class Applicative f =&gt; Monad f where
   (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>

<p>Для определения оператора <code>&gt;&gt;=</code> удобно использовать функцию <code>join</code>:</p>

<pre><code> x &gt;&gt;= f = join $ f &lt;$&gt; x
</code></pre>

<p>Мы уже знаем, что тип <code>Maybe</code> -- это монада, а значит и аппликативный функтор. Вот как это определено в языке Haskell:</p>

<pre><code>data Maybe a = Nothing | Just a 

instance Functor Maybe where
  fmap _ Nothing = Nothing
  fmap f (Just x) = Just (f x)

instance Applicative Maybe where
  pure = Just

  Nothing &lt;*&gt; _ = Nothing 
  _ &lt;*&gt; Nothing = Nothing
  (Just f) &lt;*&gt; (Just x) = Just (f x)

instance Maybe Maybe where
  Nothing &gt;&gt;= _ = Nothing
  Just x  &gt;&gt;= f = f x
</code></pre>

<hr />

<p>Какие ещё есть полезные функторы и монады?</p>

<p>Тип <code>Maybe</code> представляет частичное значение, которого может не быть. Его логическим продолжением является списочный тип <code>[a]</code>, представляющий многозначные вычисления, то есть, множество (в том числе и пустое) возможных значений. Утверждение </p>

<pre><code>x = [2, 4, -6]
</code></pre>

<p>можно толковать как то, что <code>x</code> может принимать значения 2, 4 или -6. Значит, <code>fmap</code> показывает какими могут быть значения некоторой функции для значений <code>x</code>:</p>

<pre><code>f &lt;$&gt; x = [f 2, f 4, f (-6)]
</code></pre>

<p>то есть, для списков <code>fmap = map</code>. Прочие базовые функториальные операторы определены так:</p>

<pre><code>pure x = [x] 
join = concat
</code></pre>

<p>Посмотрим, как это работает:</p>

<pre><code>&gt; (+5) &lt;$&gt; [1..3]
[6,7,8]

&gt; (+) &lt;$&gt; [2,4] &lt;*&gt; [10,20,30]
[12,22,32,14,24,34]

&gt; [(+2),(*3),(^5)] &lt;*&gt; pure 3
[5,9,243]

&gt; [2,3] &gt;&gt;= \x -&gt; [-x,x]
[-2,2,-3,3]
</code></pre>

<p>Вот как можно определить многозначную функцию <code>sqrtMany</code></p>

<pre><code>sqrtMany x | x &lt; 0  = []
           | x == 0 = [0]
           | x &gt; 0  = let y = sqrt x in [y, -y]
</code></pre>

<p>Посчитаем с её помощью:</p>

<pre><code>&gt; sqrtMany 4
[2.0,-2.0]

&gt; sqrtMany (-4)
[]

&gt; sqrtMany (0)
[0]

&gt; (+) &lt;$&gt; sqrtMany 4 &lt;*&gt; sqrtMany 9
[5.0,-1.0,1.0,-5.0]

&gt; (+) &lt;$&gt; sqrtMany (-4) &lt;*&gt; sqrtMany 9
[]

&gt; (+) &lt;$&gt; sqrtMany 0 &lt;*&gt; sqrtMany 9
[3.0,-3.0]

&gt; [-9,0,9] &gt;&gt;= sqrtMany
[0.0,3.0,-3.0]

&gt; sqrtMany 16 &gt;&gt;= sqrtMany
[2.0,-2.0]
</code></pre>

<p>Последние два примера просто замечательны! Они показывают, как многозначные вычисления корректно обрабатывают невозможные результаты.</p>

<hr />

<p>Монаду, а значит и аппликативные функторы образуют и сами функции. Для них контекстом служит аргумент:</p>

<pre><code>fmap f x = f . x
pure = const
join f = \x -&gt; f x x


&gt; ((+5) &lt;$&gt; (*2)) 3      -- 3*2+5
11

&gt; (pure 5 &lt;$&gt; (*6)) 3    -- const 5 . 3*6
5

&gt; ((*5) &lt;$&gt; (pure 6)) 3  -- 5 * (const 5) 3
30
</code></pre>

<p>Аппликативность функции удобно использовать когда для одного аргумента нужно вычислить несколько функций, а потом объединить их:</p>

<pre><code>(f &lt;$&gt; g) x             = f (g x)
(f &lt;$&gt; g &lt;*&gt; h) x       = f (g x) (h x)
(f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; w) x = f (g x) (h x) (w x)


&gt; ((,) &lt;$&gt; (+5) &lt;*&gt; (*5)) 3
(8,15)

&gt; (max &lt;$&gt; (^2) &lt;*&gt; (*4)) 2
8

&gt; (max &lt;$&gt; (^2) &lt;*&gt; (*4)) &lt;$&gt; [0..6]
[0,4,8,12,16,25,36]

&gt; join (,) 5
(5,5)

&gt; join (*) 5
25
</code></pre>

<p>Монадические свойства функци используются редко. На их основе определена монада <code>Reader</code>, которая используется для вычислений где контекстом является некий параметр, задаваемый извне вычислений. Например -- параметр выполнения программы, настройки и т.д.</p>

<hr />

<p>Так же монадой является и пара, но только при условии, что её первый элемент это моноид. Первый элемент образует контекст для второго элемента, как бы помечает его.</p>

<pre><code>fmap f (x,y)     = (x, f y)
pure x           = (mempty, x)
join (x, (y, z)) = (x &lt;&gt; y, z)

&gt; (*5) &lt;$&gt; (3,4)
(3,20)

&gt; pure (+3) &lt;*&gt; ("ok",5)
("ok",8)

&gt; ("i am", (+3)) &lt;*&gt; (" ok",5)
("i am ok",8)

&gt; pure 7 &gt;&gt;= \x -&gt; (show x, x) &gt;&gt;= \y -&gt; ("+" ++ show y, y+x)
("7+7",14)
</code></pre>

<p>Монадические свойства пары используются для определения монады <code>Writer</code>, которая позволяет вести лог -- отчёт о вычислениях.</p>

<hr />

<p>Функторы <code>Maybe</code> и <code>[]</code> имеют одну общую особенность: для них определено значение, прекращающее вычисления: <code>Nothing</code> и <code>[]</code>, соответственно. Прерывание вычислений основано на следующих уравнениях:</p>

<pre><code>Nothing &lt;*&gt; _ = _ &lt;*&gt; Nothing  =  Nothing
     [] &lt;*&gt; _ = _ &lt;*&gt; []       =  []
</code></pre>

<p>Этот элемент играет ту же роль, что и нуль для операции умножения. Однако, в алгебре для операции сложения нуль выполняет роль нейтрального элемента. Можно ли определить такую операцию для этих функторов?</p>

<p>Оказывается, можно. Операция сложения обозначаемая <code>&lt;|&gt;</code> определена для альтернативных аппликативных функторов:</p>

<pre><code>class Applicative f =&gt; Alternative f where
  empty :: f a
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
</code></pre>

<p>Для неё верны равенства:</p>

<pre><code>empty &lt;|&gt; x = x &lt;|&gt; empty = x
</code></pre>

<p>Вот как этот оператор работает:</p>

<pre><code>&gt; Just 5 &lt;|&gt; Nothing
Just 5
&gt; Nothing &lt;|&gt; Just 5
Just 5
&gt; Just 6 &lt;|&gt; Just 5
Just 6
</code></pre>

<p>Для частичных вычислений возвращается первый удачный результат.</p>

<pre><code>&gt; [1,2,3] &lt;|&gt; []
[1,2,3]
&gt; [] &lt;|&gt; [1,2,3]
[1,2,3]
&gt; [1,2,3] &lt;|&gt; [4,5]
[1,2,3,4,5]
</code></pre>

<p>Для многозначных вычислений возвращается объединение результатов.</p>

<p>Вернёмся к функциям <code>sqrtSafe</code> и <code>sqrtMany</code> и объединим их в одну универсальную: sqrtSafe</p>

<pre><code>sqrtSafe :: Alternative f =&gt; Double -&gt; f Double
sqrtSafe x | x &lt; 0 = empty
           | x == 0 = pure 0
           | x &gt; 0 = let y = sqrt x in pure y &lt;|&gt; pure (-y)
</code></pre>

<p>Теперь мы не знаем какой именно функтор будет использоваться при работе с написанной нами функцией. Это можно определить явно:</p>

<pre><code>&gt; sqrtSafe 4 :: Maybe Double
Just 2.0

&gt; sqrtSafe 4 :: [Double]
[2.0,-2.0]
</code></pre>

<p>Или компилятор сам сможет вывести тип функтора, исходя из использования нашей функции</p>

<pre><code>&gt; Just 16 &gt;&gt;= sqrtSafe &gt;&gt;= sqrtSafe
Just 2

&gt; [16] &gt;&gt;= sqrtSafe &gt;&gt;= sqrtSafe
[2,-2]
</code></pre>

<p>Альтернативные вычисления можно использовать для изящной организации логики вычислений. Рассмотрим задачу о решении алгебраических уравнений методом бисекции на указанном отрезке:</p>

<ul>
<li>если на отрезке функция не меняет знака, считаем, что корней на нём нет</li>
<li>если отрезок достаточно мал (относительно искомой величины), возвращаем середину отрезка</li>
<li>иначе, ищем корень либо в левой половине отрезка, либо -- в правой.</li>
</ul>

<p>Вот как это алгоритм практически дословно описывается с помощью альтернативных функторов:</p>

<pre><code>bisection f a b | f a * f b &gt; 0 = empty
                | abs ((a - b) / c) &lt; 1e-14 = pure c
                | otherwise = bisection f a c &lt;|&gt; bisection f c b
  where c = (a + b) / 2

&gt; bisection (\x -&gt; x^2 - 2) 1 3 :: Maybe Double
Just 1.4142135623730958
&gt; bisection (\x -&gt; x^2 - 2) 1 3 :: [Double]
[1.4142135623730958]
</code></pre>

<p>А вот поиск нескольких корней функции на указанной решётке:</p>

<pre><code>findRoots f grid = case grid of
  a:b:c -&gt; bisection f a b &lt;|&gt; findRoots f (b:c)
  _     -&gt; empty
</code></pre>

<p>Если нас интересует только один корень:</p>

<pre><code>&gt; findRoots (\x -&gt; sin x - 0.5) [0..10] :: Maybe Double
Just 0.5235987755983
</code></pre>

<p>или все обнаруженные</p>

<pre><code>&gt; findRoots (\x -&gt; sin x - 0.5) [0..10] :: [Double]
[0.5235987755983,2.6179938779914878,6.806784082777909,8.90117918517106]
</code></pre>

<p>Какие ещё есть альтернативные функторы? Например, монада <code>IO</code>, в которой происходит взаимодействие чистых программ с внешним миром, является альтернативным функтором. Это значит, что мы можем вычислять наши универсальные функции в интерпретаторе:</p>

<pre><code>&gt; sqrtSafe 16
4.0

&gt; sqrtSafe 16 &gt;&gt;= sqrtSafe
2.0

&gt; findRoots (\x -&gt; sin x - 0.5) [0..10]
0.5235987755983

&gt; sqrtSafe (-16)
*** Exception: user error (mzero)
</code></pre>

<p>Как видно, при этом из альтернативных выбирается первый успешный вариант (как для <code>Maybe</code>), а нейтральным элементом является исключение. Необходимо помнить, что результаты вычислений не являются числами, они находятся в контексте ввода-вывода <code>IO</code>.</p>

<hr />

<p>В качестве развёрнутого примера построим интерпретатор для стекового калькулятора. Его задача вычислять арифметические выражения, записанные в обратной польской записи. Примеры его использования:</p>

<pre><code>&gt; calculate "2 3 +"
5
&gt; calculate "2 3 + 6 *"
30
&gt; calculate "2 3 6 * +"
20
</code></pre>

<p>Простейшая его реализация очень изящна и хорошо показывает принцип модульности: задача разбивается на отдельные логически замкнутые части (функции), которые комбинируюясь дают общее решение.</p>

<p>Начнём с описания интерпретации отдельных команд:</p>

<p>--------|-------|-----------
команда | стек  | результат
--------|-------|-----------
число n | s     | n:s
--------|-------|-----------
"+"     | x:y:s | (x + y):s
--------|-------|-----------
"*"     | x:y:s | (x * y):s
--------|-------|-----------
"-"     | x:y:s | (y - x):s
--------|-------|-----------
"/"     | x:y:s | (y / x):s
--------|-------|-----------</p>

<p>Как видно, мы оперируем стеком, содержащим числа и строковыми командами, которые управляют состоянием стека. Определим для них типы:</p>

<pre><code>type Command = String
type Stack = [Double]
</code></pre>

<p>Таблицу команд легко описать как определение функции <code>interprete</code>:</p>

<pre><code>interprete :: Command -&gt; Stack -&gt; Stack
interprete (x:y:s) "+" = (x+y):s
interprete (x:y:s) "*" = (x*y):s
interprete (x:y:s) "-" = (y-x):s
interprete (x:y:s) "/" = (y/x):s
interprete s n = (read n):s
</code></pre>

<p>С её помощью выражение <code>"2 3 +"</code> можно вычислить так:</p>

<pre><code>interprete (interprete (interprete [] "2") "3") "+"
</code></pre>

<p>Это же левая свёртка! Замечательно. Значит, наш калькулятор можно описать так:</p>

<pre><code>calculate :: String -&gt; Double
calculate = head . foldl interprete [] . words
</code></pre>

<p>Функция <code>words</code> разделяет строку на лексемы (числа и операторы), а свёртка осуществляет вычисления. </p>

<hr />

<p><em>Убедитесь в том, что калькулятор правильно производит вычисления для корректных выражений.</em></p>

<hr />

<p>Однако выражения могут быть и не корректными.</p>

<pre><code>&gt; calculate "2 3 * +"
*** Exception: Prelude.read: no parse
&gt; calculate "2 x *"
*** Exception: Prelude.read: no parse
&gt; calculate ""
*** Exception: Prelude.head: empty list
</code></pre>

<p>В первом случае для операции <code>"+"</code> не хватило аргументов, правда из сообщения об ошибке это совершенно не следует! Это очень нехорошо. Ошибки "лезут" изнутри программы и совершенно неинформативны. Немного усовершенствуем нашу функцию, заодно облегчив её синтаксис:</p>

<pre><code>interprete :: Command -&gt; Stack -&gt; Stack
interprete s op = case op of
  "+" -&gt; binop (+)
  "*" -&gt; binop (*)
  "-" -&gt; binop (-)
  "/" -&gt; binop (/)
  n   -&gt; case readMay n of
           Just x -&gt; x : s
           Nothing -&gt; error ("unknown command " ++ n)
  where
    binop f = case s of
      x:y:s -&gt; f x y : s
      [_]   -&gt; error "got only one argument"
      []    -&gt; error "got no arguments"
</code></pre>

<p>Здесь для контроля работы функции <code>read</code> мы воспользовались тотальной функцией <code>readMay</code> из библиотеки <code>Safe</code>, она идёт по правильному пути -- возвращает частично-определённое значение.</p>

<p>Ну, и функцию <code>calculate</code> надо немного подправить, чтобы ошибка соответствовала исключительной ситуации.</p>

<pre><code>calculate :: String -&gt; Double
calculate = head' . foldl interprete [] . words
  where head' [] = error "stack is empty"
        head' (x:_) = x
</code></pre>

<p>Теперь хотя бы сообщения об ошибках будут осмысленными, </p>

<pre><code>&gt; calculate "2 3 * +"
*** Exception: got only one argument
&gt; calculate "2 x *"
*** Exception: unknown command x
&gt; calculate ""
*** Exception: stack is empty
</code></pre>

<hr />

<p>Функция <code>calculate</code> работает ожидаемо, но она осталась нетотальной. Это значит, что она может привести в остановке исполнения программы. Правильным решением было бы сделать её тотальной, но частично-определённой, или многозначной. Давайте не будем ограничивать себя каким-либо определённым функтором, а потребуем лишь, чтобы он был альтернативным:</p>

<pre><code>interprete :: Alternative f =&gt; Stack -&gt; Command -&gt; f Stack
interprete s op = case op of
  "+" -&gt; binop (+)
  "*" -&gt; binop (*)
  "-" -&gt; binop (-)
  "/" -&gt; binop (/)
  n   -&gt; case readMay n of
           Just x -&gt; pure (x : s)
           Nothing -&gt; empty
  where
    binop f = case s of
      x:y:s -&gt; pure (f x y : s)
      [_]   -&gt; empty
      []    -&gt; empty
</code></pre>

<p>При этом мы теряем сообщения об ошибках, но это мы исправим позже. Более существенно то, что теперь не работает свёртка! Компилятор сообщает о том, что не может сопоставить типы <code>[Stack] -&gt; Command -&gt; [Stack]</code> и <code>Stack -&gt; Command -&gt; [Stack]</code>. Действительно, цепочка</p>

<pre><code>interprete (interprete (interprete [] "2") "3") "+"
</code></pre>

<p>больше не выполняется. Зато её можно посчитать так:</p>

<pre><code>&gt; pure [] &gt;&gt;= (`interprete` "2") &gt;&gt;= (`interprete` "3") &gt;&gt;= (`interprete` "+")
</code></pre>

<p>такую цепочку выполняет монадическая свёртка <code>foldM</code>:</p>

<pre><code>foldM f x = foldl (\res el -&gt; res &gt;&gt;= (`f` el)) (pure x)
</code></pre>

<p>Теперь можно переопределять функцию <code>calculate</code>, уточнив, что она работает монадами, являющимися и альтернативными функторами:</p>

<pre><code>calculate :: (Alternative f, Monad f) =&gt; String -&gt; f Stack
calculate = foldM interprete [] . words
</code></pre>

<p>Опробуем её работу на частичных значениях:</p>

<pre><code>&gt; calculate "2 3 +" :: Maybe Stack
Just [5]
&gt; calculate "2 3 + 6 *" :: Maybe Stack
Just [30]
&gt; calculate "2 3 * +" :: Maybe Stack
Nothing
&gt; calculate "2 x *" :: Maybe Stack
Nothing
&gt; calculate "2 x *" :: Maybe Stack
Nothing
</code></pre>

<p>Программа стала тотальной! Впрочем, никто не запрещает нам использовать её и в контексте <code>IO</code>, тогда её тотальность теряется. Но теперь это происходит контролируемо:</p>

<pre><code>&gt; calculate "2 3 + 6 *"
[30]
&gt; calculate "2 3 * +"
*** Exception: user error (mzero)
</code></pre>

<hr />

<p><em>Cделайте так,чтобы калькулятор возвращал не весь стек, а только верхнее его значение, оставаясь при этом тотальным.</em></p>

<hr />

<p>Пора вернуть в тотальную программу сообщения об ошибках. Такую возможность даёт тип <code>Either</code>, который является монадой, а значит и аппликативным функтором. Вот его определение:</p>

<pre><code>data Either a b = Left a | Right b
</code></pre>

<p>Этот тип похож на тип <code>Maybe</code> тем, что у него есть одно верное значение -- правое, и неверное -- левое. Но в отличие от <code>Nothing</code>, тип <code>Left</code> может нести в себе какую-либо информацию, например, сообщение об ошибке или код ошибки.</p>

<pre><code>&gt; (*8) &lt;$&gt; Right 5 
Right 40
&gt; (*8) &lt;$&gt; Left 5 
Left 5
&gt; (*8) &lt;$&gt; Left "a string" 
Left "a string"
&gt; Right (+6) &lt;*&gt; Right 50
Right 56
&gt; Left "not a function" &lt;*&gt; Right 50
Left "not a function"
</code></pre>

<p>Это хороший вариант для частичных вычислений с возможностью сообщить что пошло не так. Но есть одно но: тип <code>Either</code> не является альтернативным. Это связано с тем, что для списков и <code>Maybe</code> элемент <code>empty</code> единственен и определяется однозначно, тогда как для <code>Either</code> существует множество вариантов нулевых значений. Какой из них поставить в определение для <code>empty</code>? Но мы можем схитрить: пусть левым элементом будет какой-нибудь моноид, для него-то точно существует нулевой элемент. Ну, а раз так, то разумно будет не пренебрегать тем, что моноиды можно объединять, и использовать это свойство для объединении значений <code>Left</code>:</p>

<pre><code>instance Monoid m =&gt; Alternative (Either m) where
  empty = Left mempty
  Left x  &lt;|&gt; Left y = Left (x &lt;&gt; y)  -- объединение нейтральных элементов дистрибутивно
  Left _  &lt;|&gt; x      = x               -- нейтральный элемент для объединения
  Right x &lt;|&gt; _      = Right x         -- нулевой элемент для объединения
</code></pre>

<p>Посмотрим, как это работат:</p>

<pre><code>&gt; Left "fail" &lt;|&gt; Right 42
Right 42
&gt; Right 42 &lt;|&gt; Left "fail"
Right 42    
&gt; Left "I am " &lt;|&gt; Left "a fail"
Left "I am a fail"
</code></pre>

<p>Хорошо. Но как управлять сообщениями об ошибках? Ведь в нашей программе мы используем только <code>empty</code>? А если мы перепишем всё на контекст <code>Either</code>, то потеряем возможность лёгкого переключения между частично-определёнными и многозначными вычислениями, что было довольно удобно...</p>

<p>Итак, формулируем проблему. Нужно научиться вводить сообщения об ошибках, причём так, чтобы функторы <code>Maybe</code> и <code>[]</code> их игнорировали, а <code>Either</code> и <code>IO</code> использовали для сообщений об ошибках. И надо чтобы эта возможность была определена для всех четырёх контекстов сразу, иначе придётся переписывать функцию <code>interprete</code> для разных контестов, а это уже не DRY.</p>

<p>Раз требуется обеспечить разные типы одной функциональностью, надо определить свой класс типов. А в нём определить функцию, вводящую в нулевой элемент указанное сообщение. Назовём этот класс <code>Failable</code>, а функцию -- <code>message</code>.</p>

<pre><code>class (Alternative f) =&gt; Failable f where
  message :: String -&gt; f a
  message _ = empty   -- определение, используемое по умолчанию
</code></pre>

<p>и определим четыре экземляра. Для <code>Maybe</code> и <code>[]</code> используется определение функции <code>message</code>, данное в классе, а для <code>Either String</code> и <code>IO</code> -- специфические:</p>

<pre><code>instance Failable Maybe
instance Failable []
instance Failable (Either String) where message = Left
instance Failable IO where message = error
</code></pre>

<p>Осталось вернуть в функцию <code>interprete</code> сообщения об ошибках и уточнить, что она работает с контекстами из класса <code>Failable</code>:</p>

<pre><code>interprete :: Failable f =&gt; Stack -&gt; Command -&gt; f Stack
interprete s op = case op of
  "+" -&gt; binop (+)
  "*" -&gt; binop (*)
  "-" -&gt; binop (-)
  "/" -&gt; binop (/)
  n   -&gt; case readMay n of
           Just x -&gt; pure (x : s)
           Nothing -&gt; message ("unknown command " ++ n)
  where
    binop f = case s of
      x:y:s -&gt; pure (f x y : s)
      [_]   -&gt; message "got only one argument"
      []    -&gt; message "got no arguments"

calculate :: (Failable f, Monad f) =&gt; String -&gt; f [Double]
calculate =  foldM interprete [] . words
</code></pre>

<p>Начинаем испытания. Для этого напишем функцию выводящую результаты для всех четырёх контекстов:</p>

<pre><code>test s = do print (calculate s :: Maybe Stack)
            print (calculate s :: [Stack])
            print (calculate s :: Either String Stack)
            calculate s &gt;&gt;= print -- IO

 &gt; test "2 3 + 6 *"
 Just [30.0]
 [[30.0]]
 Right [30.0]
 [30.0]

 &gt; test "2 + 6 *"
 Nothing
 []
 Left "got only one argument"
 *** Exception: got only one argument

 &gt; test "2 x + 6 *"
 Nothing
 []
 Left "unknown command x"
 *** Exception: unknown command x
</code></pre>

<p>Добавим в калькулятор неоднозначную функцию <code>sqrt</code>:</p>

<pre><code>interprete :: (Monad f, Failable f) =&gt; Stack -&gt; Command -&gt; f Stack
interprete s op = case op of
  "+" -&gt; binop (+)
  "*" -&gt; binop (*)
  "-" -&gt; binop (-)
  "/" -&gt; binop (/)
  "sqrt" -&gt; operateM sqrtSafe &lt;|&gt; message "sqrt got negative argument"
  n   -&gt; case readMay n of
           Just x -&gt; pure (x : s)
           Nothing -&gt; message ("unknown command " ++ n)
  where
    binop f = case s of
      x:y:s -&gt; pure (f x y : s)
      [_]   -&gt; message "got only one argument"
      []    -&gt; message "got no arguments"

    operateM f = case s of
      x:s -&gt; (: s) &lt;$&gt; f x
      []  -&gt; message "got no arguments"
</code></pre>

<p>Достаточно изящно, не правда ли? мы получили и неоднозначность и возможность вывода сообщения об ошибке при необходимости.</p>

<hr />

<p>Нет предела совершенству. Функторы и монады могут позволить разбить задачу на ещё более мелкие автономные части, легко и однообразно комбинируемые. </p>

<p>Начнём немного издалека. Разработаем тип для обработки последовательностей значений -- парсинга. В нём мы объединими все ключевые типы функторов -- функции, пары и контексты для альтернативных вычислений. Парсер -- это функция, которая, получив последовательность, возвращает результат разбора и остаток неразобранной последовательности. Отразим это описание в типе:</p>

<pre><code>                                     результат     остаток последовательности
                                             |     |
data Parser f seq res = Parser ([seq] -&gt; f (res, [seq]))
                                  |      |
                                  |      функтор
                                  |
                                  разбираемая последовательность
</code></pre>

<p>Функтор <code>f</code> отражает то, что результат может по каким-то причинам не получиться.</p>

<p>Так мы сможем "запускать разбор", то есть, применять спрятанную в конструктор типа функцию.</p>

<pre><code>run (Parser p) s = p s
</code></pre>

<p>Посмотрим, как работает наш первый парсер:</p>

<pre><code>&gt; run pop [1,2,3]
(1,[2,3])
</code></pre>

<p>Элементарной операцией при работе с последовательностью является операция считывания следующего элемента: <code>pop</code>. Это частично-определённая функция, для пустой последовательности она должна возвращать ошибку (или пустой элемент):</p>

<pre><code>pop :: Failable f =&gt; Parser f a a
pop = Parser (\case -&gt; [] -&gt; empty
                       x:xs -&gt; pure (x, xs))
</code></pre>

<p>Если бы смогли сделать тип <code>Parser</code> аппликативным функтором, то можно было бы комбинировать парсеры и их результаты: </p>

<pre><code>(+5) &lt;$&gt; pop   -- считать первый элемент и увеличить результат на 5
(+) &lt;$&gt; pop &lt;*&gt; pop -- считать два элемента и сложить их результаты
</code></pre>

<p>Это было очень удобно. Но ещё удобнее было бы писать как-нибудь так:</p>

<pre><code>sqrt &lt;$&gt; nonnegative    -- считать элемент, удостовериться в том, что он положителен и вычислить квадратный корень  из результата
(/) &lt;$&gt; nonzero &lt;*&gt; pop -- считать элемент, удостовериться в том, что он не равен нулю, считать следующий, а потом вычислить их отношение
</code></pre>

</body>
</html>
